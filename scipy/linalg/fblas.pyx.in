#cython: ccomplex=True

"""
The fblas module was generated with Fwrap v0.2.0dev_2a63538.

Below is a listing of functions and data types.
For usage information see the function docstrings.

Functions
---------
chemv, zhemv(...)
csrot(...)
csscal(...)
dzasum(...)
dznrm2(...)
isamax, idamax, icamax, izamax(...)
sasum, dasum(...)
saxpy, daxpy, caxpy, zaxpy(...)
scasum(...)
scnrm2(...)
scopy, dcopy, ccopy, zcopy(...)
sdot, ddot, cdotc, cdotu, zdotc, zdotu(...)
sgemm, dgemm, cgemm, zgemm(...)
sgemv, dgemv, cgemv, zgemv(...)
sger, dger, cgerc, cgeru, zgerc, zgeru(...)
snrm2, dnrm2(...)
srot, drot(...)
srotg, drotg, crotg, zrotg(...)
srotm, drotm(...)
srotmg, drotmg(...)
sscal, dscal, cscal, zscal(...)
sswap, dswap, cswap, zswap(...)
ssymv, dsymv(...)
strmv, dtrmv, ctrmv, ztrmv(...)
zdrot(...)
zdscal(...)

Data Types
----------
fw_character
fw_shape
fwc_complex
fwc_complex_x16
fwc_dbl_complex
fwi_integer
fwr_dbl
fwr_real

"""
np.import_array()
include 'fwrap_ktp.pxi'
cdef extern from "string.h":
    void *memcpy(void *dest, void *src, size_t n)
{{for fc_name, ktp, name, npy_enum
      in zip(['chemv_c', 'zhemv_c'],
             ['fwc_complex_t', 'fwc_dbl_complex_t'],
             ['chemv', 'zhemv'],
             ['fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}({{ktp}} alpha, object a, object x, {{ktp}} beta, object y, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1, fwi_integer_t lower=0, bint overwrite_y=False):
    """
    {{name}}(alpha, a, x, beta, y, offx, incx, offy, incy, lower, overwrite_y) -> y

    Parameters
    ----------
    alpha : {{ktp}}_, intent in
    a : {{ktp}}_, 2D array, dimension(n, n), intent in
    x : {{ktp}}_, 1D array, dimension(*), intent in
    beta : {{ktp}}_, intent in
    y : {{ktp}}_, 1D array, dimension(*), intent inout
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in
    lower : fwi_integer, intent in
    overwrite_y : bint_, intent in

    Returns
    -------
    y : {{ktp}}_, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef fwi_integer_t n
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    y_, y = fw_asfortranarray(y, {{npy_enum}}, 1, not overwrite_y)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, False)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((offy >= 0) and (offy < np.PyArray_DIMS(y_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offy >= 0) and (offy < np.PyArray_DIMS(y)[0])')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not (np.PyArray_DIMS(x_)[0] > (offx + ((n - 1) * abs(incx)))):
        raise ValueError('Condition on arguments not satisfied: np.PyArray_DIMS(x)[0] > (offx + ((n - 1) * abs(incx)))')
    if not (np.PyArray_DIMS(y_)[0] > (offy + ((n - 1) * abs(incy)))):
        raise ValueError('Condition on arguments not satisfied: np.PyArray_DIMS(y)[0] > (offy + ((n - 1) * abs(incy)))')
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_uplo_f, &n, &alpha, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &n, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, &beta, y_shape_, <{{ktp}}*>np.PyArray_DATA(y_) + offy, &incy, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return y
{{endfor}}


cpdef api object csrot(object x, object y, fwr_real_t c, fwr_real_t s, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1, bint overwrite_x=False, bint overwrite_y=False):
    """
    csrot(x, y, c, s, n, offx, incx, offy, incy, overwrite_x, overwrite_y) -> (x, y)

    Parameters
    ----------
    x : fwc_complex, 1D array, dimension(*), intent inout
    y : fwc_complex, 1D array, dimension(*), intent inout
    c : fwr_real, intent in
    s : fwr_real, intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in
    overwrite_x : bint_, intent in
    overwrite_y : bint_, intent in

    Returns
    -------
    x : fwc_complex, 1D array, dimension(*), intent inout
    y : fwc_complex, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, fwc_complex_t_enum, 1, not overwrite_x)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    y_, y = fw_asfortranarray(y, fwc_complex_t_enum, 1, not overwrite_y)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((np.PyArray_DIMS(y_)[0] - offy) > ((n_ - 1) * abs(incy))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(y)[0] - offy) > ((n - 1) * abs(incy))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((offy >= 0) and (offy < np.PyArray_DIMS(y_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offy >= 0) and (offy < np.PyArray_DIMS(y)[0])')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    csrot_c(&n_, x_shape_, <fwc_complex_t*>np.PyArray_DATA(x_) + offx, &incx, y_shape_, <fwc_complex_t*>np.PyArray_DATA(y_) + offy, &incy, &c, &s, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'csrot' wrapper.")
    return (x, y,)


cpdef api object csscal(fwr_real_t a, object x, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1, bint overwrite_x=False):
    """
    csscal(a, x, n, offx, incx, overwrite_x) -> x

    Parameters
    ----------
    a : fwr_real, intent in
    x : fwc_complex, 1D array, dimension(*), intent inout
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    overwrite_x : bint_, intent in

    Returns
    -------
    x : fwc_complex, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, fwc_complex_t_enum, 1, not overwrite_x)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    csscal_c(&n_, &a, x_shape_, <fwc_complex_t*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'csscal' wrapper.")
    return x


cpdef api object dzasum(object x, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1):
    """
    dzasum(x, n, offx, incx) -> fw_ret_arg

    Parameters
    ----------
    x : fwc_dbl_complex, 1D array, dimension(*), intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in

    Returns
    -------
    fw_ret_arg : fwr_dbl, intent out

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fwr_dbl_t fw_ret_arg
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, fwc_dbl_complex_t_enum, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    dzasum_c(&fw_ret_arg, &n_, x_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'dzasum' wrapper.")
    return fw_ret_arg


cpdef api object dznrm2(object x, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1):
    """
    dznrm2(x, n, offx, incx) -> fw_ret_arg

    Parameters
    ----------
    x : fwc_dbl_complex, 1D array, dimension(*), intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in

    Returns
    -------
    fw_ret_arg : fwr_dbl, intent out

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fwr_dbl_t fw_ret_arg
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, fwc_dbl_complex_t_enum, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    dznrm2_c(&fw_ret_arg, &n_, x_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'dznrm2' wrapper.")
    return fw_ret_arg


{{for fc_name, ktp, name, npy_enum
      in zip(['isamax_c', 'idamax_c', 'icamax_c', 'izamax_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['isamax', 'idamax', 'icamax', 'izamax'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object x, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1):
    """
    {{name}}(n, x, incx) -> (fw_ret_arg, n, x, incx)

    Parameters
    ----------
    n : fwi_integer, intent inout
    x : {{ktp}}_, 1D array, dimension(*), intent inout
    incx : fwi_integer, intent inout

    Returns
    -------
    fw_ret_arg : fwi_integer, intent out
    n : fwi_integer, intent inout
    x : {{ktp}}_, 1D array, dimension(*), intent inout
    incx : fwi_integer, intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t fw_ret_arg
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    n_ = n if n is not None else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if offx < 0 or offx >= np.PyArray_DIMS(x_)[0]:
        raise ValueError("Not satisfied: offx>=0 and offx<len(x)")
    if not incx != 0:
        raise ValueError("Not satisfied: incx != 0")
    if not (np.PyArray_DIMS(x_)[0] - offx) > (n_-1)*abs(incx):
        raise ValueError("Not satisfied: len(x)-offx>(n-1)*abs(incx)")
    x_shape_[0] -= offx
    {{fc_name}}(&fw_ret_arg, &n_, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    
    fw_ret_arg -= 1 # Convert Fortran index to Python index
    
    return fw_ret_arg
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sasum_c', 'dasum_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['sasum', 'dasum'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object x, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1):
    """
    {{name}}(x, n, offx, incx) -> fw_ret_arg

    Parameters
    ----------
    x : {{ktp}}_, 1D array, dimension(*), intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in

    Returns
    -------
    fw_ret_arg : {{ktp}}_, intent out

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef {{ktp}} fw_ret_arg
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    {{fc_name}}(&fw_ret_arg, &n_, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return fw_ret_arg
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['saxpy_c', 'daxpy_c', 'caxpy_c', 'zaxpy_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['saxpy', 'daxpy', 'caxpy', 'zaxpy'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object x, object y, object n=None, {{ktp}} a=1., fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1):
    """
    {{name}}(x, y, n, a, offx, incx, offy, incy) -> y

    Parameters
    ----------
    x : {{ktp}}_, 1D array, dimension(*), intent in
    y : {{ktp}}_, 1D array, dimension(*), intent inout
    n : fwi_integer, intent in
    a : {{ktp}}_, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in

    Returns
    -------
    y : {{ktp}}_, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    y_, y = fw_asfortranarray(y, {{npy_enum}}, 1, False)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((np.PyArray_DIMS(y_)[0] - offy) > ((n_ - 1) * abs(incy))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(y)[0] - offy) > ((n - 1) * abs(incy))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((offy >= 0) and (offy < np.PyArray_DIMS(y_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offy >= 0) and (offy < np.PyArray_DIMS(y)[0])')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    {{fc_name}}(&n_, &a, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, y_shape_, <{{ktp}}*>np.PyArray_DATA(y_) + offy, &incy, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return y
{{endfor}}


cpdef api object scasum(object x, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1):
    """
    scasum(x, n, offx, incx) -> fw_ret_arg

    Parameters
    ----------
    x : fwc_complex, 1D array, dimension(*), intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in

    Returns
    -------
    fw_ret_arg : fwr_real, intent out

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fwr_real_t fw_ret_arg
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, fwc_complex_t_enum, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    scasum_c(&fw_ret_arg, &n_, x_shape_, <fwc_complex_t*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'scasum' wrapper.")
    return fw_ret_arg


cpdef api object scnrm2(object x, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1):
    """
    scnrm2(x, n, offx, incx) -> fw_ret_arg

    Parameters
    ----------
    x : fwc_complex, 1D array, dimension(*), intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in

    Returns
    -------
    fw_ret_arg : fwr_real, intent out

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fwr_real_t fw_ret_arg
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, fwc_complex_t_enum, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    scnrm2_c(&fw_ret_arg, &n_, x_shape_, <fwc_complex_t*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'scnrm2' wrapper.")
    return fw_ret_arg


{{for fc_name, ktp, name, npy_enum
      in zip(['scopy_c', 'dcopy_c', 'ccopy_c', 'zcopy_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['scopy', 'dcopy', 'ccopy', 'zcopy'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object x, object y, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1):
    """
    {{name}}(x, y, n, offx, incx, offy, incy) -> y

    Parameters
    ----------
    x : {{ktp}}_, 1D array, dimension(*), intent in
    y : {{ktp}}_, 1D array, dimension(*), intent inout
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in

    Returns
    -------
    y : {{ktp}}_, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    y_, y = fw_asfortranarray(y, {{npy_enum}}, 1, False)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((np.PyArray_DIMS(y_)[0] - offy) > ((n_ - 1) * abs(incy))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(y)[0] - offy) > ((n - 1) * abs(incy))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((offy >= 0) and (offy < np.PyArray_DIMS(y_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offy >= 0) and (offy < np.PyArray_DIMS(y)[0])')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    {{fc_name}}(&n_, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, y_shape_, <{{ktp}}*>np.PyArray_DATA(y_) + offy, &incy, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return y
{{endfor}}


{{for fc_name, ktp, name, name2, npy_enum
      in zip(['sdot_c', 'ddot_c', 'cdotc_c', 'cdotu_c', 'zdotc_c', 'zdotu_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_complex_t', 'fwc_dbl_complex_t', 'fwc_dbl_complex_t'],
             ['sdot', 'ddot', 'cdotc', 'cdotu', 'zdotc', 'zdotu'],
             ['fw_ret_arg', 'fw_ret_arg', 'xy', 'xy', 'xy', 'xy'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object x, object y, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1):
    """
    {{name}}(x, y, n, offx, incx, offy, incy) -> {{name2}}

    Parameters
    ----------
    x : {{ktp}}_, 1D array, dimension(*), intent in
    y : {{ktp}}_, 1D array, dimension(*), intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in

    Returns
    -------
    {{name2}} : {{ktp}}_, intent out

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef {{ktp}} {{name2}}
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    y_, y = fw_asfortranarray(y, {{npy_enum}}, 1, False)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((np.PyArray_DIMS(y_)[0] - offy) > ((n_ - 1) * abs(incy))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(y)[0] - offy) > ((n - 1) * abs(incy))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((offy >= 0) and (offy < np.PyArray_DIMS(y_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offy >= 0) and (offy < np.PyArray_DIMS(y)[0])')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    {{fc_name}}(&{{name2}}, &n_, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, y_shape_, <{{ktp}}*>np.PyArray_DATA(y_) + offy, &incy, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return {{name2}}
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sgemm_c', 'dgemm_c', 'cgemm_c', 'zgemm_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgemm', 'dgemm', 'cgemm', 'zgemm'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}({{ktp}} alpha, object a, object b, {{ktp}} beta=0.0, object c=None, fwi_integer_t trans_a=0, fwi_integer_t trans_b=0, bint overwrite_c=False):
    """
    {{name}}(alpha, a, b, beta, trans_a, trans_b, overwrite_c, [c]) -> c

    Parameters
    ----------
    alpha : {{ktp}}_, intent in
    a : {{ktp}}_, 2D array, dimension(lda, ka), intent in
    b : {{ktp}}_, 2D array, dimension(ldb, kb), intent in
    beta : {{ktp}}_, intent in
    c : {{ktp}}_, 2D array, dimension(m, n), intent inout
    trans_a : fwi_integer, intent in
    trans_b : fwi_integer, intent in
    overwrite_c : bint_, intent in

    Returns
    -------
    c : {{ktp}}_, 2D array, dimension(m, n), intent inout

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray c_
    cdef fw_shape_t c_shape_[2]
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t k
    cdef fwi_integer_t lda
    cdef fwi_integer_t ka
    cdef fwi_integer_t ldb
    cdef fwi_integer_t kb
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_transa_f = [0, 0]
    cdef char *fw_transb_f = [0, 0]
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, False)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    lda = np.PyArray_DIMS(a_)[0]
    ka = np.PyArray_DIMS(a_)[1]
    m = ka if trans_a else lda
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, False)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    ldb = np.PyArray_DIMS(b_)[0]
    kb = np.PyArray_DIMS(b_)[1]
    n = ldb if trans_b else kb
    c_, c = fw_explicitshapearray(c, {{npy_enum}}, 2, [m, n], not overwrite_c)
    fw_copyshape(c_shape_, np.PyArray_DIMS(c_), 2)
    transa_f = ("C" if (trans_a == 2) else "T") if trans_a else "N"
    transb_f = ("C" if (trans_b == 2) else "T") if trans_b else "N"
    k = lda if trans_a else ka
    if not ((trans_a >= 0) and (trans_a <= 2)):
        raise ValueError('Condition on arguments not satisfied: (trans_a >= 0) and (trans_a <= 2)')
    if not ((trans_b >= 0) and (trans_b <= 2)):
        raise ValueError('Condition on arguments not satisfied: (trans_b >= 0) and (trans_b <= 2)')
    if not ((kb == k) if trans_b else (ldb == k)):
        raise ValueError('Condition on arguments not satisfied: (kb == k) if trans_b else (ldb == k)')
    fw_transa_f[0] = fw_aschar(transa_f)
    if fw_transa_f[0] == 0:
        raise ValueError("len(transa_f) != 1")
    fw_transb_f[0] = fw_aschar(transb_f)
    if fw_transb_f[0] == 0:
        raise ValueError("len(transb_f) != 1")
    {{fc_name}}(fw_transa_f, fw_transb_f, &m, &n, &k, &alpha, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb, &beta, c_shape_, <{{ktp}}*>np.PyArray_DATA(c_), &m, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return c
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sgemv_c', 'dgemv_c', 'cgemv_c', 'zgemv_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgemv', 'dgemv', 'cgemv', 'zgemv'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}({{ktp}} alpha, object a, object x, {{ktp}} beta=0.0, object y=None, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1, fwi_integer_t trans=0, bint overwrite_y=False):
    """
    {{name}}(alpha, a, x, beta, offx, incx, offy, incy, trans, overwrite_y, [y]) -> y

    Parameters
    ----------
    alpha : {{ktp}}_, intent in
    a : {{ktp}}_, 2D array, dimension(m, n), intent in
    x : {{ktp}}_, 1D array, dimension(*), intent in
    beta : {{ktp}}_, intent in
    y : {{ktp}}_, 1D array, dimension(ly), intent inout
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in
    trans : fwi_integer, intent in
    overwrite_y : bint_, intent in

    Returns
    -------
    y : {{ktp}}_, 1D array, dimension(ly), intent inout

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t rows
    cdef fwi_integer_t cols
    cdef fwi_integer_t ly
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_trans_f = [0, 0]
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    trans_f = ("C" if (trans == 2) else "T") if trans else "N"
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, False)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    m = np.PyArray_DIMS(a_)[0]
    n = np.PyArray_DIMS(a_)[1]
    rows = n if trans else m
    cols = m if trans else n
    if y is None:
        ly = 1 + offy + (rows - 1) * abs(incy)
    else:
        ly = -1
    y_, y = fw_explicitshapearray(y, {{npy_enum}}, 1, [ly], not overwrite_y)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    if not ((trans >= 0) and (trans <= 2)):
        raise ValueError('Condition on arguments not satisfied: (trans >= 0) and (trans <= 2)')
    fw_trans_f[0] = fw_aschar(trans_f)
    if fw_trans_f[0] == 0:
        raise ValueError("len(trans_f) != 1")
    {{fc_name}}(fw_trans_f, &m, &n, &alpha, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &m, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, &beta, y_shape_, <{{ktp}}*>np.PyArray_DATA(y_) + offy, &incy, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return y
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sger_c', 'dger_c', 'cgerc_c', 'cgeru_c', 'zgerc_c', 'zgeru_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_complex_t', 'fwc_dbl_complex_t', 'fwc_dbl_complex_t'],
             ['sger', 'dger', 'cgerc', 'cgeru', 'zgerc', 'zgeru'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}({{ktp}} alpha, object x, object y, fwi_integer_t incx=1, fwi_integer_t incy=1, object a=None, bint overwrite_x=True, bint overwrite_y=True, bint overwrite_a=False):
    """
    {{name}}(alpha, x, y, incx, incy, overwrite_x, overwrite_y, overwrite_a, [a]) -> a

    Parameters
    ----------
    alpha : {{ktp}}_, intent in
    x : {{ktp}}_, 1D array, dimension(m), intent in
    y : {{ktp}}_, 1D array, dimension(n), intent in
    incx : fwi_integer, intent in
    incy : fwi_integer, intent in
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    overwrite_x : bint_, intent in
    overwrite_y : bint_, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t lda
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, not overwrite_x)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    m = np.PyArray_DIMS(x_)[0]
    y_, y = fw_asfortranarray(y, {{npy_enum}}, 1, not overwrite_y)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    n = np.PyArray_DIMS(y_)[0]
    a_, a = fw_explicitshapearray(a, {{npy_enum}}, 2, [m, n], not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    lda = m
    if not ((incx == 1) or (incx == -1)):
        raise ValueError('Condition on arguments not satisfied: (incx == 1) or (incx == -1)')
    if not ((incy == 1) or (incy == -1)):
        raise ValueError('Condition on arguments not satisfied: (incy == 1) or (incy == -1)')
    {{fc_name}}(&m, &n, &alpha, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_), &incx, y_shape_, <{{ktp}}*>np.PyArray_DATA(y_), &incy, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return a
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['snrm2_c', 'dnrm2_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['snrm2', 'dnrm2'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object x, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1):
    """
    {{name}}(x, n, offx, incx) -> fw_ret_arg

    Parameters
    ----------
    x : {{ktp}}_, 1D array, dimension(*), intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in

    Returns
    -------
    fw_ret_arg : {{ktp}}_, intent out

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef {{ktp}} fw_ret_arg
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    {{fc_name}}(&fw_ret_arg, &n_, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return fw_ret_arg
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['srot_c', 'drot_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['srot', 'drot'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object x, object y, {{ktp}} c, {{ktp}} s, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1, bint overwrite_x=False, bint overwrite_y=False):
    """
    {{name}}(x, y, c, s, n, offx, incx, offy, incy, overwrite_x, overwrite_y) -> (x, y)

    Parameters
    ----------
    x : {{ktp}}_, 1D array, dimension(*), intent inout
    y : {{ktp}}_, 1D array, dimension(*), intent inout
    c : {{ktp}}_, intent in
    s : {{ktp}}_, intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in
    overwrite_x : bint_, intent in
    overwrite_y : bint_, intent in

    Returns
    -------
    x : {{ktp}}_, 1D array, dimension(*), intent inout
    y : {{ktp}}_, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, not overwrite_x)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    y_, y = fw_asfortranarray(y, {{npy_enum}}, 1, not overwrite_y)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((np.PyArray_DIMS(y_)[0] - offy) > ((n_ - 1) * abs(incy))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(y)[0] - offy) > ((n - 1) * abs(incy))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((offy >= 0) and (offy < np.PyArray_DIMS(y_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offy >= 0) and (offy < np.PyArray_DIMS(y)[0])')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    {{fc_name}}(&n_, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, y_shape_, <{{ktp}}*>np.PyArray_DATA(y_) + offy, &incy, &c, &s, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (x, y,)
{{endfor}}


{{for fc_name, ktp, ktp_real, name
      in zip(['srotg_c', 'drotg_c', 'crotg_c', 'zrotg_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwr_real_t', 'fwr_dbl_t'],
             ['srotg', 'drotg', 'crotg', 'zrotg'])}}
cpdef api object {{name}}({{ktp}} a, {{ktp}} b):
    """
    {{name}}(a, b) -> (c, s)

    Parameters
    ----------
    a : {{ktp}}_, intent in
    b : {{ktp}}_, intent in

    Returns
    -------
    c : {{ktp}}_, intent out
    s : {{ktp}}_, intent out

    """
    cdef fwi_integer_t fw_iserr__
    cdef {{ktp_real}} c
    cdef {{ktp}} s
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    {{fc_name}}(&a, &b, &c, &s, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (<{{ktp}}>c, s,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['srotm_c', 'drotm_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['srotm', 'drotm'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object x, object y, object param, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1, bint overwrite_x=False, bint overwrite_y=False):
    """
    {{name}}(x, y, param, n, offx, incx, offy, incy, overwrite_x, overwrite_y) -> (x, y)

    Parameters
    ----------
    x : {{ktp}}_, 1D array, dimension(*), intent inout
    y : {{ktp}}_, 1D array, dimension(*), intent inout
    param : {{ktp}}_, 1D array, dimension(5), intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in
    overwrite_x : bint_, intent in
    overwrite_y : bint_, intent in

    Returns
    -------
    x : {{ktp}}_, 1D array, dimension(*), intent inout
    y : {{ktp}}_, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef np.ndarray param_
    cdef fw_shape_t param_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    param_, param = fw_asfortranarray(param, {{npy_enum}}, 1, False)
    fw_copyshape(param_shape_, np.PyArray_DIMS(param_), 1)
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, not overwrite_x)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    y_, y = fw_asfortranarray(y, {{npy_enum}}, 1, not overwrite_y)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((np.PyArray_DIMS(y_)[0] - offy) > ((n_ - 1) * abs(incy))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(y)[0] - offy) > ((n - 1) * abs(incy))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((offy >= 0) and (offy < np.PyArray_DIMS(y_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offy >= 0) and (offy < np.PyArray_DIMS(y)[0])')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    {{fc_name}}(&n_, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, y_shape_, <{{ktp}}*>np.PyArray_DATA(y_) + offy, &incy, param_shape_, <{{ktp}}*>np.PyArray_DATA(param_), &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (x, y,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['srotmg_c', 'drotmg_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['srotmg', 'drotmg'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}({{ktp}} d1, {{ktp}} d2, {{ktp}} x1, {{ktp}} y1, object param=None):
    """
    {{name}}(d1, d2, x1, y1, [param]) -> param

    Parameters
    ----------
    d1 : {{ktp}}_, intent in
    d2 : {{ktp}}_, intent in
    x1 : {{ktp}}_, intent in
    y1 : {{ktp}}_, intent in
    param : {{ktp}}_, 1D array, dimension(5), intent out

    Returns
    -------
    param : {{ktp}}_, 1D array, dimension(5), intent out

    """
    cdef np.ndarray param_
    cdef fw_shape_t param_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    param_, param = fw_explicitshapearray(param, {{npy_enum}}, 1, [5], False)
    fw_copyshape(param_shape_, np.PyArray_DIMS(param_), 1)
    {{fc_name}}(&d1, &d2, &x1, &y1, param_shape_, <{{ktp}}*>np.PyArray_DATA(param_), &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return param
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sscal_c', 'dscal_c', 'cscal_c', 'zscal_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sscal', 'dscal', 'cscal', 'zscal'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}({{ktp}} a, object x, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1):
    """
    {{name}}(a, x, n, offx, incx) -> x

    Parameters
    ----------
    a : {{ktp}}_, intent in
    x : {{ktp}}_, 1D array, dimension(*), intent inout
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in

    Returns
    -------
    x : {{ktp}}_, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    {{fc_name}}(&n_, &a, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return x
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sswap_c', 'dswap_c', 'cswap_c', 'zswap_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sswap', 'dswap', 'cswap', 'zswap'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object x, object y, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1):
    """
    {{name}}(x, y, n, offx, incx, offy, incy) -> (x, y)

    Parameters
    ----------
    x : {{ktp}}_, 1D array, dimension(*), intent inout
    y : {{ktp}}_, 1D array, dimension(*), intent inout
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in

    Returns
    -------
    x : {{ktp}}_, 1D array, dimension(*), intent inout
    y : {{ktp}}_, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    y_, y = fw_asfortranarray(y, {{npy_enum}}, 1, False)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((np.PyArray_DIMS(y_)[0] - offy) > ((n_ - 1) * abs(incy))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(y)[0] - offy) > ((n - 1) * abs(incy))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((offy >= 0) and (offy < np.PyArray_DIMS(y_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offy >= 0) and (offy < np.PyArray_DIMS(y)[0])')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    {{fc_name}}(&n_, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, y_shape_, <{{ktp}}*>np.PyArray_DATA(y_) + offy, &incy, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (x, y,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['ssymv_c', 'dsymv_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['ssymv', 'dsymv'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}({{ktp}} alpha, object a, object x, {{ktp}} beta, object y, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1, fwi_integer_t lower=0, bint overwrite_y=False):
    """
    {{name}}(alpha, a, x, beta, y, offx, incx, offy, incy, lower, overwrite_y) -> y

    Parameters
    ----------
    alpha : {{ktp}}_, intent in
    a : {{ktp}}_, 2D array, dimension(n, n), intent in
    x : {{ktp}}_, 1D array, dimension(*), intent in
    beta : {{ktp}}_, intent in
    y : {{ktp}}_, 1D array, dimension(*), intent inout
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in
    lower : fwi_integer, intent in
    overwrite_y : bint_, intent in

    Returns
    -------
    y : {{ktp}}_, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef fwi_integer_t n
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, False)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    y_, y = fw_asfortranarray(y, {{npy_enum}}, 1, not overwrite_y)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, False)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((offy >= 0) and (offy < np.PyArray_DIMS(y_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offy >= 0) and (offy < np.PyArray_DIMS(y)[0])')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not (np.PyArray_DIMS(x_)[0] > (offx + ((n - 1) * abs(incx)))):
        raise ValueError('Condition on arguments not satisfied: np.PyArray_DIMS(x)[0] > (offx + ((n - 1) * abs(incx)))')
    if not (np.PyArray_DIMS(y_)[0] > (offy + ((n - 1) * abs(incy)))):
        raise ValueError('Condition on arguments not satisfied: np.PyArray_DIMS(y)[0] > (offy + ((n - 1) * abs(incy)))')
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_uplo_f, &n, &alpha, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &n, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, &beta, y_shape_, <{{ktp}}*>np.PyArray_DATA(y_) + offy, &incy, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return y
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['strmv_c', 'dtrmv_c', 'ctrmv_c', 'ztrmv_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['strmv', 'dtrmv', 'ctrmv', 'ztrmv'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object a, object x, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t lower=0, fwi_integer_t trans=0, fwi_integer_t unitdiag=0, bint overwrite_x=False):
    """
    {{name}}(a, x, offx, incx, lower, trans, unitdiag, overwrite_x) -> x

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent in
    x : {{ktp}}_, 1D array, dimension(*), intent inout
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    lower : fwi_integer, intent in
    trans : fwi_integer, intent in
    unitdiag : fwi_integer, intent in
    overwrite_x : bint_, intent in

    Returns
    -------
    x : {{ktp}}_, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef char *fw_trans_f = [0, 0]
    cdef char *fw_diag_f = [0, 0]
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    trans_f = ("C" if (trans == 2) else "T") if trans else "N"
    diag_f = "U" if unitdiag else "N"
    x_, x = fw_asfortranarray(x, {{npy_enum}}, 1, not overwrite_x)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, False)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not ((trans >= 0) and (trans <= 2)):
        raise ValueError('Condition on arguments not satisfied: (trans >= 0) and (trans <= 2)')
    if not ((unitdiag == 0) or (unitdiag == 1)):
        raise ValueError('Condition on arguments not satisfied: (unitdiag == 0) or (unitdiag == 1)')
    if not (np.PyArray_DIMS(x_)[0] > (offx + ((n - 1) * abs(incx)))):
        raise ValueError('Condition on arguments not satisfied: np.PyArray_DIMS(x)[0] > (offx + ((n - 1) * abs(incx)))')
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    fw_trans_f[0] = fw_aschar(trans_f)
    if fw_trans_f[0] == 0:
        raise ValueError("len(trans_f) != 1")
    fw_diag_f[0] = fw_aschar(diag_f)
    if fw_diag_f[0] == 0:
        raise ValueError("len(diag_f) != 1")
    {{fc_name}}(fw_uplo_f, fw_trans_f, fw_diag_f, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &n, x_shape_, <{{ktp}}*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return x
{{endfor}}


cpdef api object zdrot(object x, object y, fwr_dbl_t c, fwr_dbl_t s, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1, fwi_integer_t offy=0, fwi_integer_t incy=1, bint overwrite_x=False, bint overwrite_y=False):
    """
    zdrot(x, y, c, s, n, offx, incx, offy, incy, overwrite_x, overwrite_y) -> (x, y)

    Parameters
    ----------
    x : fwc_dbl_complex, 1D array, dimension(*), intent inout
    y : fwc_dbl_complex, 1D array, dimension(*), intent inout
    c : fwr_dbl, intent in
    s : fwr_dbl, intent in
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    offy : fwi_integer, intent in
    incy : fwi_integer, intent in
    overwrite_x : bint_, intent in
    overwrite_y : bint_, intent in

    Returns
    -------
    x : fwc_dbl_complex, 1D array, dimension(*), intent inout
    y : fwc_dbl_complex, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef np.ndarray y_
    cdef fw_shape_t y_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, fwc_dbl_complex_t_enum, 1, not overwrite_x)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    y_, y = fw_asfortranarray(y, fwc_dbl_complex_t_enum, 1, not overwrite_y)
    fw_copyshape(y_shape_, np.PyArray_DIMS(y_), 1)
    y_shape_[0] -= offy
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((np.PyArray_DIMS(y_)[0] - offy) > ((n_ - 1) * abs(incy))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(y)[0] - offy) > ((n - 1) * abs(incy))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    if not ((offy >= 0) and (offy < np.PyArray_DIMS(y_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offy >= 0) and (offy < np.PyArray_DIMS(y)[0])')
    if not ((incy > 0) or (incy < 0)):
        raise ValueError('Condition on arguments not satisfied: (incy > 0) or (incy < 0)')
    zdrot_c(&n_, x_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(x_) + offx, &incx, y_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(y_) + offy, &incy, &c, &s, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'zdrot' wrapper.")
    return (x, y,)


cpdef api object zdscal(fwr_dbl_t a, object x, object n=None, fwi_integer_t offx=0, fwi_integer_t incx=1, bint overwrite_x=False):
    """
    zdscal(a, x, n, offx, incx, overwrite_x) -> x

    Parameters
    ----------
    a : fwr_dbl, intent in
    x : fwc_dbl_complex, 1D array, dimension(*), intent inout
    n : fwi_integer, intent in
    offx : fwi_integer, intent in
    incx : fwi_integer, intent in
    overwrite_x : bint_, intent in

    Returns
    -------
    x : fwc_dbl_complex, 1D array, dimension(*), intent inout

    """
    cdef np.ndarray x_
    cdef fw_shape_t x_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    x_, x = fw_asfortranarray(x, fwc_dbl_complex_t_enum, 1, not overwrite_x)
    fw_copyshape(x_shape_, np.PyArray_DIMS(x_), 1)
    x_shape_[0] -= offx
    n_ = n if (n is not None) else (np.PyArray_DIMS(x_)[0] - offx) // abs(incx)
    if not ((np.PyArray_DIMS(x_)[0] - offx) > ((n_ - 1) * abs(incx))):
        raise ValueError('Condition on arguments not satisfied: (np.PyArray_DIMS(x)[0] - offx) > ((n - 1) * abs(incx))')
    if not ((offx >= 0) and (offx < np.PyArray_DIMS(x_)[0])):
        raise ValueError('Condition on arguments not satisfied: (offx >= 0) and (offx < np.PyArray_DIMS(x)[0])')
    if not ((incx > 0) or (incx < 0)):
        raise ValueError('Condition on arguments not satisfied: (incx > 0) or (incx < 0)')
    zdscal_c(&n_, &a, x_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(x_) + offx, &incx, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'zdscal' wrapper.")
    return x



cdef void fw_copyshape(fw_shape_t *target, np.intp_t *source, int ndim):
    # In f77binding mode, we do not always have fw_shape_t and np.npy_intp
    # as the same type, so must make a copy
    cdef int i
    for i in range(ndim):
        target[i] = source[i]

cdef char fw_aschar(object s):
    cdef char* buf
    try:
        return <char>s # int
    except TypeError:
        pass
    try:
        buf = <char*>s # bytes
    except TypeError:
        s = s.encode('ASCII')
        buf = <char*>s # unicode
    if buf[0] == 0:
        return 0
    elif buf[1] != 0:
        return 0
    else:
        return buf[0]

cdef object fw_asfortranarray(object value, int typenum, int ndim, bint copy):
    cdef int flags = np.NPY_F_CONTIGUOUS
    if ndim <= 1:
        # See http://projects.scipy.org/numpy/ticket/1691 for why this is needed
        flags |= np.NPY_C_CONTIGUOUS
    if copy:
        flags |= np.NPY_ENSURECOPY
    result = np.PyArray_FROMANY(value, typenum, 0, 0, flags)


    if ndim == result.ndim:
        return result, result
    else:
        to_shape = [None] * ndim
        fw_f2py_shape_coercion(ndim, to_shape, result.ndim, result.shape,
                               result.size)
        return result.reshape(to_shape, order='F'), result

cdef object fw_f2py_shape_coercion(int to_ndim, object to_shape,
                                   int from_ndim, object from_shape,
                                   Py_ssize_t from_size):
    # Logic ported from check_and_fix_dimensions in fortranobject.c
    # Todo: optimize
    if to_ndim > from_ndim:
        to_size = 1
        free_ax = -1
        for i in range(from_ndim):
            d = from_shape[i]
            if d == 0:
                d = 1
            to_shape[i] = d
            to_size *= d
        for i in range(from_ndim, to_ndim):
            if free_ax < 0:
                free_ax = i
            else:
                to_shape[i] = 1
        if free_ax >= 0:
            to_shape[free_ax] = from_size // to_size
    elif to_ndim < from_ndim:
        j = 0
        for i in range(from_ndim):
            while j < from_ndim and from_shape[j] < 2:
                j += 1
            if j >= from_ndim:
                d = 1
            else:
                d = from_shape[j]
                j += 1
            if i < to_ndim:
                to_shape[i] = d
            else:
                to_shape[to_ndim - 1] *= d    

cdef object fw_explicitshapearray(object value, int typenum, int ndim,
                                  np.intp_t *shape, bint copy):
    if value is None:
        result = np.PyArray_ZEROS(ndim, shape, typenum, 1)
        return result, result
    else:
        return fw_asfortranarray(value, typenum, ndim, copy)

# Fwrap configuration:
# Fwrap: version 0.2.0dev_2a63538
# Fwrap: self-sha1 c2676dffda7114d90f24a1f01b932de010724d64
# Fwrap: wraps $REFERENCE_BLAS/*.f
# Fwrap:     sha1 7b2b93ccd4fe2190e45d3e3a21c5156f0fffcb80
# Fwrap: exclude cgbmv
# Fwrap: exclude chbmv
# Fwrap: exclude chemm
# Fwrap: exclude cher
# Fwrap: exclude cher2
# Fwrap: exclude cher2k
# Fwrap: exclude cherk
# Fwrap: exclude chpmv
# Fwrap: exclude chpr
# Fwrap: exclude chpr2
# Fwrap: exclude csymm
# Fwrap: exclude csyr2k
# Fwrap: exclude csyrk
# Fwrap: exclude ctbmv
# Fwrap: exclude ctbsv
# Fwrap: exclude ctpmv
# Fwrap: exclude ctpsv
# Fwrap: exclude ctrmm
# Fwrap: exclude ctrsm
# Fwrap: exclude ctrsv
# Fwrap: exclude dcabs1
# Fwrap: exclude dgbmv
# Fwrap: exclude dsbmv
# Fwrap: exclude dsdot
# Fwrap: exclude dspmv
# Fwrap: exclude dspr
# Fwrap: exclude dspr2
# Fwrap: exclude dsymm
# Fwrap: exclude dsyr
# Fwrap: exclude dsyr2
# Fwrap: exclude dsyr2k
# Fwrap: exclude dsyrk
# Fwrap: exclude dtbmv
# Fwrap: exclude dtbsv
# Fwrap: exclude dtpmv
# Fwrap: exclude dtpsv
# Fwrap: exclude dtrmm
# Fwrap: exclude dtrsm
# Fwrap: exclude dtrsv
# Fwrap: exclude scabs1
# Fwrap: exclude sdsdot
# Fwrap: exclude sgbmv
# Fwrap: exclude ssbmv
# Fwrap: exclude sspmv
# Fwrap: exclude sspr
# Fwrap: exclude sspr2
# Fwrap: exclude ssymm
# Fwrap: exclude ssyr
# Fwrap: exclude ssyr2
# Fwrap: exclude ssyr2k
# Fwrap: exclude ssyrk
# Fwrap: exclude stbmv
# Fwrap: exclude stbsv
# Fwrap: exclude stpmv
# Fwrap: exclude stpsv
# Fwrap: exclude strmm
# Fwrap: exclude strsm
# Fwrap: exclude strsv
# Fwrap: exclude xerbla
# Fwrap: exclude zgbmv
# Fwrap: exclude zhbmv
# Fwrap: exclude zhemm
# Fwrap: exclude zher
# Fwrap: exclude zher2
# Fwrap: exclude zher2k
# Fwrap: exclude zherk
# Fwrap: exclude zhpmv
# Fwrap: exclude zhpr
# Fwrap: exclude zhpr2
# Fwrap: exclude zsymm
# Fwrap: exclude zsyr2k
# Fwrap: exclude zsyrk
# Fwrap: exclude ztbmv
# Fwrap: exclude ztbsv
# Fwrap: exclude ztpmv
# Fwrap: exclude ztpsv
# Fwrap: exclude ztrmm
# Fwrap: exclude ztrsm
# Fwrap: exclude ztrsv
# Fwrap: f77binding True
# Fwrap: detect-templates True
# Fwrap: template isamax,idamax,icamax,izamax
# Fwrap: emulate-f2py True
# Fwrap: auxiliary fblas.pxd
# Fwrap: auxiliary fblas.pyx.in
# Fwrap: auxiliary fblas_fc.f
# Fwrap: auxiliary fblas_fc.h
# Fwrap: auxiliary fblas_fc.pxd

