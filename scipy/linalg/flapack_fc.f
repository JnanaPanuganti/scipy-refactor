      subroutine cbbcsd_c(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, 
     &theta_shape__, theta, phi_shape__, phi, u1_shape__, u1, ldu1, u2_s
     &hape__, u2, ldu2, v1t_shape__, v1t, ldv1t, v2t_shape__, v2t, ldv2t
     &, b11d_shape__, b11d, b11e_shape__, b11e, b12d_shape__, b12d, b12e
     &_shape__, b12e, b21d_shape__, b21d, b21e_shape__, b21e, b22d_shape
     &__, b22d, b22e_shape__, b22e, rwork_shape__, rwork, lrwork, info, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu1
        character(len=1, kind=kind('a')) :: jobu2
        character(len=1, kind=kind('a')) :: jobv1t
        character(len=1, kind=kind('a')) :: jobv2t
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(1) :: phi_shape__
        real(kind=kind(0.0)), dimension(phi_shape__(1)) :: phi
        integer, dimension(2) :: u1_shape__
        complex(kind=kind((0.0,0.0))), dimension(u1_shape__(1), u1_shape
     &__(2)) :: u1
        integer :: ldu1
        integer, dimension(2) :: u2_shape__
        complex(kind=kind((0.0,0.0))), dimension(u2_shape__(1), u2_shape
     &__(2)) :: u2
        integer :: ldu2
        integer, dimension(2) :: v1t_shape__
        complex(kind=kind((0.0,0.0))), dimension(v1t_shape__(1), v1t_sha
     &pe__(2)) :: v1t
        integer :: ldv1t
        integer, dimension(2) :: v2t_shape__
        complex(kind=kind((0.0,0.0))), dimension(v2t_shape__(1), v2t_sha
     &pe__(2)) :: v2t
        integer :: ldv2t
        integer, dimension(1) :: b11d_shape__
        real(kind=kind(0.0)), dimension(b11d_shape__(1)) :: b11d
        integer, dimension(1) :: b11e_shape__
        real(kind=kind(0.0)), dimension(b11e_shape__(1)) :: b11e
        integer, dimension(1) :: b12d_shape__
        real(kind=kind(0.0)), dimension(b12d_shape__(1)) :: b12d
        integer, dimension(1) :: b12e_shape__
        real(kind=kind(0.0)), dimension(b12e_shape__(1)) :: b12e
        integer, dimension(1) :: b21d_shape__
        real(kind=kind(0.0)), dimension(b21d_shape__(1)) :: b21d
        integer, dimension(1) :: b21e_shape__
        real(kind=kind(0.0)), dimension(b21e_shape__(1)) :: b21e
        integer, dimension(1) :: b22d_shape__
        real(kind=kind(0.0)), dimension(b22d_shape__(1)) :: b22d
        integer, dimension(1) :: b22e_shape__
        real(kind=kind(0.0)), dimension(b22e_shape__(1)) :: b22e
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cbbcsd
        fw_iserr__ = -1
        if ((ldu1) .ne. (u1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv1t) .ne. (v1t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v1t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv2t) .ne. (v2t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v2t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cbbcsd(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta,
     & phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d
     &, b12e, b21d, b21e, b22d, b22e, rwork, lrwork, info)
        fw_iserr__ = 0
      end subroutine cbbcsd_c
      subroutine cbdsqr_c(uplo, n, ncvt, nru, ncc, d_shape__, d, e_shape
     &__, e, vt_shape__, vt, ldvt, u_shape__, u, ldu, c_shape__, c, ldc,
     & rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ncvt
        integer :: nru
        integer :: ncc
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: vt_shape__
        complex(kind=kind((0.0,0.0))), dimension(vt_shape__(1), vt_shape
     &__(2)) :: vt
        integer :: ldvt
        integer, dimension(2) :: u_shape__
        complex(kind=kind((0.0,0.0))), dimension(u_shape__(1), u_shape__
     &(2)) :: u
        integer :: ldu
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cbdsqr
        fw_iserr__ = -1
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cbdsqr(uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, 
     &ldc, rwork, info)
        fw_iserr__ = 0
      end subroutine cbdsqr_c
      subroutine cgbbrd_c(vect, m, n, ncc, kl, ku, ab_shape__, ab, ldab,
     & d_shape__, d, e_shape__, e, q_shape__, q, ldq, pt_shape__, pt, ld
     &pt, c_shape__, c, ldc, work_shape__, work, rwork_shape__, rwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        integer :: m
        integer :: n
        integer :: ncc
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(2) :: pt_shape__
        complex(kind=kind((0.0,0.0))), dimension(pt_shape__(1), pt_shape
     &__(2)) :: pt
        integer :: ldpt
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbbrd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldpt) .ne. (pt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("pt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbbrd(vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt,
     & ldpt, c, ldc, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgbbrd_c
      subroutine cgbcon_c(norm, n, kl, ku, ab_shape__, ab, ldab, ipiv_sh
     &ape__, ipiv, anorm, rcond, work_shape__, work, rwork_shape__, rwor
     &k, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbcon(norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work,
     & rwork, info)
        fw_iserr__ = 0
      end subroutine cgbcon_c
      subroutine cgbequ_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__,
     & r, c_shape__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbequ
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbequ(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, 
     &info)
        fw_iserr__ = 0
      end subroutine cgbequ_c
      subroutine cgbequb_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__
     &, r, c_shape__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbequb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbequb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax,
     & info)
        fw_iserr__ = 0
      end subroutine cgbequb_c
      subroutine cgbrfs_c(trans, n, kl, ku, nrhs, ab_shape__, ab, ldab, 
     &afb_shape__, afb, ldafb, ipiv_shape__, ipiv, b_shape__, b, ldb, x_
     &shape__, x, ldx, ferr_shape__, ferr, berr_shape__, berr, work_shap
     &e__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex(kind=kind((0.0,0.0))), dimension(afb_shape__(1), afb_sha
     &pe__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbrfs(trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, 
     &b, ldb, x, ldx, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgbrfs_c
      subroutine cgbrfsx_c(trans, equed, n, kl, ku, nrhs, ab_shape__, ab
     &, ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, r_shape__, r,
     & c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, berr_s
     &hape__, berr, n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, er
     &r_bnds_comp_shape__, err_bnds_comp, nparams, params_shape__, param
     &s, work_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex(kind=kind((0.0,0.0))), dimension(afb_shape__(1), afb_sha
     &pe__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbrfsx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbrfsx(trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb
     &, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_no
     &rm, err_bnds_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgbrfsx_c
      subroutine cgbsv_c(n, kl, ku, nrhs, ab_shape__, ab, ldab, ipiv_sha
     &pe__, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbsv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbsv(n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cgbsv_c
      subroutine cgbsvx_c(fact, trans, n, kl, ku, nrhs, ab_shape__, ab, 
     &ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, equed, r_shape_
     &_, r, c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, f
     &err_shape__, ferr, berr_shape__, berr, work_shape__, work, rwork_s
     &hape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex(kind=kind((0.0,0.0))), dimension(afb_shape__(1), afb_sha
     &pe__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbsvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbsvx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, 
     &ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork,
     & info)
        fw_iserr__ = 0
      end subroutine cgbsvx_c
      subroutine cgbsvxx_c(fact, trans, n, kl, ku, nrhs, ab_shape__, ab,
     & ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, equed, r_shape
     &__, r, c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, 
     &rpvgrw, berr_shape__, berr, n_err_bnds, err_bnds_norm_shape__, err
     &_bnds_norm, err_bnds_comp_shape__, err_bnds_comp, nparams, params_
     &shape__, params, work_shape__, work, rwork_shape__, rwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex(kind=kind((0.0,0.0))), dimension(afb_shape__(1), afb_sha
     &pe__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        real(kind=kind(0.0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbsvxx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbsvxx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,
     & ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnd
     &s, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine cgbsvxx_c
      subroutine cgbtf2_c(m, n, kl, ku, ab_shape__, ab, ldab, ipiv_shape
     &__, ipiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbtf2
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbtf2(m, n, kl, ku, ab, ldab, ipiv, info)
        fw_iserr__ = 0
      end subroutine cgbtf2_c
      subroutine cgbtrf_c(m, n, kl, ku, ab_shape__, ab, ldab, ipiv_shape
     &__, ipiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbtrf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbtrf(m, n, kl, ku, ab, ldab, ipiv, info)
        fw_iserr__ = 0
      end subroutine cgbtrf_c
      subroutine cgbtrs_c(trans, n, kl, ku, nrhs, ab_shape__, ab, ldab, 
     &ipiv_shape__, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgbtrs(trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info
     &)
        fw_iserr__ = 0
      end subroutine cgbtrs_c
      subroutine cgebak_c(job, side, n, ilo, ihi, scale_shape__, scale, 
     &m, v_shape__, v, ldv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: side
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0)), dimension(scale_shape__(1)) :: scale
        integer :: m
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgebak
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgebak(job, side, n, ilo, ihi, scale, m, v, ldv, info)
        fw_iserr__ = 0
      end subroutine cgebak_c
      subroutine cgebal_c(job, n, a_shape__, a, lda, ilo, ihi, scale_sha
     &pe__, scale, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0)), dimension(scale_shape__(1)) :: scale
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgebal
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgebal(job, n, a, lda, ilo, ihi, scale, info)
        fw_iserr__ = 0
      end subroutine cgebal_c
      subroutine cgebd2_c(m, n, a_shape__, a, lda, d_shape__, d, e_shape
     &__, e, tauq_shape__, tauq, taup_shape__, taup, work_shape__, work,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        complex(kind=kind((0.0,0.0))), dimension(tauq_shape__(1)) :: tau
     &q
        integer, dimension(1) :: taup_shape__
        complex(kind=kind((0.0,0.0))), dimension(taup_shape__(1)) :: tau
     &p
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgebd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgebd2(m, n, a, lda, d, e, tauq, taup, work, info)
        fw_iserr__ = 0
      end subroutine cgebd2_c
      subroutine cgebrd_c(m, n, a_shape__, a, lda, d_shape__, d, e_shape
     &__, e, tauq_shape__, tauq, taup_shape__, taup, work_shape__, work,
     & lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        complex(kind=kind((0.0,0.0))), dimension(tauq_shape__(1)) :: tau
     &q
        integer, dimension(1) :: taup_shape__
        complex(kind=kind((0.0,0.0))), dimension(taup_shape__(1)) :: tau
     &p
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgebrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgebrd(m, n, a, lda, d, e, tauq, taup, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cgebrd_c
      subroutine cgecon_c(norm, n, a_shape__, a, lda, anorm, rcond, work
     &_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgecon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgecon(norm, n, a, lda, anorm, rcond, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgecon_c
      subroutine cgeequ_c(m, n, a_shape__, a, lda, r_shape__, r, c_shape
     &__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeequ
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeequ(m, n, a, lda, r, c, rowcnd, colcnd, amax, info)
        fw_iserr__ = 0
      end subroutine cgeequ_c
      subroutine cgeequb_c(m, n, a_shape__, a, lda, r_shape__, r, c_shap
     &e__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeequb(m, n, a, lda, r, c, rowcnd, colcnd, amax, info)
        fw_iserr__ = 0
      end subroutine cgeequb_c
      subroutine cgees_c(jobvs, sort, select, n, a_shape__, a, lda, sdim
     &, w_shape__, w, vs_shape__, vs, ldvs, work_shape__, work, lwork, r
     &work_shape__, rwork, bwork_shape__, bwork, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvs
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: sdim
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: vs_shape__
        complex(kind=kind((0.0,0.0))), dimension(vs_shape__(1), vs_shape
     &__(2)) :: vs
        integer :: ldvs
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgees
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvs) .ne. (vs_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vs                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgees(jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, wo
     &rk, lwork, rwork, bwork, info)
        fw_iserr__ = 0
      end subroutine cgees_c
      subroutine cgeesx_c(jobvs, sort, select, sense, n, a_shape__, a, l
     &da, sdim, w_shape__, w, vs_shape__, vs, ldvs, rconde, rcondv, work
     &_shape__, work, lwork, rwork_shape__, rwork, bwork_shape__, bwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvs
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: select
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: sdim
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: vs_shape__
        complex(kind=kind((0.0,0.0))), dimension(vs_shape__(1), vs_shape
     &__(2)) :: vs
        integer :: ldvs
        real(kind=kind(0.0)) :: rconde
        real(kind=kind(0.0)) :: rcondv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeesx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvs) .ne. (vs_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vs                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeesx(jobvs, sort, select, sense, n, a, lda, sdim, w, vs, 
     &ldvs, rconde, rcondv, work, lwork, rwork, bwork, info)
        fw_iserr__ = 0
      end subroutine cgeesx_c
      subroutine cgeev_c(jobvl, jobvr, n, a_shape__, a, lda, w_shape__, 
     &w, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, work_shape__, work,
     & lwork, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: vl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vl_shape__(1), vl_shape
     &__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vr_shape__(1), vr_shape
     &__(2)) :: vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeev(jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work,
     & lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine cgeev_c
      subroutine cgeevx_c(balanc, jobvl, jobvr, sense, n, a_shape__, a, 
     &lda, w_shape__, w, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, ilo
     &, ihi, scale_shape__, scale, abnrm, rconde_shape__, rconde, rcondv
     &_shape__, rcondv, work_shape__, work, lwork, rwork_shape__, rwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: balanc
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: vl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vl_shape__(1), vl_shape
     &__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vr_shape__(1), vr_shape
     &__(2)) :: vr
        integer :: ldvr
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0)), dimension(scale_shape__(1)) :: scale
        real(kind=kind(0.0)) :: abnrm
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeevx(balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl,
     & vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rw
     &ork, info)
        fw_iserr__ = 0
      end subroutine cgeevx_c
      subroutine cgegs_c(jobvsl, jobvsr, n, a_shape__, a, lda, b_shape__
     &, b, ldb, alpha_shape__, alpha, beta_shape__, beta, vsl_shape__, v
     &sl, ldvsl, vsr_shape__, vsr, ldvsr, work_shape__, work, lwork, rwo
     &rk_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        complex(kind=kind((0.0,0.0))), dimension(alpha_shape__(1)) :: al
     &pha
        integer, dimension(1) :: beta_shape__
        complex(kind=kind((0.0,0.0))), dimension(beta_shape__(1)) :: bet
     &a
        integer, dimension(2) :: vsl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vsl_shape__(1), vsl_sha
     &pe__(2)) :: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vsr_shape__(1), vsr_sha
     &pe__(2)) :: vsr
        integer :: ldvsr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgegs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgegs(jobvsl, jobvsr, n, a, lda, b, ldb, alpha, beta, vsl, 
     &ldvsl, vsr, ldvsr, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine cgegs_c
      subroutine cgegv_c(jobvl, jobvr, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, alpha_shape__, alpha, beta_shape__, beta, vl_shape__, vl, 
     &ldvl, vr_shape__, vr, ldvr, work_shape__, work, lwork, rwork_shape
     &__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        complex(kind=kind((0.0,0.0))), dimension(alpha_shape__(1)) :: al
     &pha
        integer, dimension(1) :: beta_shape__
        complex(kind=kind((0.0,0.0))), dimension(beta_shape__(1)) :: bet
     &a
        integer, dimension(2) :: vl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vl_shape__(1), vl_shape
     &__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vr_shape__(1), vr_shape
     &__(2)) :: vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgegv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgegv(jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldv
     &l, vr, ldvr, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine cgegv_c
      subroutine cgehd2_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgehd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgehd2(n, ilo, ihi, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine cgehd2_c
      subroutine cgehrd_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgehrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgehrd(n, ilo, ihi, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cgehrd_c
      subroutine cgelq2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgelq2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgelq2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine cgelq2_c
      subroutine cgelqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgelqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgelqf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cgelqf_c
      subroutine cgels_c(trans, m, n, nrhs, a_shape__, a, lda, b_shape__
     &, b, ldb, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgels
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgels(trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cgels_c
      subroutine cgelsd_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, s_shape__, s, rcond, rank, work_shape__, work, lwork, rwork_sh
     &ape__, rwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgelsd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgelsd(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lw
     &ork, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine cgelsd_c
      subroutine cgelss_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, s_shape__, s, rcond, rank, work_shape__, work, lwork, rwork_sh
     &ape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgelss
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgelss(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lw
     &ork, rwork, info)
        fw_iserr__ = 0
      end subroutine cgelss_c
      subroutine cgelsx_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, jpvt_shape__, jpvt, rcond, rank, work_shape__, work, rwork_sha
     &pe__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        real(kind=kind(0.0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgelsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgelsx(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work,
     & rwork, info)
        fw_iserr__ = 0
      end subroutine cgelsx_c
      subroutine cgelsy_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, jpvt_shape__, jpvt, rcond, rank, work_shape__, work, lwork, rw
     &ork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        real(kind=kind(0.0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgelsy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgelsy(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work,
     & lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine cgelsy_c
      subroutine cgeql2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeql2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeql2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine cgeql2_c
      subroutine cgeqlf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeqlf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeqlf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cgeqlf_c
      subroutine cgeqp3_c(m, n, a_shape__, a, lda, jpvt_shape__, jpvt, t
     &au_shape__, tau, work_shape__, work, lwork, rwork_shape__, rwork, 
     &info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeqp3
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeqp3(m, n, a, lda, jpvt, tau, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine cgeqp3_c
      subroutine cgeqpf_c(m, n, a_shape__, a, lda, jpvt_shape__, jpvt, t
     &au_shape__, tau, work_shape__, work, rwork_shape__, rwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeqpf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeqpf(m, n, a, lda, jpvt, tau, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgeqpf_c
      subroutine cgeqr2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeqr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeqr2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine cgeqr2_c
      subroutine cgeqr2p_c(m, n, a_shape__, a, lda, tau_shape__, tau, wo
     &rk_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeqr2p
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeqr2p(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine cgeqr2p_c
      subroutine cgeqrf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeqrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeqrf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cgeqrf_c
      subroutine cgeqrfp_c(m, n, a_shape__, a, lda, tau_shape__, tau, wo
     &rk_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgeqrfp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgeqrfp(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cgeqrfp_c
      subroutine cgerfs_c(trans, n, nrhs, a_shape__, a, lda, af_shape__,
     & af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ld
     &x, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, rwo
     &rk_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgerfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgerfs(trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, l
     &dx, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgerfs_c
      subroutine cgerfsx_c(trans, equed, n, nrhs, a_shape__, a, lda, af_
     &shape__, af, ldaf, ipiv_shape__, ipiv, r_shape__, r, c_shape__, c,
     & b_shape__, b, ldb, x_shape__, x, ldx, rcond, berr_shape__, berr, 
     &n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_sh
     &ape__, err_bnds_comp, nparams, params_shape__, params, work_shape_
     &_, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgerfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgerfsx(trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c
     &, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds
     &_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgerfsx_c
      subroutine cgerq2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgerq2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgerq2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine cgerq2_c
      subroutine cgerqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgerqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgerqf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cgerqf_c
      subroutine cgesc2_c(n, a_shape__, a, lda, rhs_shape__, rhs, ipiv_s
     &hape__, ipiv, jpiv_shape__, jpiv, scale, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: rhs_shape__
        complex(kind=kind((0.0,0.0))), dimension(rhs_shape__(1)) :: rhs
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        real(kind=kind(0.0)) :: scale
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgesc2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgesc2(n, a, lda, rhs, ipiv, jpiv, scale)
        fw_iserr__ = 0
      end subroutine cgesc2_c
      subroutine cgesdd_c(jobz, m, n, a_shape__, a, lda, s_shape__, s, u
     &_shape__, u, ldu, vt_shape__, vt, ldvt, work_shape__, work, lwork,
     & rwork_shape__, rwork, iwork_shape__, iwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: u_shape__
        complex(kind=kind((0.0,0.0))), dimension(u_shape__(1), u_shape__
     &(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        complex(kind=kind((0.0,0.0))), dimension(vt_shape__(1), vt_shape
     &__(2)) :: vt
        integer :: ldvt
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgesdd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgesdd(jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork
     &, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine cgesdd_c
      subroutine cgesv_c(n, nrhs, a_shape__, a, lda, ipiv_shape__, ipiv,
     & b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgesv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgesv(n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cgesv_c
      subroutine cgesvd_c(jobu, jobvt, m, n, a_shape__, a, lda, s_shape_
     &_, s, u_shape__, u, ldu, vt_shape__, vt, ldvt, work_shape__, work,
     & lwork, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobvt
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: u_shape__
        complex(kind=kind((0.0,0.0))), dimension(u_shape__(1), u_shape__
     &(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        complex(kind=kind((0.0,0.0))), dimension(vt_shape__(1), vt_shape
     &__(2)) :: vt
        integer :: ldvt
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgesvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work
     &, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine cgesvd_c
      subroutine cgesvx_c(fact, trans, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, ipiv_shape__, ipiv, equed, r_shape__, r, c_shape_
     &_, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, ferr_shape__, f
     &err, berr_shape__, berr, work_shape__, work, rwork_shape__, rwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgesvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgesvx(fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed,
     & r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgesvx_c
      subroutine cgesvxx_c(fact, trans, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, ipiv_shape__, ipiv, equed, r_shape__, r, c_shape
     &__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, rpvgrw, berr_s
     &hape__, berr, n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, er
     &r_bnds_comp_shape__, err_bnds_comp, nparams, params_shape__, param
     &s, work_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        real(kind=kind(0.0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgesvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgesvxx(fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed
     &, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_
     &norm, err_bnds_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgesvxx_c
      subroutine cgetc2_c(n, a_shape__, a, lda, ipiv_shape__, ipiv, jpiv
     &_shape__, jpiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgetc2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgetc2(n, a, lda, ipiv, jpiv, info)
        fw_iserr__ = 0
      end subroutine cgetc2_c
      subroutine cgetf2_c(m, n, a_shape__, a, lda, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgetf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgetf2(m, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine cgetf2_c
      subroutine cgetrf_c(m, n, a_shape__, a, lda, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgetrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgetrf(m, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine cgetrf_c
      subroutine cgetri_c(n, a_shape__, a, lda, ipiv_shape__, ipiv, work
     &_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgetri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgetri(n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cgetri_c
      subroutine cgetrs_c(trans, n, nrhs, a_shape__, a, lda, ipiv_shape_
     &_, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgetrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cgetrs_c
      subroutine cggbak_c(job, side, n, ilo, ihi, lscale_shape__, lscale
     &, rscale_shape__, rscale, m, v_shape__, v, ldv, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: side
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0)), dimension(rscale_shape__(1)) :: rscale
        integer :: m
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cggbak
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cggbak(job, side, n, ilo, ihi, lscale, rscale, m, v, ldv, i
     &nfo)
        fw_iserr__ = 0
      end subroutine cggbak_c
      subroutine cggbal_c(job, n, a_shape__, a, lda, b_shape__, b, ldb, 
     &ilo, ihi, lscale_shape__, lscale, rscale_shape__, rscale, work_sha
     &pe__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0)), dimension(rscale_shape__(1)) :: rscale
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cggbal
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cggbal(job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, wo
     &rk, info)
        fw_iserr__ = 0
      end subroutine cggbal_c
      subroutine cgges_c(jobvsl, jobvsr, sort, selctg, n, a_shape__, a, 
     &lda, b_shape__, b, ldb, sdim, alpha_shape__, alpha, beta_shape__, 
     &beta, vsl_shape__, vsl, ldvsl, vsr_shape__, vsr, ldvsr, work_shape
     &__, work, lwork, rwork_shape__, rwork, bwork_shape__, bwork, info,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: selctg
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: sdim
        integer, dimension(1) :: alpha_shape__
        complex(kind=kind((0.0,0.0))), dimension(alpha_shape__(1)) :: al
     &pha
        integer, dimension(1) :: beta_shape__
        complex(kind=kind((0.0,0.0))), dimension(beta_shape__(1)) :: bet
     &a
        integer, dimension(2) :: vsl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vsl_shape__(1), vsl_sha
     &pe__(2)) :: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vsr_shape__(1), vsr_sha
     &pe__(2)) :: vsr
        integer :: ldvsr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgges
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgges(jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim
     &, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork, 
     &info)
        fw_iserr__ = 0
      end subroutine cgges_c
      subroutine cggesx_c(jobvsl, jobvsr, sort, selctg, sense, n, a_shap
     &e__, a, lda, b_shape__, b, ldb, sdim, alpha_shape__, alpha, beta_s
     &hape__, beta, vsl_shape__, vsl, ldvsl, vsr_shape__, vsr, ldvsr, rc
     &onde_shape__, rconde, rcondv_shape__, rcondv, work_shape__, work, 
     &lwork, rwork_shape__, rwork, iwork_shape__, iwork, liwork, bwork_s
     &hape__, bwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: selctg
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: sdim
        integer, dimension(1) :: alpha_shape__
        complex(kind=kind((0.0,0.0))), dimension(alpha_shape__(1)) :: al
     &pha
        integer, dimension(1) :: beta_shape__
        complex(kind=kind((0.0,0.0))), dimension(beta_shape__(1)) :: bet
     &a
        integer, dimension(2) :: vsl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vsl_shape__(1), vsl_sha
     &pe__(2)) :: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vsr_shape__(1), vsr_sha
     &pe__(2)) :: vsr
        integer :: ldvsr
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cggesx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (rconde_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("rconde                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (rcondv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("rcondv                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cggesx(jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, l
     &db, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, wor
     &k, lwork, rwork, iwork, liwork, bwork, info)
        fw_iserr__ = 0
      end subroutine cggesx_c
      subroutine cggev_c(jobvl, jobvr, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, alpha_shape__, alpha, beta_shape__, beta, vl_shape__, vl, 
     &ldvl, vr_shape__, vr, ldvr, work_shape__, work, lwork, rwork_shape
     &__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        complex(kind=kind((0.0,0.0))), dimension(alpha_shape__(1)) :: al
     &pha
        integer, dimension(1) :: beta_shape__
        complex(kind=kind((0.0,0.0))), dimension(beta_shape__(1)) :: bet
     &a
        integer, dimension(2) :: vl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vl_shape__(1), vl_shape
     &__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vr_shape__(1), vr_shape
     &__(2)) :: vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cggev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cggev(jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldv
     &l, vr, ldvr, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine cggev_c
      subroutine cggevx_c(balanc, jobvl, jobvr, sense, n, a_shape__, a, 
     &lda, b_shape__, b, ldb, alpha_shape__, alpha, beta_shape__, beta, 
     &vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, ilo, ihi, lscale_shape
     &__, lscale, rscale_shape__, rscale, abnrm, bbnrm, rconde_shape__, 
     &rconde, rcondv_shape__, rcondv, work_shape__, work, lwork, rwork_s
     &hape__, rwork, iwork_shape__, iwork, bwork_shape__, bwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: balanc
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        complex(kind=kind((0.0,0.0))), dimension(alpha_shape__(1)) :: al
     &pha
        integer, dimension(1) :: beta_shape__
        complex(kind=kind((0.0,0.0))), dimension(beta_shape__(1)) :: bet
     &a
        integer, dimension(2) :: vl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vl_shape__(1), vl_shape
     &__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vr_shape__(1), vr_shape
     &__(2)) :: vr
        integer :: ldvr
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0)), dimension(rscale_shape__(1)) :: rscale
        real(kind=kind(0.0)) :: abnrm
        real(kind=kind(0.0)) :: bbnrm
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cggevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cggevx(balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alph
     &a, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnr
     &m, rconde, rcondv, work, lwork, rwork, iwork, bwork, info)
        fw_iserr__ = 0
      end subroutine cggevx_c
      subroutine cggglm_c(n, m, p, a_shape__, a, lda, b_shape__, b, ldb,
     & d_shape__, d, x_shape__, x, y_shape__, y, work_shape__, work, lwo
     &rk, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: m
        integer :: p
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1)) :: y
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cggglm
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cggglm(n, m, p, a, lda, b, ldb, d, x, y, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cggglm_c
      subroutine cgghrd_c(compq, compz, n, ilo, ihi, a_shape__, a, lda, 
     &b_shape__, b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compq
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgghrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgghrd(compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z
     &, ldz, info)
        fw_iserr__ = 0
      end subroutine cgghrd_c
      subroutine cgglse_c(m, n, p, a_shape__, a, lda, b_shape__, b, ldb,
     & c_shape__, c, d_shape__, d, x_shape__, x, work_shape__, work, lwo
     &rk, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: p
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgglse
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgglse(m, n, p, a, lda, b, ldb, c, d, x, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cgglse_c
      subroutine cggqrf_c(n, m, p, a_shape__, a, lda, taua_shape__, taua
     &, b_shape__, b, ldb, taub_shape__, taub, work_shape__, work, lwork
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: m
        integer :: p
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: taua_shape__
        complex(kind=kind((0.0,0.0))), dimension(taua_shape__(1)) :: tau
     &a
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: taub_shape__
        complex(kind=kind((0.0,0.0))), dimension(taub_shape__(1)) :: tau
     &b
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cggqrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cggqrf(n, m, p, a, lda, taua, b, ldb, taub, work, lwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine cggqrf_c
      subroutine cggrqf_c(m, p, n, a_shape__, a, lda, taua_shape__, taua
     &, b_shape__, b, ldb, taub_shape__, taub, work_shape__, work, lwork
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: p
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: taua_shape__
        complex(kind=kind((0.0,0.0))), dimension(taua_shape__(1)) :: tau
     &a
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: taub_shape__
        complex(kind=kind((0.0,0.0))), dimension(taub_shape__(1)) :: tau
     &b
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cggrqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cggrqf(m, p, n, a, lda, taua, b, ldb, taub, work, lwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine cggrqf_c
      subroutine cggsvd_c(jobu, jobv, jobq, m, n, p, k, l, a_shape__, a,
     & lda, b_shape__, b, ldb, alpha_shape__, alpha, beta_shape__, beta,
     & u_shape__, u, ldu, v_shape__, v, ldv, q_shape__, q, ldq, work_sha
     &pe__, work, rwork_shape__, rwork, iwork_shape__, iwork, info, fw_i
     &serr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: n
        integer :: p
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        real(kind=kind(0.0)), dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: u_shape__
        complex(kind=kind((0.0,0.0))), dimension(u_shape__(1), u_shape__
     &(2)) :: u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cggsvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cggsvd(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alp
     &ha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine cggsvd_c
      subroutine cggsvp_c(jobu, jobv, jobq, m, p, n, a_shape__, a, lda, 
     &b_shape__, b, ldb, tola, tolb, k, l, u_shape__, u, ldu, v_shape__,
     & v, ldv, q_shape__, q, ldq, iwork_shape__, iwork, rwork_shape__, r
     &work, tau_shape__, tau, work_shape__, work, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: p
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: tola
        real(kind=kind(0.0)) :: tolb
        integer :: k
        integer :: l
        integer, dimension(2) :: u_shape__
        complex(kind=kind((0.0,0.0))), dimension(u_shape__(1), u_shape__
     &(2)) :: u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cggsvp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cggsvp(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tol
     &b, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info)
        fw_iserr__ = 0
      end subroutine cggsvp_c
      subroutine cgtcon_c(norm, n, dl_shape__, dl, d_shape__, d, du_shap
     &e__, du, du2_shape__, du2, ipiv_shape__, ipiv, anorm, rcond, work_
     &shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: dl_shape__
        complex(kind=kind((0.0,0.0))), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex(kind=kind((0.0,0.0))), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        complex(kind=kind((0.0,0.0))), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgtcon
        fw_iserr__ = -1
        call cgtcon(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, i
     &nfo)
        fw_iserr__ = 0
      end subroutine cgtcon_c
      subroutine cgtrfs_c(trans, n, nrhs, dl_shape__, dl, d_shape__, d, 
     &du_shape__, du, dlf_shape__, dlf, df_shape__, df, duf_shape__, duf
     &, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape
     &__, x, ldx, ferr_shape__, ferr, berr_shape__, berr, work_shape__, 
     &work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        complex(kind=kind((0.0,0.0))), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex(kind=kind((0.0,0.0))), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: dlf_shape__
        complex(kind=kind((0.0,0.0))), dimension(dlf_shape__(1)) :: dlf
        integer, dimension(1) :: df_shape__
        complex(kind=kind((0.0,0.0))), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: duf_shape__
        complex(kind=kind((0.0,0.0))), dimension(duf_shape__(1)) :: duf
        integer, dimension(1) :: du2_shape__
        complex(kind=kind((0.0,0.0))), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgtrfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgtrfs(trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, 
     &b, ldb, x, ldx, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgtrfs_c
      subroutine cgtsv_c(n, nrhs, dl_shape__, dl, d_shape__, d, du_shape
     &__, du, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        complex(kind=kind((0.0,0.0))), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex(kind=kind((0.0,0.0))), dimension(du_shape__(1)) :: du
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgtsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgtsv(n, nrhs, dl, d, du, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cgtsv_c
      subroutine cgtsvx_c(fact, trans, n, nrhs, dl_shape__, dl, d_shape_
     &_, d, du_shape__, du, dlf_shape__, dlf, df_shape__, df, duf_shape_
     &_, duf, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b, ldb, x
     &_shape__, x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, w
     &ork_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        complex(kind=kind((0.0,0.0))), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex(kind=kind((0.0,0.0))), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: dlf_shape__
        complex(kind=kind((0.0,0.0))), dimension(dlf_shape__(1)) :: dlf
        integer, dimension(1) :: df_shape__
        complex(kind=kind((0.0,0.0))), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: duf_shape__
        complex(kind=kind((0.0,0.0))), dimension(duf_shape__(1)) :: duf
        integer, dimension(1) :: du2_shape__
        complex(kind=kind((0.0,0.0))), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgtsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgtsvx(fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, 
     &ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cgtsvx_c
      subroutine cgttrf_c(n, dl_shape__, dl, d_shape__, d, du_shape__, d
     &u, du2_shape__, du2, ipiv_shape__, ipiv, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: dl_shape__
        complex(kind=kind((0.0,0.0))), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex(kind=kind((0.0,0.0))), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        complex(kind=kind((0.0,0.0))), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgttrf
        fw_iserr__ = -1
        call cgttrf(n, dl, d, du, du2, ipiv, info)
        fw_iserr__ = 0
      end subroutine cgttrf_c
      subroutine cgttrs_c(trans, n, nrhs, dl_shape__, dl, d_shape__, d, 
     &du_shape__, du, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b
     &, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        complex(kind=kind((0.0,0.0))), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex(kind=kind((0.0,0.0))), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        complex(kind=kind((0.0,0.0))), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgttrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cgttrs_c
      subroutine cgtts2_c(itrans, n, nrhs, dl_shape__, dl, d_shape__, d,
     & du_shape__, du, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, 
     &b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itrans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        complex(kind=kind((0.0,0.0))), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex(kind=kind((0.0,0.0))), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        complex(kind=kind((0.0,0.0))), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cgtts2
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cgtts2(itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb)
        fw_iserr__ = 0
      end subroutine cgtts2_c
      subroutine chbev_c(jobz, uplo, n, kd, ab_shape__, ab, ldab, w_shap
     &e__, w, z_shape__, z, ldz, work_shape__, work, rwork_shape__, rwor
     &k, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chbev
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chbev(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork, 
     &info)
        fw_iserr__ = 0
      end subroutine chbev_c
      subroutine chbevd_c(jobz, uplo, n, kd, ab_shape__, ab, ldab, w_sha
     &pe__, w, z_shape__, z, ldz, work_shape__, work, lwork, rwork_shape
     &__, rwork, lrwork, iwork_shape__, iwork, liwork, info, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chbevd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chbevd(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork,
     & rwork, lrwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine chbevd_c
      subroutine chbevx_c(jobz, range, uplo, n, kd, ab_shape__, ab, ldab
     &, q_shape__, q, ldq, vl, vu, il, iu, abstol, m, w_shape__, w, z_sh
     &ape__, z, ldz, work_shape__, work, rwork_shape__, rwork, iwork_sha
     &pe__, iwork, ifail_shape__, ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chbevx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chbevx(jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, 
     &il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine chbevx_c
      subroutine chbgst_c(vect, uplo, n, ka, kb, ab_shape__, ab, ldab, b
     &b_shape__, bb, ldbb, x_shape__, x, ldx, work_shape__, work, rwork_
     &shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        complex(kind=kind((0.0,0.0))), dimension(bb_shape__(1), bb_shape
     &__(2)) :: bb
        integer :: ldbb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chbgst
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chbgst(vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, w
     &ork, rwork, info)
        fw_iserr__ = 0
      end subroutine chbgst_c
      subroutine chbgv_c(jobz, uplo, n, ka, kb, ab_shape__, ab, ldab, bb
     &_shape__, bb, ldbb, w_shape__, w, z_shape__, z, ldz, work_shape__,
     & work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        complex(kind=kind((0.0,0.0))), dimension(bb_shape__(1), bb_shape
     &__(2)) :: bb
        integer :: ldbb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chbgv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chbgv(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz,
     & work, rwork, info)
        fw_iserr__ = 0
      end subroutine chbgv_c
      subroutine chbgvd_c(jobz, uplo, n, ka, kb, ab_shape__, ab, ldab, b
     &b_shape__, bb, ldbb, w_shape__, w, z_shape__, z, ldz, work_shape__
     &, work, lwork, rwork_shape__, rwork, lrwork, iwork_shape__, iwork,
     & liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        complex(kind=kind((0.0,0.0))), dimension(bb_shape__(1), bb_shape
     &__(2)) :: bb
        integer :: ldbb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chbgvd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chbgvd(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz
     &, work, lwork, rwork, lrwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine chbgvd_c
      subroutine chbgvx_c(jobz, range, uplo, n, ka, kb, ab_shape__, ab, 
     &ldab, bb_shape__, bb, ldbb, q_shape__, q, ldq, vl, vu, il, iu, abs
     &tol, m, w_shape__, w, z_shape__, z, ldz, work_shape__, work, rwork
     &_shape__, rwork, iwork_shape__, iwork, ifail_shape__, ifail, info,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        complex(kind=kind((0.0,0.0))), dimension(bb_shape__(1), bb_shape
     &__(2)) :: bb
        integer :: ldbb
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chbgvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chbgvx(jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q,
     & ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, if
     &ail, info)
        fw_iserr__ = 0
      end subroutine chbgvx_c
      subroutine chbtrd_c(vect, uplo, n, kd, ab_shape__, ab, ldab, d_sha
     &pe__, d, e_shape__, e, q_shape__, q, ldq, work_shape__, work, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chbtrd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chbtrd(vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine chbtrd_c
      subroutine checon_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, anorm, rcond, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external checon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call checon(uplo, n, a, lda, ipiv, anorm, rcond, work, info)
        fw_iserr__ = 0
      end subroutine checon_c
      subroutine cheequb_c(uplo, n, a_shape__, a, lda, s_shape__, s, sco
     &nd, amax, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cheequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cheequb(uplo, n, a, lda, s, scond, amax, work, info)
        fw_iserr__ = 0
      end subroutine cheequb_c
      subroutine cheev_c(jobz, uplo, n, a_shape__, a, lda, w_shape__, w,
     & work_shape__, work, lwork, rwork_shape__, rwork, info, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cheev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cheev(jobz, uplo, n, a, lda, w, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine cheev_c
      subroutine cheevd_c(jobz, uplo, n, a_shape__, a, lda, w_shape__, w
     &, work_shape__, work, lwork, rwork_shape__, rwork, lrwork, iwork_s
     &hape__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cheevd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cheevd(jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork
     &, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine cheevd_c
      subroutine cheevr_c(jobz, range, uplo, n, a_shape__, a, lda, vl, v
     &u, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, isuppz_shap
     &e__, isuppz, work_shape__, work, lwork, rwork_shape__, rwork, lrwo
     &rk, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cheevr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cheevr(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol
     &, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork,
     & info)
        fw_iserr__ = 0
      end subroutine cheevr_c
      subroutine cheevx_c(jobz, range, uplo, n, a_shape__, a, lda, vl, v
     &u, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, work_shape_
     &_, work, lwork, rwork_shape__, rwork, iwork_shape__, iwork, ifail_
     &shape__, ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cheevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cheevx(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol
     &, m, w, z, ldz, work, lwork, rwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine cheevx_c
      subroutine chegs2_c(itype, uplo, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chegs2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chegs2(itype, uplo, n, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine chegs2_c
      subroutine chegst_c(itype, uplo, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chegst
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chegst(itype, uplo, n, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine chegst_c
      subroutine chegv_c(itype, jobz, uplo, n, a_shape__, a, lda, b_shap
     &e__, b, ldb, w_shape__, w, work_shape__, work, lwork, rwork_shape_
     &_, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chegv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chegv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork,
     & rwork, info)
        fw_iserr__ = 0
      end subroutine chegv_c
      subroutine chegvd_c(itype, jobz, uplo, n, a_shape__, a, lda, b_sha
     &pe__, b, ldb, w_shape__, w, work_shape__, work, lwork, rwork_shape
     &__, rwork, lrwork, iwork_shape__, iwork, liwork, info, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chegvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chegvd(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork
     &, rwork, lrwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine chegvd_c
      subroutine chegvx_c(itype, jobz, range, uplo, n, a_shape__, a, lda
     &, b_shape__, b, ldb, vl, vu, il, iu, abstol, m, w_shape__, w, z_sh
     &ape__, z, ldz, work_shape__, work, lwork, rwork_shape__, rwork, iw
     &ork_shape__, iwork, ifail_shape__, ifail, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chegvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chegvx(itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu,
     & il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail, i
     &nfo)
        fw_iserr__ = 0
      end subroutine chegvx_c
      subroutine cherfs_c(uplo, n, nrhs, a_shape__, a, lda, af_shape__, 
     &af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx
     &, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, rwor
     &k_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cherfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cherfs(uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ld
     &x, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cherfs_c
      subroutine cherfsx_c(uplo, equed, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, ipiv_shape__, ipiv, s_shape__, s, b_shape__, b, 
     &ldb, x_shape__, x, ldx, rcond, berr_shape__, berr, n_err_bnds, err
     &_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bnds
     &_comp, nparams, params_shape__, params, work_shape__, work, rwork_
     &shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cherfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cherfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b,
     & ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_com
     &p, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cherfsx_c
      subroutine chesv_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__,
     & ipiv, b_shape__, b, ldb, work_shape__, work, lwork, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chesv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chesv(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine chesv_c
      subroutine chesvx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sha
     &pe__, af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, 
     &x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape_
     &_, work, lwork, rwork_shape__, rwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chesvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chesvx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     & x, ldx, rcond, ferr, berr, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine chesvx_c
      subroutine chesvxx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, ipiv_shape__, ipiv, equed, s_shape__, s, b_shape_
     &_, b, ldb, x_shape__, x, ldx, rcond, rpvgrw, berr_shape__, berr, n
     &_err_bnds, err_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_sha
     &pe__, err_bnds_comp, nparams, params_shape__, params, work_shape__
     &, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        real(kind=kind(0.0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chesvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chesvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed,
     & s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm
     &, err_bnds_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine chesvxx_c
      subroutine chetd2_c(uplo, n, a_shape__, a, lda, d_shape__, d, e_sh
     &ape__, e, tau_shape__, tau, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chetd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chetd2(uplo, n, a, lda, d, e, tau, info)
        fw_iserr__ = 0
      end subroutine chetd2_c
      subroutine chetf2_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chetf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chetf2(uplo, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine chetf2_c
      subroutine chetrd_c(uplo, n, a_shape__, a, lda, d_shape__, d, e_sh
     &ape__, e, tau_shape__, tau, work_shape__, work, lwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chetrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chetrd(uplo, n, a, lda, d, e, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine chetrd_c
      subroutine chetrf_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chetrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chetrf(uplo, n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine chetrf_c
      subroutine chetri_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chetri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chetri(uplo, n, a, lda, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine chetri_c
      subroutine chetrs_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__
     &, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chetrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chetrs(uplo, n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine chetrs_c
      subroutine chetrs2_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape_
     &_, ipiv, b_shape__, b, ldb, work_shape__, work, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chetrs2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chetrs2(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, info)
        fw_iserr__ = 0
      end subroutine chetrs2_c
      subroutine chfrk_c(transr, uplo, trans, n, k, alpha, a_shape__, a,
     & lda, beta, c_shape__, c, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: k
        real(kind=kind(0.0)) :: alpha
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1)) :: c
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chfrk
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chfrk(transr, uplo, trans, n, k, alpha, a, lda, beta, c)
        fw_iserr__ = 0
      end subroutine chfrk_c
      subroutine chgeqz_c(job, compq, compz, n, ilo, ihi, h_shape__, h, 
     &ldh, t_shape__, t, ldt, alpha_shape__, alpha, beta_shape__, beta, 
     &q_shape__, q, ldq, z_shape__, z, ldz, work_shape__, work, lwork, r
     &work_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compq
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer, dimension(1) :: alpha_shape__
        complex(kind=kind((0.0,0.0))), dimension(alpha_shape__(1)) :: al
     &pha
        integer, dimension(1) :: beta_shape__
        complex(kind=kind((0.0,0.0))), dimension(beta_shape__(1)) :: bet
     &a
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chgeqz
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chgeqz(job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alph
     &a, beta, q, ldq, z, ldz, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine chgeqz_c
      subroutine chla_transtype_c(fw_ret_arg, trans, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1) :: fw_ret_arg
        integer :: trans
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        character(len=1) :: chla_transtype
        external chla_transtype
        fw_iserr__ = -1
        fw_ret_arg = chla_transtype(trans)
        fw_iserr__ = 0
      end subroutine chla_transtype_c
      subroutine chpcon_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, a
     &norm, rcond, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chpcon
        fw_iserr__ = -1
        call chpcon(uplo, n, ap, ipiv, anorm, rcond, work, info)
        fw_iserr__ = 0
      end subroutine chpcon_c
      subroutine chpev_c(jobz, uplo, n, ap_shape__, ap, w_shape__, w, z_
     &shape__, z, ldz, work_shape__, work, rwork_shape__, rwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chpev
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chpev(jobz, uplo, n, ap, w, z, ldz, work, rwork, info)
        fw_iserr__ = 0
      end subroutine chpev_c
      subroutine chpevd_c(jobz, uplo, n, ap_shape__, ap, w_shape__, w, z
     &_shape__, z, ldz, work_shape__, work, lwork, rwork_shape__, rwork,
     & lrwork, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chpevd
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chpevd(jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lr
     &work, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine chpevd_c
      subroutine chpevx_c(jobz, range, uplo, n, ap_shape__, ap, vl, vu, 
     &il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, work_shape__, 
     &work, rwork_shape__, rwork, iwork_shape__, iwork, ifail_shape__, i
     &fail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chpevx
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chpevx(jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m,
     & w, z, ldz, work, rwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine chpevx_c
      subroutine chpgst_c(itype, uplo, n, ap_shape__, ap, bp_shape__, bp
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        complex(kind=kind((0.0,0.0))), dimension(bp_shape__(1)) :: bp
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chpgst
        fw_iserr__ = -1
        call chpgst(itype, uplo, n, ap, bp, info)
        fw_iserr__ = 0
      end subroutine chpgst_c
      subroutine chpgv_c(itype, jobz, uplo, n, ap_shape__, ap, bp_shape_
     &_, bp, w_shape__, w, z_shape__, z, ldz, work_shape__, work, rwork_
     &shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        complex(kind=kind((0.0,0.0))), dimension(bp_shape__(1)) :: bp
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chpgv
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chpgv(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork,
     & info)
        fw_iserr__ = 0
      end subroutine chpgv_c
      subroutine chpgvd_c(itype, jobz, uplo, n, ap_shape__, ap, bp_shape
     &__, bp, w_shape__, w, z_shape__, z, ldz, work_shape__, work, lwork
     &, rwork_shape__, rwork, lrwork, iwork_shape__, iwork, liwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        complex(kind=kind((0.0,0.0))), dimension(bp_shape__(1)) :: bp
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chpgvd
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chpgvd(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork
     &, rwork, lrwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine chpgvd_c
      subroutine chpgvx_c(itype, jobz, range, uplo, n, ap_shape__, ap, b
     &p_shape__, bp, vl, vu, il, iu, abstol, m, w_shape__, w, z_shape__,
     & z, ldz, work_shape__, work, rwork_shape__, rwork, iwork_shape__, 
     &iwork, ifail_shape__, ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        complex(kind=kind((0.0,0.0))), dimension(bp_shape__(1)) :: bp
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chpgvx
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chpgvx(itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu,
     & abstol, m, w, z, ldz, work, rwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine chpgvx_c
      subroutine chprfs_c(uplo, n, nrhs, ap_shape__, ap, afp_shape__, af
     &p, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx, ferr_
     &shape__, ferr, berr_shape__, berr, work_shape__, work, rwork_shape
     &__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex(kind=kind((0.0,0.0))), dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chprfs(uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, 
     &berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine chprfs_c
      subroutine chpsv_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, ip
     &iv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chpsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chpsv(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine chpsv_c
      subroutine chpsvx_c(fact, uplo, n, nrhs, ap_shape__, ap, afp_shape
     &__, afp, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx,
     & rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work
     &, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex(kind=kind((0.0,0.0))), dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chpsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chpsvx(fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, 
     &rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine chpsvx_c
      subroutine chptrd_c(uplo, n, ap_shape__, ap, d_shape__, d, e_shape
     &__, e, tau_shape__, tau, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chptrd
        fw_iserr__ = -1
        call chptrd(uplo, n, ap, d, e, tau, info)
        fw_iserr__ = 0
      end subroutine chptrd_c
      subroutine chptrf_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chptrf
        fw_iserr__ = -1
        call chptrf(uplo, n, ap, ipiv, info)
        fw_iserr__ = 0
      end subroutine chptrf_c
      subroutine chptri_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, w
     &ork_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chptri
        fw_iserr__ = -1
        call chptri(uplo, n, ap, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine chptri_c
      subroutine chptrs_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, i
     &piv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chptrs(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine chptrs_c
      subroutine chsein_c(side, eigsrc, initv, select_shape__, select, n
     &, h_shape__, h, ldh, w_shape__, w, vl_shape__, vl, ldvl, vr_shape_
     &_, vr, ldvr, mm, m, work_shape__, work, rwork_shape__, rwork, ifai
     &ll_shape__, ifaill, ifailr_shape__, ifailr, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: eigsrc
        character(len=1, kind=kind('a')) :: initv
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: vl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vl_shape__(1), vl_shape
     &__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vr_shape__(1), vr_shape
     &__(2)) :: vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: ifaill_shape__
        integer, dimension(ifaill_shape__(1)) :: ifaill
        integer, dimension(1) :: ifailr_shape__
        integer, dimension(ifailr_shape__(1)) :: ifailr
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chsein
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chsein(side, eigsrc, initv, select, n, h, ldh, w, vl, ldvl,
     & vr, ldvr, mm, m, work, rwork, ifaill, ifailr, info)
        fw_iserr__ = 0
      end subroutine chsein_c
      subroutine chseqr_c(job, compz, n, ilo, ihi, h_shape__, h, ldh, w_
     &shape__, w, z_shape__, z, ldz, work_shape__, work, lwork, info, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external chseqr
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call chseqr(job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lw
     &ork, info)
        fw_iserr__ = 0
      end subroutine chseqr_c
      subroutine cla_gbamv_c(trans, m, n, kl, ku, alpha, ab_shape__, ab,
     & ldab, x_shape__, x, incx, beta, y_shape__, y, incy, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: trans
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        real(kind=kind(0.0)) :: alpha
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_gbamv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cla_gbamv(trans, m, n, kl, ku, alpha, ab, ldab, x, incx, be
     &ta, y, incy)
        fw_iserr__ = 0
      end subroutine cla_gbamv_c
      subroutine cla_gbrcond_c_c(fw_ret_arg, trans, n, kl, ku, ab_shape_
     &_, ab, ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, c_shape_
     &_, c, capply, info, work_shape__, work, rwork_shape__, rwork, fw_i
     &serr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex(kind=kind((0.0,0.0))), dimension(afb_shape__(1), afb_sha
     &pe__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer(kind=kind(0)) :: capply
        integer :: info
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_gbrcond_c
        external cla_gbrcond_c
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_gbrcond_c(trans, n, kl, ku, ab, ldab, afb, ldaf
     &b, ipiv, c, capply, info, work, rwork)
        fw_iserr__ = 0
      end subroutine cla_gbrcond_c_c
      subroutine cla_gbrcond_x_c(fw_ret_arg, trans, n, kl, ku, ab_shape_
     &_, ab, ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, x_shape_
     &_, x, info, work_shape__, work, rwork_shape__, rwork, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex(kind=kind((0.0,0.0))), dimension(afb_shape__(1), afb_sha
     &pe__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: info
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_gbrcond_x
        external cla_gbrcond_x
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_gbrcond_x(trans, n, kl, ku, ab, ldab, afb, ldaf
     &b, ipiv, x, info, work, rwork)
        fw_iserr__ = 0
      end subroutine cla_gbrcond_x_c
      subroutine cla_gbrfsx_extended_c(prec_type, trans_type, n, kl, ku,
     & nrhs, ab_shape__, ab, ldab, afb_shape__, afb, ldafb, ipiv_shape__
     &, ipiv, colequ, c_shape__, c, b_shape__, b, ldb, y_shape__, y, ldy
     &, berr_out_shape__, berr_out, n_norms, err_bnds_norm_shape__, err_
     &bnds_norm, err_bnds_comp_shape__, err_bnds_comp, res_shape__, res,
     & ayb_shape__, ayb, dy_shape__, dy, y_tail_shape__, y_tail, rcond, 
     &ithresh, rthresh, dz_ub, ignore_cwise, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        integer :: trans_type
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex(kind=kind((0.0,0.0))), dimension(afb_shape__(1), afb_sha
     &pe__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1), y_shape__
     &(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0)), dimension(berr_out_shape__(1)) :: berr_out
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        complex(kind=kind((0.0,0.0))), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        complex(kind=kind((0.0,0.0))), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_tail_shape__(1)) :: y
     &_tail
        real(kind=kind(0.0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0)) :: rthresh
        real(kind=kind(0.0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_gbrfsx_extended
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cla_gbrfsx_extended(prec_type, trans_type, n, kl, ku, nrhs,
     & ab, ldab, afb, ldafb, ipiv, colequ, c, b, ldb, y, ldy, berr_out, 
     &n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond
     &, ithresh, rthresh, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine cla_gbrfsx_extended_c
      subroutine cla_gbrpvgrw_c(fw_ret_arg, n, kl, ku, ncols, ab_shape__
     &, ab, ldab, afb_shape__, afb, ldafb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        integer :: n
        integer :: kl
        integer :: ku
        integer :: ncols
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex(kind=kind((0.0,0.0))), dimension(afb_shape__(1), afb_sha
     &pe__(2)) :: afb
        integer :: ldafb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_gbrpvgrw
        external cla_gbrpvgrw
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_gbrpvgrw(n, kl, ku, ncols, ab, ldab, afb, ldafb
     &)
        fw_iserr__ = 0
      end subroutine cla_gbrpvgrw_c
      subroutine cla_geamv_c(trans, m, n, alpha, a_shape__, a, lda, x_sh
     &ape__, x, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: trans
        integer :: m
        integer :: n
        real(kind=kind(0.0)) :: alpha
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_geamv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cla_geamv(trans, m, n, alpha, a, lda, x, incx, beta, y, inc
     &y)
        fw_iserr__ = 0
      end subroutine cla_geamv_c
      subroutine cla_gercond_c_c(fw_ret_arg, trans, n, a_shape__, a, lda
     &, af_shape__, af, ldaf, ipiv_shape__, ipiv, c_shape__, c, capply, 
     &info, work_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer(kind=kind(0)) :: capply
        integer :: info
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_gercond_c
        external cla_gercond_c
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_gercond_c(trans, n, a, lda, af, ldaf, ipiv, c, 
     &capply, info, work, rwork)
        fw_iserr__ = 0
      end subroutine cla_gercond_c_c
      subroutine cla_gercond_x_c(fw_ret_arg, trans, n, a_shape__, a, lda
     &, af_shape__, af, ldaf, ipiv_shape__, ipiv, x_shape__, x, info, wo
     &rk_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: info
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_gercond_x
        external cla_gercond_x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_gercond_x(trans, n, a, lda, af, ldaf, ipiv, x, 
     &info, work, rwork)
        fw_iserr__ = 0
      end subroutine cla_gercond_x_c
      subroutine cla_gerfsx_extended_c(prec_type, trans_type, n, nrhs, a
     &_shape__, a, lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, colequ
     &, c_shape__, c, b_shape__, b, ldb, y_shape__, y, ldy, berr_out_sha
     &pe__, berr_out, n_norms, errs_n_shape__, errs_n, errs_c_shape__, e
     &rrs_c, res_shape__, res, ayb_shape__, ayb, dy_shape__, dy, y_tail_
     &shape__, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        integer :: trans_type
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1), y_shape__
     &(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0)), dimension(berr_out_shape__(1)) :: berr_out
        integer :: n_norms
        integer, dimension(2) :: errs_n_shape__
        real(kind=kind(0.0)), dimension(errs_n_shape__(1), errs_n_shape_
     &_(2)) :: errs_n
        integer, dimension(2) :: errs_c_shape__
        real(kind=kind(0.0)), dimension(errs_c_shape__(1), errs_c_shape_
     &_(2)) :: errs_c
        integer, dimension(1) :: res_shape__
        complex(kind=kind((0.0,0.0))), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        complex(kind=kind((0.0,0.0))), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_tail_shape__(1)) :: y
     &_tail
        real(kind=kind(0.0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0)) :: rthresh
        real(kind=kind(0.0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_gerfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (errs_n_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("errs_n                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (errs_c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("errs_c                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cla_gerfsx_extended(prec_type, trans_type, n, nrhs, a, lda,
     & af, ldaf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err
     &s_n, errs_c, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub,
     & ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine cla_gerfsx_extended_c
      subroutine cla_heamv_c(uplo, n, alpha, a_shape__, a, lda, x_shape_
     &_, x, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: uplo
        integer :: n
        real(kind=kind(0.0)) :: alpha
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_heamv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cla_heamv(uplo, n, alpha, a, lda, x, incx, beta, y, incy)
        fw_iserr__ = 0
      end subroutine cla_heamv_c
      subroutine cla_hercond_c_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, ipiv_shape__, ipiv, c_shape__, c, capply, i
     &nfo, work_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer(kind=kind(0)) :: capply
        integer :: info
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_hercond_c
        external cla_hercond_c
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_hercond_c(uplo, n, a, lda, af, ldaf, ipiv, c, c
     &apply, info, work, rwork)
        fw_iserr__ = 0
      end subroutine cla_hercond_c_c
      subroutine cla_hercond_x_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, ipiv_shape__, ipiv, x_shape__, x, info, wor
     &k_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: info
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_hercond_x
        external cla_hercond_x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_hercond_x(uplo, n, a, lda, af, ldaf, ipiv, x, i
     &nfo, work, rwork)
        fw_iserr__ = 0
      end subroutine cla_hercond_x_c
      subroutine cla_herfsx_extended_c(prec_type, uplo, n, nrhs, a_shape
     &__, a, lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, colequ, c_sh
     &ape__, c, b_shape__, b, ldb, y_shape__, y, ldy, berr_out_shape__, 
     &berr_out, n_norms, err_bnds_norm_shape__, err_bnds_norm, err_bnds_
     &comp_shape__, err_bnds_comp, res_shape__, res, ayb_shape__, ayb, d
     &y_shape__, dy, y_tail_shape__, y_tail, rcond, ithresh, rthresh, dz
     &_ub, ignore_cwise, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1), y_shape__
     &(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0)), dimension(berr_out_shape__(1)) :: berr_out
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        complex(kind=kind((0.0,0.0))), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        complex(kind=kind((0.0,0.0))), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_tail_shape__(1)) :: y
     &_tail
        real(kind=kind(0.0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0)) :: rthresh
        real(kind=kind(0.0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_herfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cla_herfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, l
     &daf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_
     &norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh
     &, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine cla_herfsx_extended_c
      subroutine cla_herpvgrw_c(fw_ret_arg, uplo, n, info, a_shape__, a,
     & lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, work_shape__, work
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1) :: uplo
        integer :: n
        integer :: info
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_herpvgrw
        external cla_herpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_herpvgrw(uplo, n, info, a, lda, af, ldaf, ipiv,
     & work)
        fw_iserr__ = 0
      end subroutine cla_herpvgrw_c
      subroutine cla_lin_berr_c(n, nz, nrhs, res_shape__, res, ayb_shape
     &__, ayb, berr_shape__, berr, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nz
        integer :: nrhs
        integer, dimension(2) :: res_shape__
        complex(kind=kind((0.0,0.0))), dimension(res_shape__(1), res_sha
     &pe__(2)) :: res
        integer, dimension(2) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1), ayb_shape__(2)) 
     &:: ayb
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_lin_berr
        fw_iserr__ = -1
        if ((n) .ne. (res_shape__(1)) .or. (nrhs) .lt. 0 .or. (nrhs) .gt
     &. (res_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("res                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .ne. (ayb_shape__(1)) .or. (nrhs) .lt. 0 .or. (nrhs) .gt
     &. (ayb_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ayb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .lt. 0 .or. (nrhs) .gt. (berr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("berr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cla_lin_berr(n, nz, nrhs, res, ayb, berr)
        fw_iserr__ = 0
      end subroutine cla_lin_berr_c
      subroutine cla_porcond_c_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, c_shape__, c, capply, info, work_shape__, w
     &ork, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer(kind=kind(0)) :: capply
        integer :: info
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_porcond_c
        external cla_porcond_c
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_porcond_c(uplo, n, a, lda, af, ldaf, c, capply,
     & info, work, rwork)
        fw_iserr__ = 0
      end subroutine cla_porcond_c_c
      subroutine cla_porcond_x_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, x_shape__, x, info, work_shape__, work, rwo
     &rk_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: info
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_porcond_x
        external cla_porcond_x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_porcond_x(uplo, n, a, lda, af, ldaf, x, info, w
     &ork, rwork)
        fw_iserr__ = 0
      end subroutine cla_porcond_x_c
      subroutine cla_porfsx_extended_c(prec_type, uplo, n, nrhs, a_shape
     &__, a, lda, af_shape__, af, ldaf, colequ, c_shape__, c, b_shape__,
     & b, ldb, y_shape__, y, ldy, berr_out_shape__, berr_out, n_norms, e
     &rr_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bn
     &ds_comp, res_shape__, res, ayb_shape__, ayb, dy_shape__, dy, y_tai
     &l_shape__, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1), y_shape__
     &(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0)), dimension(berr_out_shape__(1)) :: berr_out
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        complex(kind=kind((0.0,0.0))), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        complex(kind=kind((0.0,0.0))), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_tail_shape__(1)) :: y
     &_tail
        real(kind=kind(0.0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0)) :: rthresh
        real(kind=kind(0.0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_porfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cla_porfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, l
     &daf, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, 
     &err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_u
     &b, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine cla_porfsx_extended_c
      subroutine cla_porpvgrw_c(fw_ret_arg, uplo, ncols, a_shape__, a, l
     &da, af_shape__, af, ldaf, work_shape__, work, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1) :: uplo
        integer :: ncols
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_porpvgrw
        external cla_porpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_porpvgrw(uplo, ncols, a, lda, af, ldaf, work)
        fw_iserr__ = 0
      end subroutine cla_porpvgrw_c
      subroutine cla_rpvgrw_c(fw_ret_arg, n, ncols, a_shape__, a, lda, a
     &f_shape__, af, ldaf, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        integer :: n
        integer :: ncols
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_rpvgrw
        external cla_rpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_rpvgrw(n, ncols, a, lda, af, ldaf)
        fw_iserr__ = 0
      end subroutine cla_rpvgrw_c
      subroutine cla_syamv_c(uplo, n, alpha, a_shape__, a, lda, x_shape_
     &_, x, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: uplo
        integer :: n
        real(kind=kind(0.0)) :: alpha
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_syamv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cla_syamv(uplo, n, alpha, a, lda, x, incx, beta, y, incy)
        fw_iserr__ = 0
      end subroutine cla_syamv_c
      subroutine cla_syrcond_c_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, ipiv_shape__, ipiv, c_shape__, c, capply, i
     &nfo, work_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer(kind=kind(0)) :: capply
        integer :: info
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_syrcond_c
        external cla_syrcond_c
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_syrcond_c(uplo, n, a, lda, af, ldaf, ipiv, c, c
     &apply, info, work, rwork)
        fw_iserr__ = 0
      end subroutine cla_syrcond_c_c
      subroutine cla_syrcond_x_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, ipiv_shape__, ipiv, x_shape__, x, info, wor
     &k_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: info
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_syrcond_x
        external cla_syrcond_x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_syrcond_x(uplo, n, a, lda, af, ldaf, ipiv, x, i
     &nfo, work, rwork)
        fw_iserr__ = 0
      end subroutine cla_syrcond_x_c
      subroutine cla_syrfsx_extended_c(prec_type, uplo, n, nrhs, a_shape
     &__, a, lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, colequ, c_sh
     &ape__, c, b_shape__, b, ldb, y_shape__, y, ldy, berr_out_shape__, 
     &berr_out, n_norms, err_bnds_norm_shape__, err_bnds_norm, err_bnds_
     &comp_shape__, err_bnds_comp, res_shape__, res, ayb_shape__, ayb, d
     &y_shape__, dy, y_tail_shape__, y_tail, rcond, ithresh, rthresh, dz
     &_ub, ignore_cwise, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1), y_shape__
     &(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0)), dimension(berr_out_shape__(1)) :: berr_out
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        complex(kind=kind((0.0,0.0))), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        complex(kind=kind((0.0,0.0))), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_tail_shape__(1)) :: y
     &_tail
        real(kind=kind(0.0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0)) :: rthresh
        real(kind=kind(0.0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_syrfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cla_syrfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, l
     &daf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_
     &norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh
     &, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine cla_syrfsx_extended_c
      subroutine cla_syrpvgrw_c(fw_ret_arg, uplo, n, info, a_shape__, a,
     & lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, work_shape__, work
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1) :: uplo
        integer :: n
        integer :: info
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: cla_syrpvgrw
        external cla_syrpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = cla_syrpvgrw(uplo, n, info, a, lda, af, ldaf, ipiv,
     & work)
        fw_iserr__ = 0
      end subroutine cla_syrpvgrw_c
      subroutine cla_wwaddw_c(n, x_shape__, x, y_shape__, y, w_shape__, 
     &w, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1)) :: y
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cla_wwaddw
        fw_iserr__ = -1
        call cla_wwaddw(n, x, y, w)
        fw_iserr__ = 0
      end subroutine cla_wwaddw_c
      subroutine clabrd_c(m, n, nb, a_shape__, a, lda, d_shape__, d, e_s
     &hape__, e, tauq_shape__, tauq, taup_shape__, taup, x_shape__, x, l
     &dx, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nb
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        complex(kind=kind((0.0,0.0))), dimension(tauq_shape__(1)) :: tau
     &q
        integer, dimension(1) :: taup_shape__
        complex(kind=kind((0.0,0.0))), dimension(taup_shape__(1)) :: tau
     &p
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(2) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1), y_shape__
     &(2)) :: y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clabrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clabrd(m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y, ldy)
        fw_iserr__ = 0
      end subroutine clabrd_c
      subroutine clacgv_c(n, x_shape__, x, incx, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clacgv
        fw_iserr__ = -1
        call clacgv(n, x, incx)
        fw_iserr__ = 0
      end subroutine clacgv_c
      subroutine clacn2_c(n, v_shape__, v, x_shape__, x, est, kase, isav
     &e_shape__, isave, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1)) :: v
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0)) :: est
        integer :: kase
        integer, dimension(1) :: isave_shape__
        integer, dimension(isave_shape__(1)) :: isave
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clacn2
        fw_iserr__ = -1
        if ((3) .lt. 0 .or. (3) .gt. (isave_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("isave                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clacn2(n, v, x, est, kase, isave)
        fw_iserr__ = 0
      end subroutine clacn2_c
      subroutine clacon_c(n, v_shape__, v, x_shape__, x, est, kase, fw_i
     &serr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1)) :: v
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0)) :: est
        integer :: kase
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clacon
        fw_iserr__ = -1
        if ((n) .lt. 0 .or. (n) .gt. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clacon(n, v, x, est, kase)
        fw_iserr__ = 0
      end subroutine clacon_c
      subroutine clacp2_c(uplo, m, n, a_shape__, a, lda, b_shape__, b, l
     &db, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clacp2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clacp2(uplo, m, n, a, lda, b, ldb)
        fw_iserr__ = 0
      end subroutine clacp2_c
      subroutine clacpy_c(uplo, m, n, a_shape__, a, lda, b_shape__, b, l
     &db, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clacpy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clacpy(uplo, m, n, a, lda, b, ldb)
        fw_iserr__ = 0
      end subroutine clacpy_c
      subroutine clacrm_c(m, n, a_shape__, a, lda, b_shape__, b, ldb, c_
     &shape__, c, ldc, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clacrm
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clacrm(m, n, a, lda, b, ldb, c, ldc, rwork)
        fw_iserr__ = 0
      end subroutine clacrm_c
      subroutine clacrt_c(n, cx_shape__, cx, incx, cy_shape__, cy, incy,
     & c, s, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: cx_shape__
        complex(kind=kind((0.0,0.0))), dimension(cx_shape__(1)) :: cx
        integer :: incx
        integer, dimension(1) :: cy_shape__
        complex(kind=kind((0.0,0.0))), dimension(cy_shape__(1)) :: cy
        integer :: incy
        complex(kind=kind((0.0,0.0))) :: c
        complex(kind=kind((0.0,0.0))) :: s
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clacrt
        fw_iserr__ = -1
        call clacrt(n, cx, incx, cy, incy, c, s)
        fw_iserr__ = 0
      end subroutine clacrt_c
      subroutine cladiv_c(fw_ret_arg, x, y, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        complex(kind=kind((0.0,0.0))) :: fw_ret_arg
        complex(kind=kind((0.0,0.0))) :: x
        complex(kind=kind((0.0,0.0))) :: y
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        complex(kind=kind((0.0,0.0))) :: cladiv
        external cladiv
        fw_iserr__ = -1
        fw_ret_arg = cladiv(x, y)
        fw_iserr__ = 0
      end subroutine cladiv_c
      subroutine claed0_c(qsiz, n, d_shape__, d, e_shape__, e, q_shape__
     &, q, ldq, qstore_shape__, qstore, ldqs, rwork_shape__, rwork, iwor
     &k_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: qsiz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(2) :: qstore_shape__
        complex(kind=kind((0.0,0.0))), dimension(qstore_shape__(1), qsto
     &re_shape__(2)) :: qstore
        integer :: ldqs
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claed0
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldqs) .ne. (qstore_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("qstore                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claed0(qsiz, n, d, e, q, ldq, qstore, ldqs, rwork, iwork, i
     &nfo)
        fw_iserr__ = 0
      end subroutine claed0_c
      subroutine claed7_c(n, cutpnt, qsiz, tlvls, curlvl, curpbm, d_shap
     &e__, d, q_shape__, q, ldq, rho, indxq_shape__, indxq, qstore_shape
     &__, qstore, qptr_shape__, qptr, prmptr_shape__, prmptr, perm_shape
     &__, perm, givptr_shape__, givptr, givcol_shape__, givcol, givnum_s
     &hape__, givnum, work_shape__, work, rwork_shape__, rwork, iwork_sh
     &ape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: cutpnt
        integer :: qsiz
        integer :: tlvls
        integer :: curlvl
        integer :: curpbm
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        real(kind=kind(0.0)) :: rho
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        integer, dimension(1) :: qstore_shape__
        real(kind=kind(0.0)), dimension(qstore_shape__(1)) :: qstore
        integer, dimension(1) :: qptr_shape__
        integer, dimension(qptr_shape__(1)) :: qptr
        integer, dimension(1) :: prmptr_shape__
        integer, dimension(prmptr_shape__(1)) :: prmptr
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claed7
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claed7(n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q, ldq, r
     &ho, indxq, qstore, qptr, prmptr, perm, givptr, givcol, givnum, wor
     &k, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine claed7_c
      subroutine claed8_c(k, n, qsiz, q_shape__, q, ldq, d_shape__, d, r
     &ho, cutpnt, z_shape__, z, dlamda_shape__, dlamda, q2_shape__, q2, 
     &ldq2, w_shape__, w, indxp_shape__, indxp, indx_shape__, indx, indx
     &q_shape__, indxq, perm_shape__, perm, givptr, givcol_shape__, givc
     &ol, givnum_shape__, givnum, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: k
        integer :: n
        integer :: qsiz
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        real(kind=kind(0.0)) :: rho
        integer :: cutpnt
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: dlamda_shape__
        real(kind=kind(0.0)), dimension(dlamda_shape__(1)) :: dlamda
        integer, dimension(2) :: q2_shape__
        complex(kind=kind((0.0,0.0))), dimension(q2_shape__(1), q2_shape
     &__(2)) :: q2
        integer :: ldq2
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: indxp_shape__
        integer, dimension(indxp_shape__(1)) :: indxp
        integer, dimension(1) :: indx_shape__
        integer, dimension(indx_shape__(1)) :: indx
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claed8
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq2) .ne. (q2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claed8(k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda, q2, l
     &dq2, w, indxp, indx, indxq, perm, givptr, givcol, givnum, info)
        fw_iserr__ = 0
      end subroutine claed8_c
      subroutine claein_c(rightv, noinit, n, h_shape__, h, ldh, w, v_sha
     &pe__, v, b_shape__, b, ldb, rwork_shape__, rwork, eps3, smlnum, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: rightv
        integer(kind=kind(0)) :: noinit
        integer :: n
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        complex(kind=kind((0.0,0.0))) :: w
        integer, dimension(1) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1)) :: v
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        real(kind=kind(0.0)) :: eps3
        real(kind=kind(0.0)) :: smlnum
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claein
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claein(rightv, noinit, n, h, ldh, w, v, b, ldb, rwork, eps3
     &, smlnum, info)
        fw_iserr__ = 0
      end subroutine claein_c
      subroutine claesy_c(a, b, c, rt1, rt2, evscal, cs1, sn1, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        complex(kind=kind((0.0,0.0))) :: a
        complex(kind=kind((0.0,0.0))) :: b
        complex(kind=kind((0.0,0.0))) :: c
        complex(kind=kind((0.0,0.0))) :: rt1
        complex(kind=kind((0.0,0.0))) :: rt2
        complex(kind=kind((0.0,0.0))) :: evscal
        complex(kind=kind((0.0,0.0))) :: cs1
        complex(kind=kind((0.0,0.0))) :: sn1
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claesy
        fw_iserr__ = -1
        call claesy(a, b, c, rt1, rt2, evscal, cs1, sn1)
        fw_iserr__ = 0
      end subroutine claesy_c
      subroutine claev2_c(a, b, c, rt1, rt2, cs1, sn1, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        complex(kind=kind((0.0,0.0))) :: a
        complex(kind=kind((0.0,0.0))) :: b
        complex(kind=kind((0.0,0.0))) :: c
        real(kind=kind(0.0)) :: rt1
        real(kind=kind(0.0)) :: rt2
        real(kind=kind(0.0)) :: cs1
        complex(kind=kind((0.0,0.0))) :: sn1
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claev2
        fw_iserr__ = -1
        call claev2(a, b, c, rt1, rt2, cs1, sn1)
        fw_iserr__ = 0
      end subroutine claev2_c
      subroutine clag2z_c(m, n, sa_shape__, sa, ldsa, a_shape__, a, lda,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: sa_shape__
        complex(kind=kind((0.0,0.0))), dimension(sa_shape__(1), sa_shape
     &__(2)) :: sa
        integer :: ldsa
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clag2z
        fw_iserr__ = -1
        if ((ldsa) .ne. (sa_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sa                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clag2z(m, n, sa, ldsa, a, lda, info)
        fw_iserr__ = 0
      end subroutine clag2z_c
      subroutine clags2_c(upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, 
     &snv, csq, snq, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: upper
        real(kind=kind(0.0)) :: a1
        complex(kind=kind((0.0,0.0))) :: a2
        real(kind=kind(0.0)) :: a3
        real(kind=kind(0.0)) :: b1
        complex(kind=kind((0.0,0.0))) :: b2
        real(kind=kind(0.0)) :: b3
        real(kind=kind(0.0)) :: csu
        complex(kind=kind((0.0,0.0))) :: snu
        real(kind=kind(0.0)) :: csv
        complex(kind=kind((0.0,0.0))) :: snv
        real(kind=kind(0.0)) :: csq
        complex(kind=kind((0.0,0.0))) :: snq
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clags2
        fw_iserr__ = -1
        call clags2(upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, snv, c
     &sq, snq)
        fw_iserr__ = 0
      end subroutine clags2_c
      subroutine clagtm_c(trans, n, nrhs, alpha, dl_shape__, dl, d_shape
     &__, d, du_shape__, du, x_shape__, x, ldx, beta, b_shape__, b, ldb,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        real(kind=kind(0.0)) :: alpha
        integer, dimension(1) :: dl_shape__
        complex(kind=kind((0.0,0.0))), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex(kind=kind((0.0,0.0))), dimension(du_shape__(1)) :: du
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: beta
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clagtm
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clagtm(trans, n, nrhs, alpha, dl, d, du, x, ldx, beta, b, l
     &db)
        fw_iserr__ = 0
      end subroutine clagtm_c
      subroutine clahef_c(uplo, n, nb, kb, a_shape__, a, lda, ipiv_shape
     &__, ipiv, w_shape__, w, ldw, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nb
        integer :: kb
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1), w_shape__
     &(2)) :: w
        integer :: ldw
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clahef
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldw) .ne. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clahef(uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)
        fw_iserr__ = 0
      end subroutine clahef_c
      subroutine clahqr_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &w_shape__, w, iloz, ihiz, z_shape__, z, ldz, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clahqr
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clahqr(wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z,
     & ldz, info)
        fw_iserr__ = 0
      end subroutine clahqr_c
      subroutine clahr2_c(n, k, nb, a_shape__, a, lda, tau_shape__, tau,
     & t_shape__, t, ldt, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: k
        integer :: nb
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer, dimension(2) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1), y_shape__
     &(2)) :: y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clahr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nb) .lt. 0 .or. (nb) .gt. (tau_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tau                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (t
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (y
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clahr2(n, k, nb, a, lda, tau, t, ldt, y, ldy)
        fw_iserr__ = 0
      end subroutine clahr2_c
      subroutine clahrd_c(n, k, nb, a_shape__, a, lda, tau_shape__, tau,
     & t_shape__, t, ldt, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: k
        integer :: nb
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer, dimension(2) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1), y_shape__
     &(2)) :: y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clahrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nb) .lt. 0 .or. (nb) .gt. (tau_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tau                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (t
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (y
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clahrd(n, k, nb, a, lda, tau, t, ldt, y, ldy)
        fw_iserr__ = 0
      end subroutine clahrd_c
      subroutine claic1_c(job, j, x_shape__, x, sest, w_shape__, w, gamm
     &a, sestpr, s, c, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: job
        integer :: j
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0)) :: sest
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        complex(kind=kind((0.0,0.0))) :: gamma
        real(kind=kind(0.0)) :: sestpr
        complex(kind=kind((0.0,0.0))) :: s
        complex(kind=kind((0.0,0.0))) :: c
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claic1
        fw_iserr__ = -1
        if ((j) .lt. 0 .or. (j) .gt. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((j) .lt. 0 .or. (j) .gt. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claic1(job, j, x, sest, w, gamma, sestpr, s, c)
        fw_iserr__ = 0
      end subroutine claic1_c
      subroutine clals0_c(icompq, nl, nr, sqre, nrhs, b_shape__, b, ldb,
     & bx_shape__, bx, ldbx, perm_shape__, perm, givptr, givcol_shape__,
     & givcol, ldgcol, givnum_shape__, givnum, ldgnum, poles_shape__, po
     &les, difl_shape__, difl, difr_shape__, difr, z_shape__, z, k, c, s
     &, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: nl
        integer :: nr
        integer :: sqre
        integer :: nrhs
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: bx_shape__
        complex(kind=kind((0.0,0.0))), dimension(bx_shape__(1), bx_shape
     &__(2)) :: bx
        integer :: ldbx
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer :: ldgnum
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0)), dimension(poles_shape__(1), poles_shape__(
     &2)) :: poles
        integer, dimension(1) :: difl_shape__
        real(kind=kind(0.0)), dimension(difl_shape__(1)) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0)), dimension(difr_shape__(1), difr_shape__(2)
     &) :: difr
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer :: k
        real(kind=kind(0.0)) :: c
        real(kind=kind(0.0)) :: s
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clals0
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbx) .ne. (bx_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bx                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clals0(icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx, perm, 
     &givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z, k, c
     &, s, rwork, info)
        fw_iserr__ = 0
      end subroutine clals0_c
      subroutine clalsa_c(icompq, smlsiz, n, nrhs, b_shape__, b, ldb, bx
     &_shape__, bx, ldbx, u_shape__, u, ldu, vt_shape__, vt, k_shape__, 
     &k, difl_shape__, difl, difr_shape__, difr, z_shape__, z, poles_sha
     &pe__, poles, givptr_shape__, givptr, givcol_shape__, givcol, ldgco
     &l, perm_shape__, perm, givnum_shape__, givnum, c_shape__, c, s_sha
     &pe__, s, rwork_shape__, rwork, iwork_shape__, iwork, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: smlsiz
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: bx_shape__
        complex(kind=kind((0.0,0.0))), dimension(bx_shape__(1), bx_shape
     &__(2)) :: bx
        integer :: ldbx
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer, dimension(2) :: difl_shape__
        real(kind=kind(0.0)), dimension(difl_shape__(1), difl_shape__(2)
     &) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0)), dimension(difr_shape__(1), difr_shape__(2)
     &) :: difr
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0)), dimension(poles_shape__(1), poles_shape__(
     &2)) :: poles
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: perm_shape__
        integer, dimension(perm_shape__(1), perm_shape__(2)) :: perm
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clalsa
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbx) .ne. (bx_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bx                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difl                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (perm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("perm                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clalsa(icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, v
     &t, k, difl, difr, z, poles, givptr, givcol, ldgcol, perm, givnum, 
     &c, s, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine clalsa_c
      subroutine clalsd_c(uplo, smlsiz, n, nrhs, d_shape__, d, e_shape__
     &, e, b_shape__, b, ldb, rcond, rank, work_shape__, work, rwork_sha
     &pe__, rwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: smlsiz
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clalsd
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clalsd(uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond, rank, wo
     &rk, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine clalsd_c
      subroutine clangb_c(fw_ret_arg, norm, n, kl, ku, ab_shape__, ab, l
     &dab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clangb
        external clangb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = clangb(norm, n, kl, ku, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine clangb_c
      subroutine clange_c(fw_ret_arg, norm, m, n, a_shape__, a, lda, wor
     &k_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clange
        external clange
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = clange(norm, m, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine clange_c
      subroutine clangt_c(fw_ret_arg, norm, n, dl_shape__, dl, d_shape__
     &, d, du_shape__, du, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: dl_shape__
        complex(kind=kind((0.0,0.0))), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex(kind=kind((0.0,0.0))), dimension(du_shape__(1)) :: du
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clangt
        external clangt
        fw_iserr__ = -1
        fw_ret_arg = clangt(norm, n, dl, d, du)
        fw_iserr__ = 0
      end subroutine clangt_c
      subroutine clanhb_c(fw_ret_arg, norm, uplo, n, k, ab_shape__, ab, 
     &ldab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: k
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clanhb
        external clanhb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = clanhb(norm, uplo, n, k, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine clanhb_c
      subroutine clanhe_c(fw_ret_arg, norm, uplo, n, a_shape__, a, lda, 
     &work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clanhe
        external clanhe
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = clanhe(norm, uplo, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine clanhe_c
      subroutine clanhf_c(fw_ret_arg, norm, transr, uplo, n, a_shape__, 
     &a, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1)) :: a
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clanhf
        external clanhf
        fw_iserr__ = -1
        fw_ret_arg = clanhf(norm, transr, uplo, n, a, work)
        fw_iserr__ = 0
      end subroutine clanhf_c
      subroutine clanhp_c(fw_ret_arg, norm, uplo, n, ap_shape__, ap, wor
     &k_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clanhp
        external clanhp
        fw_iserr__ = -1
        fw_ret_arg = clanhp(norm, uplo, n, ap, work)
        fw_iserr__ = 0
      end subroutine clanhp_c
      subroutine clanhs_c(fw_ret_arg, norm, n, a_shape__, a, lda, work_s
     &hape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clanhs
        external clanhs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = clanhs(norm, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine clanhs_c
      subroutine clanht_c(fw_ret_arg, norm, n, d_shape__, d, e_shape__, 
     &e, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex(kind=kind((0.0,0.0))), dimension(e_shape__(1)) :: e
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clanht
        external clanht
        fw_iserr__ = -1
        fw_ret_arg = clanht(norm, n, d, e)
        fw_iserr__ = 0
      end subroutine clanht_c
      subroutine clansb_c(fw_ret_arg, norm, uplo, n, k, ab_shape__, ab, 
     &ldab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: k
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clansb
        external clansb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = clansb(norm, uplo, n, k, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine clansb_c
      subroutine clansp_c(fw_ret_arg, norm, uplo, n, ap_shape__, ap, wor
     &k_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clansp
        external clansp
        fw_iserr__ = -1
        fw_ret_arg = clansp(norm, uplo, n, ap, work)
        fw_iserr__ = 0
      end subroutine clansp_c
      subroutine clansy_c(fw_ret_arg, norm, uplo, n, a_shape__, a, lda, 
     &work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clansy
        external clansy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = clansy(norm, uplo, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine clansy_c
      subroutine clantb_c(fw_ret_arg, norm, uplo, diag, n, k, ab_shape__
     &, ab, ldab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: k
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clantb
        external clantb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = clantb(norm, uplo, diag, n, k, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine clantb_c
      subroutine clantp_c(fw_ret_arg, norm, uplo, diag, n, ap_shape__, a
     &p, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clantp
        external clantp
        fw_iserr__ = -1
        fw_ret_arg = clantp(norm, uplo, diag, n, ap, work)
        fw_iserr__ = 0
      end subroutine clantp_c
      subroutine clantr_c(fw_ret_arg, norm, uplo, diag, m, n, a_shape__,
     & a, lda, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: clantr
        external clantr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = clantr(norm, uplo, diag, m, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine clantr_c
      subroutine clapll_c(n, x_shape__, x, incx, y_shape__, y, incy, ssm
     &in, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1)) :: y
        integer :: incy
        real(kind=kind(0.0)) :: ssmin
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clapll
        fw_iserr__ = -1
        call clapll(n, x, incx, y, incy, ssmin)
        fw_iserr__ = 0
      end subroutine clapll_c
      subroutine clapmr_c(forwrd, m, n, x_shape__, x, ldx, k_shape__, k,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: forwrd
        integer :: m
        integer :: n
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clapmr
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clapmr(forwrd, m, n, x, ldx, k)
        fw_iserr__ = 0
      end subroutine clapmr_c
      subroutine clapmt_c(forwrd, m, n, x_shape__, x, ldx, k_shape__, k,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: forwrd
        integer :: m
        integer :: n
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clapmt
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clapmt(forwrd, m, n, x, ldx, k)
        fw_iserr__ = 0
      end subroutine clapmt_c
      subroutine claqgb_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__,
     & r, c_shape__, c, rowcnd, colcnd, amax, equed, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqgb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqgb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, 
     &equed)
        fw_iserr__ = 0
      end subroutine claqgb_c
      subroutine claqge_c(m, n, a_shape__, a, lda, r_shape__, r, c_shape
     &__, c, rowcnd, colcnd, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqge
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqge(m, n, a, lda, r, c, rowcnd, colcnd, amax, equed)
        fw_iserr__ = 0
      end subroutine claqge_c
      subroutine claqhb_c(uplo, n, kd, ab_shape__, ab, ldab, s_shape__, 
     &s, scond, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqhb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqhb(uplo, n, kd, ab, ldab, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine claqhb_c
      subroutine claqhe_c(uplo, n, a_shape__, a, lda, s_shape__, s, scon
     &d, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqhe
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqhe(uplo, n, a, lda, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine claqhe_c
      subroutine claqhp_c(uplo, n, ap_shape__, ap, s_shape__, s, scond, 
     &amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqhp
        fw_iserr__ = -1
        call claqhp(uplo, n, ap, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine claqhp_c
      subroutine claqp2_c(m, n, offset, a_shape__, a, lda, jpvt_shape__,
     & jpvt, tau_shape__, tau, vn1_shape__, vn1, vn2_shape__, vn2, work_
     &shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: offset
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: vn1_shape__
        real(kind=kind(0.0)), dimension(vn1_shape__(1)) :: vn1
        integer, dimension(1) :: vn2_shape__
        real(kind=kind(0.0)), dimension(vn2_shape__(1)) :: vn2
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqp2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqp2(m, n, offset, a, lda, jpvt, tau, vn1, vn2, work)
        fw_iserr__ = 0
      end subroutine claqp2_c
      subroutine claqps_c(m, n, offset, nb, kb, a_shape__, a, lda, jpvt_
     &shape__, jpvt, tau_shape__, tau, vn1_shape__, vn1, vn2_shape__, vn
     &2, auxv_shape__, auxv, f_shape__, f, ldf, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: offset
        integer :: nb
        integer :: kb
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: vn1_shape__
        real(kind=kind(0.0)), dimension(vn1_shape__(1)) :: vn1
        integer, dimension(1) :: vn2_shape__
        real(kind=kind(0.0)), dimension(vn2_shape__(1)) :: vn2
        integer, dimension(1) :: auxv_shape__
        complex(kind=kind((0.0,0.0))), dimension(auxv_shape__(1)) :: aux
     &v
        integer, dimension(2) :: f_shape__
        complex(kind=kind((0.0,0.0))), dimension(f_shape__(1), f_shape__
     &(2)) :: f
        integer :: ldf
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqps
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqps(m, n, offset, nb, kb, a, lda, jpvt, tau, vn1, vn2, a
     &uxv, f, ldf)
        fw_iserr__ = 0
      end subroutine claqps_c
      subroutine claqr0_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &w_shape__, w, iloz, ihiz, z_shape__, z, ldz, work_shape__, work, l
     &work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqr0
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqr0(wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z,
     & ldz, work, lwork, info)
        fw_iserr__ = 0
      end subroutine claqr0_c
      subroutine claqr1_c(n, h_shape__, h, ldh, s1, s2, v_shape__, v, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        complex(kind=kind((0.0,0.0))) :: s1
        complex(kind=kind((0.0,0.0))) :: s2
        integer, dimension(1) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1)) :: v
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqr1
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqr1(n, h, ldh, s1, s2, v)
        fw_iserr__ = 0
      end subroutine claqr1_c
      subroutine claqr2_c(wantt, wantz, n, ktop, kbot, nw, h_shape__, h,
     & ldh, iloz, ihiz, z_shape__, z, ldz, ns, nd, sh_shape__, sh, v_sha
     &pe__, v, ldv, nh, t_shape__, t, ldt, nv, wv_shape__, wv, ldwv, wor
     &k_shape__, work, lwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nw
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer :: ns
        integer :: nd
        integer, dimension(1) :: sh_shape__
        complex(kind=kind((0.0,0.0))), dimension(sh_shape__(1)) :: sh
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer :: nh
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer :: nv
        integer, dimension(2) :: wv_shape__
        complex(kind=kind((0.0,0.0))), dimension(wv_shape__(1), wv_shape
     &__(2)) :: wv
        integer :: ldwv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqr2
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqr2(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz,
     & z, ldz, ns, nd, sh, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork
     &)
        fw_iserr__ = 0
      end subroutine claqr2_c
      subroutine claqr3_c(wantt, wantz, n, ktop, kbot, nw, h_shape__, h,
     & ldh, iloz, ihiz, z_shape__, z, ldz, ns, nd, sh_shape__, sh, v_sha
     &pe__, v, ldv, nh, t_shape__, t, ldt, nv, wv_shape__, wv, ldwv, wor
     &k_shape__, work, lwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nw
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer :: ns
        integer :: nd
        integer, dimension(1) :: sh_shape__
        complex(kind=kind((0.0,0.0))), dimension(sh_shape__(1)) :: sh
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer :: nh
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer :: nv
        integer, dimension(2) :: wv_shape__
        complex(kind=kind((0.0,0.0))), dimension(wv_shape__(1), wv_shape
     &__(2)) :: wv
        integer :: ldwv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqr3
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqr3(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz,
     & z, ldz, ns, nd, sh, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork
     &)
        fw_iserr__ = 0
      end subroutine claqr3_c
      subroutine claqr4_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &w_shape__, w, iloz, ihiz, z_shape__, z, ldz, work_shape__, work, l
     &work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqr4
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqr4(wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z,
     & ldz, work, lwork, info)
        fw_iserr__ = 0
      end subroutine claqr4_c
      subroutine claqr5_c(wantt, wantz, kacc22, n, ktop, kbot, nshfts, s
     &_shape__, s, h_shape__, h, ldh, iloz, ihiz, z_shape__, z, ldz, v_s
     &hape__, v, ldv, u_shape__, u, ldu, nv, wv_shape__, wv, ldwv, nh, w
     &h_shape__, wh, ldwh, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: kacc22
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nshfts
        integer, dimension(1) :: s_shape__
        complex(kind=kind((0.0,0.0))), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: h_shape__
        complex(kind=kind((0.0,0.0))), dimension(h_shape__(1), h_shape__
     &(2)) :: h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer, dimension(2) :: u_shape__
        complex(kind=kind((0.0,0.0))), dimension(u_shape__(1), u_shape__
     &(2)) :: u
        integer :: ldu
        integer :: nv
        integer, dimension(2) :: wv_shape__
        complex(kind=kind((0.0,0.0))), dimension(wv_shape__(1), wv_shape
     &__(2)) :: wv
        integer :: ldwv
        integer :: nh
        integer, dimension(2) :: wh_shape__
        complex(kind=kind((0.0,0.0))), dimension(wh_shape__(1), wh_shape
     &__(2)) :: wh
        integer :: ldwh
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqr5
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwh) .ne. (wh_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wh                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqr5(wantt, wantz, kacc22, n, ktop, kbot, nshfts, s, h, l
     &dh, iloz, ihiz, z, ldz, v, ldv, u, ldu, nv, wv, ldwv, nh, wh, ldwh
     &)
        fw_iserr__ = 0
      end subroutine claqr5_c
      subroutine claqsb_c(uplo, n, kd, ab_shape__, ab, ldab, s_shape__, 
     &s, scond, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqsb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqsb(uplo, n, kd, ab, ldab, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine claqsb_c
      subroutine claqsp_c(uplo, n, ap_shape__, ap, s_shape__, s, scond, 
     &amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqsp
        fw_iserr__ = -1
        call claqsp(uplo, n, ap, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine claqsp_c
      subroutine claqsy_c(uplo, n, a_shape__, a, lda, s_shape__, s, scon
     &d, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claqsy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claqsy(uplo, n, a, lda, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine claqsy_c
      subroutine clar1v_c(n, b1, bn, lambda, d_shape__, d, l_shape__, l,
     & ld_shape__, ld, lld_shape__, lld, pivmin, gaptol, z_shape__, z, w
     &antnc, negcnt, ztz, mingma, r, isuppz_shape__, isuppz, nrminv, res
     &id, rqcorr, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: b1
        integer :: bn
        real(kind=kind(0.0)) :: lambda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: l_shape__
        real(kind=kind(0.0)), dimension(l_shape__(1)) :: l
        integer, dimension(1) :: ld_shape__
        real(kind=kind(0.0)), dimension(ld_shape__(1)) :: ld
        integer, dimension(1) :: lld_shape__
        real(kind=kind(0.0)), dimension(lld_shape__(1)) :: lld
        real(kind=kind(0.0)) :: pivmin
        real(kind=kind(0.0)) :: gaptol
        integer, dimension(1) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1)) :: z
        integer(kind=kind(0)) :: wantnc
        integer :: negcnt
        real(kind=kind(0.0)) :: ztz
        real(kind=kind(0.0)) :: mingma
        integer :: r
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        real(kind=kind(0.0)) :: nrminv
        real(kind=kind(0.0)) :: resid
        real(kind=kind(0.0)) :: rqcorr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clar1v
        fw_iserr__ = -1
        call clar1v(n, b1, bn, lambda, d, l, ld, lld, pivmin, gaptol, z,
     & wantnc, negcnt, ztz, mingma, r, isuppz, nrminv, resid, rqcorr, wo
     &rk)
        fw_iserr__ = 0
      end subroutine clar1v_c
      subroutine clar2v_c(n, x_shape__, x, y_shape__, y, z_shape__, z, i
     &ncx, c_shape__, c, s_shape__, s, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1)) :: y
        integer, dimension(1) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1)) :: z
        integer :: incx
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        complex(kind=kind((0.0,0.0))), dimension(s_shape__(1)) :: s
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clar2v
        fw_iserr__ = -1
        call clar2v(n, x, y, z, incx, c, s, incc)
        fw_iserr__ = 0
      end subroutine clar2v_c
      subroutine clarcm_c(m, n, a_shape__, a, lda, b_shape__, b, ldb, c_
     &shape__, c, ldc, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarcm
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarcm(m, n, a, lda, b, ldb, c, ldc, rwork)
        fw_iserr__ = 0
      end subroutine clarcm_c
      subroutine clarf_c(side, m, n, v_shape__, v, incv, tau, c_shape__,
     & c, ldc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1)) :: v
        integer :: incv
        complex(kind=kind((0.0,0.0))) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarf
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarf(side, m, n, v, incv, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine clarf_c
      subroutine clarfb_c(side, trans, direct, storev, m, n, k, v_shape_
     &_, v, ldv, t_shape__, t, ldt, c_shape__, c, ldc, work_shape__, wor
     &k, ldwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(2) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1), work_s
     &hape__(2)) :: work
        integer :: ldwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarfb
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarfb(side, trans, direct, storev, m, n, k, v, ldv, t, ldt
     &, c, ldc, work, ldwork)
        fw_iserr__ = 0
      end subroutine clarfb_c
      subroutine clarfg_c(n, alpha, x_shape__, x, incx, tau, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        complex(kind=kind((0.0,0.0))) :: alpha
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        complex(kind=kind((0.0,0.0))) :: tau
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarfg
        fw_iserr__ = -1
        call clarfg(n, alpha, x, incx, tau)
        fw_iserr__ = 0
      end subroutine clarfg_c
      subroutine clarfgp_c(n, alpha, x_shape__, x, incx, tau, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        complex(kind=kind((0.0,0.0))) :: alpha
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        complex(kind=kind((0.0,0.0))) :: tau
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarfgp
        fw_iserr__ = -1
        call clarfgp(n, alpha, x, incx, tau)
        fw_iserr__ = 0
      end subroutine clarfgp_c
      subroutine clarft_c(direct, storev, n, k, v_shape__, v, ldv, tau_s
     &hape__, tau, t_shape__, t, ldt, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarft
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarft(direct, storev, n, k, v, ldv, tau, t, ldt)
        fw_iserr__ = 0
      end subroutine clarft_c
      subroutine clarfx_c(side, m, n, v_shape__, v, tau, c_shape__, c, l
     &dc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1)) :: v
        complex(kind=kind((0.0,0.0))) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarfx
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarfx(side, m, n, v, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine clarfx_c
      subroutine clargv_c(n, x_shape__, x, incx, y_shape__, y, incy, c_s
     &hape__, c, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1)) :: y
        integer :: incy
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clargv
        fw_iserr__ = -1
        call clargv(n, x, incx, y, incy, c, incc)
        fw_iserr__ = 0
      end subroutine clargv_c
      subroutine clarnv_c(idist, iseed_shape__, iseed, n, x_shape__, x, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: idist
        integer, dimension(1) :: iseed_shape__
        integer, dimension(iseed_shape__(1)) :: iseed
        integer :: n
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarnv
        fw_iserr__ = -1
        if ((4) .lt. 0 .or. (4) .gt. (iseed_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("iseed                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarnv(idist, iseed, n, x)
        fw_iserr__ = 0
      end subroutine clarnv_c
      subroutine clarrv_c(n, vl, vu, d_shape__, d, l_shape__, l, pivmin,
     & isplit_shape__, isplit, m, dol, dou, minrgp, rtol1, rtol2, w_shap
     &e__, w, werr_shape__, werr, wgap_shape__, wgap, iblock_shape__, ib
     &lock, indexw_shape__, indexw, gers_shape__, gers, z_shape__, z, ld
     &z, isuppz_shape__, isuppz, work_shape__, work, iwork_shape__, iwor
     &k, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: l_shape__
        real(kind=kind(0.0)), dimension(l_shape__(1)) :: l
        real(kind=kind(0.0)) :: pivmin
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer :: m
        integer :: dol
        integer :: dou
        real(kind=kind(0.0)) :: minrgp
        real(kind=kind(0.0)) :: rtol1
        real(kind=kind(0.0)) :: rtol2
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0)), dimension(werr_shape__(1)) :: werr
        integer, dimension(1) :: wgap_shape__
        real(kind=kind(0.0)), dimension(wgap_shape__(1)) :: wgap
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: indexw_shape__
        integer, dimension(indexw_shape__(1)) :: indexw
        integer, dimension(1) :: gers_shape__
        real(kind=kind(0.0)), dimension(gers_shape__(1)) :: gers
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarrv
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarrv(n, vl, vu, d, l, pivmin, isplit, m, dol, dou, minrgp
     &, rtol1, rtol2, w, werr, wgap, iblock, indexw, gers, z, ldz, isupp
     &z, work, iwork, info)
        fw_iserr__ = 0
      end subroutine clarrv_c
      subroutine clarscl2_c(m, n, d_shape__, d, x_shape__, x, ldx, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarscl2
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarscl2(m, n, d, x, ldx)
        fw_iserr__ = 0
      end subroutine clarscl2_c
      subroutine clartg_c(f, g, cs, sn, r, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        complex(kind=kind((0.0,0.0))) :: f
        complex(kind=kind((0.0,0.0))) :: g
        real(kind=kind(0.0)) :: cs
        complex(kind=kind((0.0,0.0))) :: sn
        complex(kind=kind((0.0,0.0))) :: r
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clartg
        fw_iserr__ = -1
        call clartg(f, g, cs, sn, r)
        fw_iserr__ = 0
      end subroutine clartg_c
      subroutine clartv_c(n, x_shape__, x, incx, y_shape__, y, incy, c_s
     &hape__, c, s_shape__, s, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1)) :: y
        integer :: incy
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        complex(kind=kind((0.0,0.0))), dimension(s_shape__(1)) :: s
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clartv
        fw_iserr__ = -1
        call clartv(n, x, incx, y, incy, c, s, incc)
        fw_iserr__ = 0
      end subroutine clartv_c
      subroutine clarz_c(side, m, n, l, v_shape__, v, incv, tau, c_shape
     &__, c, ldc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer :: l
        integer, dimension(1) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1)) :: v
        integer :: incv
        complex(kind=kind((0.0,0.0))) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarz
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarz(side, m, n, l, v, incv, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine clarz_c
      subroutine clarzb_c(side, trans, direct, storev, m, n, k, l, v_sha
     &pe__, v, ldv, t_shape__, t, ldt, c_shape__, c, ldc, work_shape__, 
     &work, ldwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(2) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1), work_s
     &hape__(2)) :: work
        integer :: ldwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarzb
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarzb(side, trans, direct, storev, m, n, k, l, v, ldv, t, 
     &ldt, c, ldc, work, ldwork)
        fw_iserr__ = 0
      end subroutine clarzb_c
      subroutine clarzt_c(direct, storev, n, k, v_shape__, v, ldv, tau_s
     &hape__, tau, t_shape__, t, ldt, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clarzt
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clarzt(direct, storev, n, k, v, ldv, tau, t, ldt)
        fw_iserr__ = 0
      end subroutine clarzt_c
      subroutine clascl_c(type, kl, ku, cfrom, cto, m, n, a_shape__, a, 
     &lda, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: type
        integer :: kl
        integer :: ku
        real(kind=kind(0.0)) :: cfrom
        real(kind=kind(0.0)) :: cto
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clascl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clascl(type, kl, ku, cfrom, cto, m, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine clascl_c
      subroutine clascl2_c(m, n, d_shape__, d, x_shape__, x, ldx, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clascl2
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clascl2(m, n, d, x, ldx)
        fw_iserr__ = 0
      end subroutine clascl2_c
      subroutine claset_c(uplo, m, n, alpha, beta, a_shape__, a, lda, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: m
        integer :: n
        complex(kind=kind((0.0,0.0))) :: alpha
        complex(kind=kind((0.0,0.0))) :: beta
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claset
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claset(uplo, m, n, alpha, beta, a, lda)
        fw_iserr__ = 0
      end subroutine claset_c
      subroutine clasr_c(side, pivot, direct, m, n, c_shape__, c, s_shap
     &e__, s, a_shape__, a, lda, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: pivot
        character(len=1, kind=kind('a')) :: direct
        integer :: m
        integer :: n
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clasr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clasr(side, pivot, direct, m, n, c, s, a, lda)
        fw_iserr__ = 0
      end subroutine clasr_c
      subroutine classq_c(n, x_shape__, x, incx, scale, sumsq, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: scale
        real(kind=kind(0.0)) :: sumsq
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external classq
        fw_iserr__ = -1
        call classq(n, x, incx, scale, sumsq)
        fw_iserr__ = 0
      end subroutine classq_c
      subroutine claswp_c(n, a_shape__, a, lda, k1, k2, ipiv_shape__, ip
     &iv, incx, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: k1
        integer :: k2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external claswp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call claswp(n, a, lda, k1, k2, ipiv, incx)
        fw_iserr__ = 0
      end subroutine claswp_c
      subroutine clasyf_c(uplo, n, nb, kb, a_shape__, a, lda, ipiv_shape
     &__, ipiv, w_shape__, w, ldw, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nb
        integer :: kb
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1), w_shape__
     &(2)) :: w
        integer :: ldw
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clasyf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldw) .ne. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clasyf(uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)
        fw_iserr__ = 0
      end subroutine clasyf_c
      subroutine clatbs_c(uplo, trans, diag, normin, n, kd, ab_shape__, 
     &ab, ldab, x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clatbs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clatbs(uplo, trans, diag, normin, n, kd, ab, ldab, x, scale
     &, cnorm, info)
        fw_iserr__ = 0
      end subroutine clatbs_c
      subroutine clatdf_c(ijob, n, z_shape__, z, ldz, rhs_shape__, rhs, 
     &rdsum, rdscal, ipiv_shape__, ipiv, jpiv_shape__, jpiv, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: ijob
        integer :: n
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: rhs_shape__
        complex(kind=kind((0.0,0.0))), dimension(rhs_shape__(1)) :: rhs
        real(kind=kind(0.0)) :: rdsum
        real(kind=kind(0.0)) :: rdscal
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clatdf
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clatdf(ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv, jpiv)
        fw_iserr__ = 0
      end subroutine clatdf_c
      subroutine clatps_c(uplo, trans, diag, normin, n, ap_shape__, ap, 
     &x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clatps
        fw_iserr__ = -1
        call clatps(uplo, trans, diag, normin, n, ap, x, scale, cnorm, i
     &nfo)
        fw_iserr__ = 0
      end subroutine clatps_c
      subroutine clatrd_c(uplo, n, nb, a_shape__, a, lda, e_shape__, e, 
     &tau_shape__, tau, w_shape__, w, ldw, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nb
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1), w_shape__
     &(2)) :: w
        integer :: ldw
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clatrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldw) .ne. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clatrd(uplo, n, nb, a, lda, e, tau, w, ldw)
        fw_iserr__ = 0
      end subroutine clatrd_c
      subroutine clatrs_c(uplo, trans, diag, normin, n, a_shape__, a, ld
     &a, x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iserr__, fw
     &_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clatrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clatrs(uplo, trans, diag, normin, n, a, lda, x, scale, cnor
     &m, info)
        fw_iserr__ = 0
      end subroutine clatrs_c
      subroutine clatrz_c(m, n, l, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: l
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clatrz
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clatrz(m, n, l, a, lda, tau, work)
        fw_iserr__ = 0
      end subroutine clatrz_c
      subroutine clatzm_c(side, m, n, v_shape__, v, incv, tau, c1_shape_
     &_, c1, c2_shape__, c2, ldc, work_shape__, work, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1)) :: v
        integer :: incv
        complex(kind=kind((0.0,0.0))) :: tau
        integer, dimension(2) :: c1_shape__
        complex(kind=kind((0.0,0.0))), dimension(c1_shape__(1), c1_shape
     &__(2)) :: c1
        integer, dimension(2) :: c2_shape__
        complex(kind=kind((0.0,0.0))), dimension(c2_shape__(1), c2_shape
     &__(2)) :: c2
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clatzm
        fw_iserr__ = -1
        if ((ldc) .ne. (c1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clatzm(side, m, n, v, incv, tau, c1, c2, ldc, work)
        fw_iserr__ = 0
      end subroutine clatzm_c
      subroutine clauu2_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clauu2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clauu2(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine clauu2_c
      subroutine clauum_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external clauum
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call clauum(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine clauum_c
      subroutine cpbcon_c(uplo, n, kd, ab_shape__, ab, ldab, anorm, rcon
     &d, work_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpbcon(uplo, n, kd, ab, ldab, anorm, rcond, work, rwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine cpbcon_c
      subroutine cpbequ_c(uplo, n, kd, ab_shape__, ab, ldab, s_shape__, 
     &s, scond, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpbequ
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpbequ(uplo, n, kd, ab, ldab, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine cpbequ_c
      subroutine cpbrfs_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, afb_s
     &hape__, afb, ldafb, b_shape__, b, ldb, x_shape__, x, ldx, ferr_sha
     &pe__, ferr, berr_shape__, berr, work_shape__, work, rwork_shape__,
     & rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex(kind=kind((0.0,0.0))), dimension(afb_shape__(1), afb_sha
     &pe__(2)) :: afb
        integer :: ldafb
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpbrfs(uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, 
     &ldx, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cpbrfs_c
      subroutine cpbstf_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpbstf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpbstf(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine cpbstf_c
      subroutine cpbsv_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, b_shap
     &e__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpbsv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpbsv(uplo, n, kd, nrhs, ab, ldab, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cpbsv_c
      subroutine cpbsvx_c(fact, uplo, n, kd, nrhs, ab_shape__, ab, ldab,
     & afb_shape__, afb, ldafb, equed, s_shape__, s, b_shape__, b, ldb, 
     &x_shape__, x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, 
     &work_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex(kind=kind((0.0,0.0))), dimension(afb_shape__(1), afb_sha
     &pe__(2)) :: afb
        integer :: ldafb
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpbsvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpbsvx(fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed
     &, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cpbsvx_c
      subroutine cpbtf2_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpbtf2
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpbtf2(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine cpbtf2_c
      subroutine cpbtrf_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpbtrf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpbtrf(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine cpbtrf_c
      subroutine cpbtrs_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, b_sha
     &pe__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpbtrs(uplo, n, kd, nrhs, ab, ldab, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cpbtrs_c
      subroutine cpftrf_c(transr, uplo, n, a_shape__, a, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpftrf
        fw_iserr__ = -1
        call cpftrf(transr, uplo, n, a, info)
        fw_iserr__ = 0
      end subroutine cpftrf_c
      subroutine cpftri_c(transr, uplo, n, a_shape__, a, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpftri
        fw_iserr__ = -1
        call cpftri(transr, uplo, n, a, info)
        fw_iserr__ = 0
      end subroutine cpftri_c
      subroutine cpftrs_c(transr, uplo, n, nrhs, a_shape__, a, b_shape__
     &, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1)) :: a
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpftrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpftrs(transr, uplo, n, nrhs, a, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cpftrs_c
      subroutine cpocon_c(uplo, n, a_shape__, a, lda, anorm, rcond, work
     &_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpocon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpocon(uplo, n, a, lda, anorm, rcond, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cpocon_c
      subroutine cpoequ_c(n, a_shape__, a, lda, s_shape__, s, scond, ama
     &x, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpoequ
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpoequ(n, a, lda, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine cpoequ_c
      subroutine cpoequb_c(n, a_shape__, a, lda, s_shape__, s, scond, am
     &ax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpoequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpoequb(n, a, lda, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine cpoequb_c
      subroutine cporfs_c(uplo, n, nrhs, a_shape__, a, lda, af_shape__, 
     &af, ldaf, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr
     &, berr_shape__, berr, work_shape__, work, rwork_shape__, rwork, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cporfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cporfs(uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, fer
     &r, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cporfs_c
      subroutine cporfsx_c(uplo, equed, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, s_shape__, s, b_shape__, b, ldb, x_shape__, x, l
     &dx, rcond, berr_shape__, berr, n_err_bnds, err_bnds_norm_shape__, 
     &err_bnds_norm, err_bnds_comp_shape__, err_bnds_comp, nparams, para
     &ms_shape__, params, work_shape__, work, rwork_shape__, rwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cporfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cporfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, 
     &x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, npa
     &rams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cporfsx_c
      subroutine cposv_c(uplo, n, nrhs, a_shape__, a, lda, b_shape__, b,
     & ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cposv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cposv(uplo, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cposv_c
      subroutine cposvx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sha
     &pe__, af, ldaf, equed, s_shape__, s, b_shape__, b, ldb, x_shape__,
     & x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape
     &__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cposvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cposvx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, 
     &ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cposvx_c
      subroutine cposvxx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, equed, s_shape__, s, b_shape__, b, ldb, x_shape__
     &, x, ldx, rcond, rpvgrw, berr_shape__, berr, n_err_bnds, err_bnds_
     &norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bnds_comp,
     & nparams, params_shape__, params, work_shape__, work, rwork_shape_
     &_, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        real(kind=kind(0.0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cposvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cposvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b,
     & ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_
     &bnds_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cposvxx_c
      subroutine cpotf2_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpotf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpotf2(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine cpotf2_c
      subroutine cpotrf_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpotrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpotrf(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine cpotrf_c
      subroutine cpotri_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpotri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpotri(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine cpotri_c
      subroutine cpotrs_c(uplo, n, nrhs, a_shape__, a, lda, b_shape__, b
     &, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpotrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpotrs(uplo, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cpotrs_c
      subroutine cppcon_c(uplo, n, ap_shape__, ap, anorm, rcond, work_sh
     &ape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cppcon
        fw_iserr__ = -1
        call cppcon(uplo, n, ap, anorm, rcond, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cppcon_c
      subroutine cppequ_c(uplo, n, ap_shape__, ap, s_shape__, s, scond, 
     &amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cppequ
        fw_iserr__ = -1
        call cppequ(uplo, n, ap, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine cppequ_c
      subroutine cpprfs_c(uplo, n, nrhs, ap_shape__, ap, afp_shape__, af
     &p, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_
     &shape__, berr, work_shape__, work, rwork_shape__, rwork, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex(kind=kind((0.0,0.0))), dimension(afp_shape__(1)) :: afp
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpprfs(uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, 
     &work, rwork, info)
        fw_iserr__ = 0
      end subroutine cpprfs_c
      subroutine cppsv_c(uplo, n, nrhs, ap_shape__, ap, b_shape__, b, ld
     &b, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cppsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cppsv(uplo, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cppsv_c
      subroutine cppsvx_c(fact, uplo, n, nrhs, ap_shape__, ap, afp_shape
     &__, afp, equed, s_shape__, s, b_shape__, b, ldb, x_shape__, x, ldx
     &, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, wor
     &k, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex(kind=kind((0.0,0.0))), dimension(afp_shape__(1)) :: afp
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cppsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cppsvx(fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, l
     &dx, rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cppsvx_c
      subroutine cpptrf_c(uplo, n, ap_shape__, ap, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpptrf
        fw_iserr__ = -1
        call cpptrf(uplo, n, ap, info)
        fw_iserr__ = 0
      end subroutine cpptrf_c
      subroutine cpptri_c(uplo, n, ap_shape__, ap, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpptri
        fw_iserr__ = -1
        call cpptri(uplo, n, ap, info)
        fw_iserr__ = 0
      end subroutine cpptri_c
      subroutine cpptrs_c(uplo, n, nrhs, ap_shape__, ap, b_shape__, b, l
     &db, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpptrs(uplo, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cpptrs_c
      subroutine cpstf2_c(uplo, n, a_shape__, a, lda, piv_shape__, piv, 
     &rank, tol, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: piv_shape__
        integer, dimension(piv_shape__(1)) :: piv
        integer :: rank
        real(kind=kind(0.0)) :: tol
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpstf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (piv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("piv                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2*n) .lt. 0 .or. (2*n) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpstf2(uplo, n, a, lda, piv, rank, tol, work, info)
        fw_iserr__ = 0
      end subroutine cpstf2_c
      subroutine cpstrf_c(uplo, n, a_shape__, a, lda, piv_shape__, piv, 
     &rank, tol, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: piv_shape__
        integer, dimension(piv_shape__(1)) :: piv
        integer :: rank
        real(kind=kind(0.0)) :: tol
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpstrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (piv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("piv                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2*n) .lt. 0 .or. (2*n) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpstrf(uplo, n, a, lda, piv, rank, tol, work, info)
        fw_iserr__ = 0
      end subroutine cpstrf_c
      subroutine cptcon_c(n, d_shape__, d, e_shape__, e, anorm, rcond, r
     &work_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex(kind=kind((0.0,0.0))), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cptcon
        fw_iserr__ = -1
        call cptcon(n, d, e, anorm, rcond, rwork, info)
        fw_iserr__ = 0
      end subroutine cptcon_c
      subroutine cpteqr_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpteqr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpteqr(compz, n, d, e, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine cpteqr_c
      subroutine cptrfs_c(uplo, n, nrhs, d_shape__, d, e_shape__, e, df_
     &shape__, df, ef_shape__, ef, b_shape__, b, ldb, x_shape__, x, ldx,
     & ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, rwork
     &_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex(kind=kind((0.0,0.0))), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: ef_shape__
        complex(kind=kind((0.0,0.0))), dimension(ef_shape__(1)) :: ef
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cptrfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cptrfs(uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, b
     &err, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cptrfs_c
      subroutine cptsv_c(n, nrhs, d_shape__, d, e_shape__, e, b_shape__,
     & b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex(kind=kind((0.0,0.0))), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cptsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cptsv(n, nrhs, d, e, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cptsv_c
      subroutine cptsvx_c(fact, n, nrhs, d_shape__, d, e_shape__, e, df_
     &shape__, df, ef_shape__, ef, b_shape__, b, ldb, x_shape__, x, ldx,
     & rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work
     &, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex(kind=kind((0.0,0.0))), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: ef_shape__
        complex(kind=kind((0.0,0.0))), dimension(ef_shape__(1)) :: ef
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cptsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, 
     &ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cptsvx_c
      subroutine cpttrf_c(n, d_shape__, d, e_shape__, e, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex(kind=kind((0.0,0.0))), dimension(e_shape__(1)) :: e
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpttrf
        fw_iserr__ = -1
        call cpttrf(n, d, e, info)
        fw_iserr__ = 0
      end subroutine cpttrf_c
      subroutine cpttrs_c(uplo, n, nrhs, d_shape__, d, e_shape__, e, b_s
     &hape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex(kind=kind((0.0,0.0))), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cpttrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cpttrs(uplo, n, nrhs, d, e, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cpttrs_c
      subroutine cptts2_c(iuplo, n, nrhs, d_shape__, d, e_shape__, e, b_
     &shape__, b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: iuplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex(kind=kind((0.0,0.0))), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cptts2
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cptts2(iuplo, n, nrhs, d, e, b, ldb)
        fw_iserr__ = 0
      end subroutine cptts2_c
      subroutine crot_c(n, cx_shape__, cx, incx, cy_shape__, cy, incy, c
     &, s, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: cx_shape__
        complex(kind=kind((0.0,0.0))), dimension(cx_shape__(1)) :: cx
        integer :: incx
        integer, dimension(1) :: cy_shape__
        complex(kind=kind((0.0,0.0))), dimension(cy_shape__(1)) :: cy
        integer :: incy
        real(kind=kind(0.0)) :: c
        complex(kind=kind((0.0,0.0))) :: s
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external crot
        fw_iserr__ = -1
        call crot(n, cx, incx, cy, incy, c, s)
        fw_iserr__ = 0
      end subroutine crot_c
      subroutine cspcon_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, a
     &norm, rcond, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cspcon
        fw_iserr__ = -1
        call cspcon(uplo, n, ap, ipiv, anorm, rcond, work, info)
        fw_iserr__ = 0
      end subroutine cspcon_c
      subroutine cspmv_c(uplo, n, alpha, ap_shape__, ap, x_shape__, x, i
     &ncx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        complex(kind=kind((0.0,0.0))) :: alpha
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        complex(kind=kind((0.0,0.0))) :: beta
        integer, dimension(1) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cspmv
        fw_iserr__ = -1
        call cspmv(uplo, n, alpha, ap, x, incx, beta, y, incy)
        fw_iserr__ = 0
      end subroutine cspmv_c
      subroutine cspr_c(uplo, n, alpha, x_shape__, x, incx, ap_shape__, 
     &ap, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        complex(kind=kind((0.0,0.0))) :: alpha
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cspr
        fw_iserr__ = -1
        call cspr(uplo, n, alpha, x, incx, ap)
        fw_iserr__ = 0
      end subroutine cspr_c
      subroutine csprfs_c(uplo, n, nrhs, ap_shape__, ap, afp_shape__, af
     &p, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx, ferr_
     &shape__, ferr, berr_shape__, berr, work_shape__, work, rwork_shape
     &__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex(kind=kind((0.0,0.0))), dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csprfs(uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, 
     &berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine csprfs_c
      subroutine cspsv_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, ip
     &iv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cspsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cspsv(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine cspsv_c
      subroutine cspsvx_c(fact, uplo, n, nrhs, ap_shape__, ap, afp_shape
     &__, afp, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx,
     & rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work
     &, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex(kind=kind((0.0,0.0))), dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cspsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cspsvx(fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, 
     &rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine cspsvx_c
      subroutine csptrf_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csptrf
        fw_iserr__ = -1
        call csptrf(uplo, n, ap, ipiv, info)
        fw_iserr__ = 0
      end subroutine csptrf_c
      subroutine csptri_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, w
     &ork_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csptri
        fw_iserr__ = -1
        call csptri(uplo, n, ap, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine csptri_c
      subroutine csptrs_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, i
     &piv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csptrs(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine csptrs_c
      subroutine csrscl_c(n, sa, sx_shape__, sx, incx, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0)) :: sa
        integer, dimension(1) :: sx_shape__
        complex(kind=kind((0.0,0.0))), dimension(sx_shape__(1)) :: sx
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csrscl
        fw_iserr__ = -1
        call csrscl(n, sa, sx, incx)
        fw_iserr__ = 0
      end subroutine csrscl_c
      subroutine cstedc_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, lwork, rwork_shape__, rwork, lrwork
     &, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cstedc
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cstedc(compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, 
     &iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine cstedc_c
      subroutine cstegr_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, isuppz_s
     &hape__, isuppz, work_shape__, work, lwork, iwork_shape__, iwork, l
     &iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cstegr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cstegr(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, 
     &z, ldz, isuppz, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine cstegr_c
      subroutine cstein_c(n, d_shape__, d, e_shape__, e, m, w_shape__, w
     &, iblock_shape__, iblock, isplit_shape__, isplit, z_shape__, z, ld
     &z, work_shape__, work, iwork_shape__, iwork, ifail_shape__, ifail,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cstein
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cstein(n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, 
     &ifail, info)
        fw_iserr__ = 0
      end subroutine cstein_c
      subroutine cstemr_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, m, w_shape__, w, z_shape__, z, ldz, nzc, isuppz_shap
     &e__, isuppz, tryrac, work_shape__, work, lwork, iwork_shape__, iwo
     &rk, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer :: nzc
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer(kind=kind(0)) :: tryrac
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cstemr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cstemr(jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, 
     &nzc, isuppz, tryrac, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine cstemr_c
      subroutine csteqr_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csteqr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csteqr(compz, n, d, e, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine csteqr_c
      subroutine csycon_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, anorm, rcond, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csycon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csycon(uplo, n, a, lda, ipiv, anorm, rcond, work, info)
        fw_iserr__ = 0
      end subroutine csycon_c
      subroutine csyconv_c(uplo, way, n, a_shape__, a, lda, ipiv_shape__
     &, ipiv, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: way
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csyconv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csyconv(uplo, way, n, a, lda, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine csyconv_c
      subroutine csyequb_c(uplo, n, a_shape__, a, lda, s_shape__, s, sco
     &nd, amax, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csyequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csyequb(uplo, n, a, lda, s, scond, amax, work, info)
        fw_iserr__ = 0
      end subroutine csyequb_c
      subroutine csymv_c(uplo, n, alpha, a_shape__, a, lda, x_shape__, x
     &, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        complex(kind=kind((0.0,0.0))) :: alpha
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        complex(kind=kind((0.0,0.0))) :: beta
        integer, dimension(1) :: y_shape__
        complex(kind=kind((0.0,0.0))), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csymv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csymv(uplo, n, alpha, a, lda, x, incx, beta, y, incy)
        fw_iserr__ = 0
      end subroutine csymv_c
      subroutine csyr_c(uplo, n, alpha, x_shape__, x, incx, a_shape__, a
     &, lda, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        complex(kind=kind((0.0,0.0))) :: alpha
        integer, dimension(1) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csyr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csyr(uplo, n, alpha, x, incx, a, lda)
        fw_iserr__ = 0
      end subroutine csyr_c
      subroutine csyrfs_c(uplo, n, nrhs, a_shape__, a, lda, af_shape__, 
     &af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx
     &, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, rwor
     &k_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csyrfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csyrfs(uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ld
     &x, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine csyrfs_c
      subroutine csyrfsx_c(uplo, equed, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, ipiv_shape__, ipiv, s_shape__, s, b_shape__, b, 
     &ldb, x_shape__, x, ldx, rcond, berr_shape__, berr, n_err_bnds, err
     &_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bnds
     &_comp, nparams, params_shape__, params, work_shape__, work, rwork_
     &shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csyrfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csyrfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b,
     & ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_com
     &p, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine csyrfsx_c
      subroutine csysv_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__,
     & ipiv, b_shape__, b, ldb, work_shape__, work, lwork, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csysv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csysv(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine csysv_c
      subroutine csysvx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sha
     &pe__, af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, 
     &x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape_
     &_, work, lwork, rwork_shape__, rwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csysvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csysvx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     & x, ldx, rcond, ferr, berr, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine csysvx_c
      subroutine csysvxx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, ipiv_shape__, ipiv, equed, s_shape__, s, b_shape_
     &_, b, ldb, x_shape__, x, ldx, rcond, rpvgrw, berr_shape__, berr, n
     &_err_bnds, err_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_sha
     &pe__, err_bnds_comp, nparams, params_shape__, params, work_shape__
     &, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex(kind=kind((0.0,0.0))), dimension(af_shape__(1), af_shape
     &__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        real(kind=kind(0.0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csysvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csysvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed,
     & s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm
     &, err_bnds_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine csysvxx_c
      subroutine csyswapr_c(uplo, n, a_shape__, a, i1, i2, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: i1
        integer :: i2
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csyswapr
        fw_iserr__ = -1
        if ((n) .ne. (a_shape__(1)) .or. (n) .lt. 0 .or. (n) .gt. (a_sha
     &pe__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csyswapr(uplo, n, a, i1, i2)
        fw_iserr__ = 0
      end subroutine csyswapr_c
      subroutine csytf2_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csytf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csytf2(uplo, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine csytf2_c
      subroutine csytrf_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csytrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csytrf(uplo, n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine csytrf_c
      subroutine csytri_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csytri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csytri(uplo, n, a, lda, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine csytri_c
      subroutine csytri2_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipi
     &v, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csytri2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csytri2(uplo, n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine csytri2_c
      subroutine csytri2x_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ip
     &iv, work_shape__, work, nb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1), work_s
     &hape__(2)) :: work
        integer :: nb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csytri2x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n+nb+1) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csytri2x(uplo, n, a, lda, ipiv, work, nb, info)
        fw_iserr__ = 0
      end subroutine csytri2x_c
      subroutine csytrs_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__
     &, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csytrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csytrs(uplo, n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine csytrs_c
      subroutine csytrs2_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape_
     &_, ipiv, b_shape__, b, ldb, work_shape__, work, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external csytrs2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call csytrs2(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, info)
        fw_iserr__ = 0
      end subroutine csytrs2_c
      subroutine ctbcon_c(norm, uplo, diag, n, kd, ab_shape__, ab, ldab,
     & rcond, work_shape__, work, rwork_shape__, rwork, info, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctbcon(norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwor
     &k, info)
        fw_iserr__ = 0
      end subroutine ctbcon_c
      subroutine ctbrfs_c(uplo, trans, diag, n, kd, nrhs, ab_shape__, ab
     &, ldab, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, 
     &berr_shape__, berr, work_shape__, work, rwork_shape__, rwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctbrfs(uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x,
     & ldx, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ctbrfs_c
      subroutine ctbtrs_c(uplo, trans, diag, n, kd, nrhs, ab_shape__, ab
     &, ldab, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex(kind=kind((0.0,0.0))), dimension(ab_shape__(1), ab_shape
     &__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctbtrs(uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, in
     &fo)
        fw_iserr__ = 0
      end subroutine ctbtrs_c
      subroutine ctfsm_c(transr, side, uplo, trans, diag, m, n, alpha, a
     &_shape__, a, b_shape__, b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: m
        integer :: n
        complex(kind=kind((0.0,0.0))) :: alpha
        integer, dimension(1) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1)) :: a
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctfsm
        fw_iserr__ = -1
        if (((ldb-1) - (0) + 1) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctfsm(transr, side, uplo, trans, diag, m, n, alpha, a, b, l
     &db)
        fw_iserr__ = 0
      end subroutine ctfsm_c
      subroutine ctftri_c(transr, uplo, diag, n, a_shape__, a, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctftri
        fw_iserr__ = -1
        call ctftri(transr, uplo, diag, n, a, info)
        fw_iserr__ = 0
      end subroutine ctftri_c
      subroutine ctfttp_c(transr, uplo, n, arf_shape__, arf, ap_shape__,
     & ap, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: arf_shape__
        complex(kind=kind((0.0,0.0))), dimension(arf_shape__(1)) :: arf
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctfttp
        fw_iserr__ = -1
        call ctfttp(transr, uplo, n, arf, ap, info)
        fw_iserr__ = 0
      end subroutine ctfttp_c
      subroutine ctfttr_c(transr, uplo, n, arf_shape__, arf, a_shape__, 
     &a, lda, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: arf_shape__
        complex(kind=kind((0.0,0.0))), dimension(arf_shape__(1)) :: arf
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctfttr
        fw_iserr__ = -1
        if (((lda-1) - (0) + 1) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctfttr(transr, uplo, n, arf, a, lda, info)
        fw_iserr__ = 0
      end subroutine ctfttr_c
      subroutine ctgevc_c(side, howmny, select_shape__, select, n, s_sha
     &pe__, s, lds, p_shape__, p, ldp, vl_shape__, vl, ldvl, vr_shape__,
     & vr, ldvr, mm, m, work_shape__, work, rwork_shape__, rwork, info, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: s_shape__
        complex(kind=kind((0.0,0.0))), dimension(s_shape__(1), s_shape__
     &(2)) :: s
        integer :: lds
        integer, dimension(2) :: p_shape__
        complex(kind=kind((0.0,0.0))), dimension(p_shape__(1), p_shape__
     &(2)) :: p
        integer :: ldp
        integer, dimension(2) :: vl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vl_shape__(1), vl_shape
     &__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vr_shape__(1), vr_shape
     &__(2)) :: vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctgevc
        fw_iserr__ = -1
        if ((lds) .ne. (s_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("s                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldp) .ne. (p_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("p                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctgevc(side, howmny, select, n, s, lds, p, ldp, vl, ldvl, v
     &r, ldvr, mm, m, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ctgevc_c
      subroutine ctgex2_c(wantq, wantz, n, a_shape__, a, lda, b_shape__,
     & b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, j1, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer :: j1
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctgex2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctgex2(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, j1,
     & info)
        fw_iserr__ = 0
      end subroutine ctgex2_c
      subroutine ctgexc_c(wantq, wantz, n, a_shape__, a, lda, b_shape__,
     & b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, ifst, ilst, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer :: ifst
        integer :: ilst
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctgexc
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctgexc(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifs
     &t, ilst, info)
        fw_iserr__ = 0
      end subroutine ctgexc_c
      subroutine ctgsen_c(ijob, wantq, wantz, select_shape__, select, n,
     & a_shape__, a, lda, b_shape__, b, ldb, alpha_shape__, alpha, beta_
     &shape__, beta, q_shape__, q, ldq, z_shape__, z, ldz, m, pl, pr, di
     &f_shape__, dif, work_shape__, work, lwork, iwork_shape__, iwork, l
     &iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: ijob
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        complex(kind=kind((0.0,0.0))), dimension(alpha_shape__(1)) :: al
     &pha
        integer, dimension(1) :: beta_shape__
        complex(kind=kind((0.0,0.0))), dimension(beta_shape__(1)) :: bet
     &a
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        complex(kind=kind((0.0,0.0))), dimension(z_shape__(1), z_shape__
     &(2)) :: z
        integer :: ldz
        integer :: m
        real(kind=kind(0.0)) :: pl
        real(kind=kind(0.0)) :: pr
        integer, dimension(1) :: dif_shape__
        real(kind=kind(0.0)), dimension(dif_shape__(1)) :: dif
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctgsen
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctgsen(ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha
     &, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork
     &, info)
        fw_iserr__ = 0
      end subroutine ctgsen_c
      subroutine ctgsja_c(jobu, jobv, jobq, m, p, n, k, l, a_shape__, a,
     & lda, b_shape__, b, ldb, tola, tolb, alpha_shape__, alpha, beta_sh
     &ape__, beta, u_shape__, u, ldu, v_shape__, v, ldv, q_shape__, q, l
     &dq, work_shape__, work, ncycle, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: p
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: tola
        real(kind=kind(0.0)) :: tolb
        integer, dimension(1) :: alpha_shape__
        real(kind=kind(0.0)), dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: u_shape__
        complex(kind=kind((0.0,0.0))), dimension(u_shape__(1), u_shape__
     &(2)) :: u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        complex(kind=kind((0.0,0.0))), dimension(v_shape__(1), v_shape__
     &(2)) :: v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: ncycle
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctgsja
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctgsja(jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tol
     &a, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle, info)
        fw_iserr__ = 0
      end subroutine ctgsja_c
      subroutine ctgsna_c(job, howmny, select_shape__, select, n, a_shap
     &e__, a, lda, b_shape__, b, ldb, vl_shape__, vl, ldvl, vr_shape__, 
     &vr, ldvr, s_shape__, s, dif_shape__, dif, mm, m, work_shape__, wor
     &k, lwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: vl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vl_shape__(1), vl_shape
     &__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vr_shape__(1), vr_shape
     &__(2)) :: vr
        integer :: ldvr
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: dif_shape__
        real(kind=kind(0.0)), dimension(dif_shape__(1)) :: dif
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctgsna
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctgsna(job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr
     &, ldvr, s, dif, mm, m, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine ctgsna_c
      subroutine ctgsy2_c(trans, ijob, m, n, a_shape__, a, lda, b_shape_
     &_, b, ldb, c_shape__, c, ldc, d_shape__, d, ldd, e_shape__, e, lde
     &, f_shape__, f, ldf, scale, rdsum, rdscal, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: ijob
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(2) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1), d_shape__
     &(2)) :: d
        integer :: ldd
        integer, dimension(2) :: e_shape__
        complex(kind=kind((0.0,0.0))), dimension(e_shape__(1), e_shape__
     &(2)) :: e
        integer :: lde
        integer, dimension(2) :: f_shape__
        complex(kind=kind((0.0,0.0))), dimension(f_shape__(1), f_shape__
     &(2)) :: f
        integer :: ldf
        real(kind=kind(0.0)) :: scale
        real(kind=kind(0.0)) :: rdsum
        real(kind=kind(0.0)) :: rdscal
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctgsy2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldd) .ne. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lde) .ne. (e_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("e                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctgsy2(trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e
     &, lde, f, ldf, scale, rdsum, rdscal, info)
        fw_iserr__ = 0
      end subroutine ctgsy2_c
      subroutine ctgsyl_c(trans, ijob, m, n, a_shape__, a, lda, b_shape_
     &_, b, ldb, c_shape__, c, ldc, d_shape__, d, ldd, e_shape__, e, lde
     &, f_shape__, f, ldf, scale, dif, work_shape__, work, lwork, iwork_
     &shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: ijob
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(2) :: d_shape__
        complex(kind=kind((0.0,0.0))), dimension(d_shape__(1), d_shape__
     &(2)) :: d
        integer :: ldd
        integer, dimension(2) :: e_shape__
        complex(kind=kind((0.0,0.0))), dimension(e_shape__(1), e_shape__
     &(2)) :: e
        integer :: lde
        integer, dimension(2) :: f_shape__
        complex(kind=kind((0.0,0.0))), dimension(f_shape__(1), f_shape__
     &(2)) :: f
        integer :: ldf
        real(kind=kind(0.0)) :: scale
        real(kind=kind(0.0)) :: dif
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctgsyl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldd) .ne. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lde) .ne. (e_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("e                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctgsyl(trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e
     &, lde, f, ldf, scale, dif, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine ctgsyl_c
      subroutine ctpcon_c(norm, uplo, diag, n, ap_shape__, ap, rcond, wo
     &rk_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctpcon
        fw_iserr__ = -1
        call ctpcon(norm, uplo, diag, n, ap, rcond, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ctpcon_c
      subroutine ctprfs_c(uplo, trans, diag, n, nrhs, ap_shape__, ap, b_
     &shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_shape
     &__, berr, work_shape__, work, rwork_shape__, rwork, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctprfs(uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr
     &, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ctprfs_c
      subroutine ctptri_c(uplo, diag, n, ap_shape__, ap, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctptri
        fw_iserr__ = -1
        call ctptri(uplo, diag, n, ap, info)
        fw_iserr__ = 0
      end subroutine ctptri_c
      subroutine ctptrs_c(uplo, trans, diag, n, nrhs, ap_shape__, ap, b_
     &shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctptrs(uplo, trans, diag, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine ctptrs_c
      subroutine ctpttf_c(transr, uplo, n, ap_shape__, ap, arf_shape__, 
     &arf, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: arf_shape__
        complex(kind=kind((0.0,0.0))), dimension(arf_shape__(1)) :: arf
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctpttf
        fw_iserr__ = -1
        call ctpttf(transr, uplo, n, ap, arf, info)
        fw_iserr__ = 0
      end subroutine ctpttf_c
      subroutine ctpttr_c(uplo, n, ap_shape__, ap, a_shape__, a, lda, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctpttr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctpttr(uplo, n, ap, a, lda, info)
        fw_iserr__ = 0
      end subroutine ctpttr_c
      subroutine ctrcon_c(norm, uplo, diag, n, a_shape__, a, lda, rcond,
     & work_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrcon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrcon(norm, uplo, diag, n, a, lda, rcond, work, rwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine ctrcon_c
      subroutine ctrevc_c(side, howmny, select_shape__, select, n, t_sha
     &pe__, t, ldt, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, mm, m, w
     &ork_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer, dimension(2) :: vl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vl_shape__(1), vl_shape
     &__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vr_shape__(1), vr_shape
     &__(2)) :: vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrevc
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrevc(side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr,
     & mm, m, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ctrevc_c
      subroutine ctrexc_c(compq, n, t_shape__, t, ldt, q_shape__, q, ldq
     &, ifst, ilst, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compq
        integer :: n
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer :: ifst
        integer :: ilst
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrexc
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrexc(compq, n, t, ldt, q, ldq, ifst, ilst, info)
        fw_iserr__ = 0
      end subroutine ctrexc_c
      subroutine ctrrfs_c(uplo, trans, diag, n, nrhs, a_shape__, a, lda,
     & b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_sh
     &ape__, berr, work_shape__, work, rwork_shape__, rwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex(kind=kind((0.0,0.0))), dimension(x_shape__(1), x_shape__
     &(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrrfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrrfs(uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, 
     &ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ctrrfs_c
      subroutine ctrsen_c(job, compq, select_shape__, select, n, t_shape
     &__, t, ldt, q_shape__, q, ldq, w_shape__, w, m, s, sep, work_shape
     &__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compq
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(1) :: w_shape__
        complex(kind=kind((0.0,0.0))), dimension(w_shape__(1)) :: w
        integer :: m
        real(kind=kind(0.0)) :: s
        real(kind=kind(0.0)) :: sep
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrsen
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrsen(job, compq, select, n, t, ldt, q, ldq, w, m, s, sep,
     & work, lwork, info)
        fw_iserr__ = 0
      end subroutine ctrsen_c
      subroutine ctrsna_c(job, howmny, select_shape__, select, n, t_shap
     &e__, t, ldt, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, s_shape__
     &, s, sep_shape__, sep, mm, m, work_shape__, work, ldwork, rwork_sh
     &ape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        complex(kind=kind((0.0,0.0))), dimension(t_shape__(1), t_shape__
     &(2)) :: t
        integer :: ldt
        integer, dimension(2) :: vl_shape__
        complex(kind=kind((0.0,0.0))), dimension(vl_shape__(1), vl_shape
     &__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex(kind=kind((0.0,0.0))), dimension(vr_shape__(1), vr_shape
     &__(2)) :: vr
        integer :: ldvr
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: sep_shape__
        real(kind=kind(0.0)), dimension(sep_shape__(1)) :: sep
        integer :: mm
        integer :: m
        integer, dimension(2) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1), work_s
     &hape__(2)) :: work
        integer :: ldwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrsna
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrsna(job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, 
     &s, sep, mm, m, work, ldwork, rwork, info)
        fw_iserr__ = 0
      end subroutine ctrsna_c
      subroutine ctrsyl_c(trana, tranb, isgn, m, n, a_shape__, a, lda, b
     &_shape__, b, ldb, c_shape__, c, ldc, scale, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trana
        character(len=1, kind=kind('a')) :: tranb
        integer :: isgn
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        real(kind=kind(0.0)) :: scale
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrsyl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, sc
     &ale, info)
        fw_iserr__ = 0
      end subroutine ctrsyl_c
      subroutine ctrti2_c(uplo, diag, n, a_shape__, a, lda, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrti2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrti2(uplo, diag, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine ctrti2_c
      subroutine ctrtri_c(uplo, diag, n, a_shape__, a, lda, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrtri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrtri(uplo, diag, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine ctrtri_c
      subroutine ctrtrs_c(uplo, trans, diag, n, nrhs, a_shape__, a, lda,
     & b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0,0.0))), dimension(b_shape__(1), b_shape__
     &(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrtrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrtrs(uplo, trans, diag, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine ctrtrs_c
      subroutine ctrttf_c(transr, uplo, n, a_shape__, a, lda, arf_shape_
     &_, arf, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: arf_shape__
        complex(kind=kind((0.0,0.0))), dimension(arf_shape__(1)) :: arf
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrttf
        fw_iserr__ = -1
        if (((lda-1) - (0) + 1) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrttf(transr, uplo, n, a, lda, arf, info)
        fw_iserr__ = 0
      end subroutine ctrttf_c
      subroutine ctrttp_c(uplo, n, a_shape__, a, lda, ap_shape__, ap, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctrttp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctrttp(uplo, n, a, lda, ap, info)
        fw_iserr__ = 0
      end subroutine ctrttp_c
      subroutine ctzrqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctzrqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctzrqf(m, n, a, lda, tau, info)
        fw_iserr__ = 0
      end subroutine ctzrqf_c
      subroutine ctzrzf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ctzrzf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ctzrzf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine ctzrzf_c
      subroutine cunbdb_c(trans, signs, m, p, q, x11_shape__, x11, ldx11
     &, x12_shape__, x12, ldx12, x21_shape__, x21, ldx21, x22_shape__, x
     &22, ldx22, theta_shape__, theta, phi_shape__, phi, taup1_shape__, 
     &taup1, taup2_shape__, taup2, tauq1_shape__, tauq1, tauq2_shape__, 
     &tauq2, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: signs
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(2) :: x11_shape__
        complex(kind=kind((0.0,0.0))), dimension(x11_shape__(1), x11_sha
     &pe__(2)) :: x11
        integer :: ldx11
        integer, dimension(2) :: x12_shape__
        complex(kind=kind((0.0,0.0))), dimension(x12_shape__(1), x12_sha
     &pe__(2)) :: x12
        integer :: ldx12
        integer, dimension(2) :: x21_shape__
        complex(kind=kind((0.0,0.0))), dimension(x21_shape__(1), x21_sha
     &pe__(2)) :: x21
        integer :: ldx21
        integer, dimension(2) :: x22_shape__
        complex(kind=kind((0.0,0.0))), dimension(x22_shape__(1), x22_sha
     &pe__(2)) :: x22
        integer :: ldx22
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(1) :: phi_shape__
        real(kind=kind(0.0)), dimension(phi_shape__(1)) :: phi
        integer, dimension(1) :: taup1_shape__
        complex(kind=kind((0.0,0.0))), dimension(taup1_shape__(1)) :: ta
     &up1
        integer, dimension(1) :: taup2_shape__
        complex(kind=kind((0.0,0.0))), dimension(taup2_shape__(1)) :: ta
     &up2
        integer, dimension(1) :: tauq1_shape__
        complex(kind=kind((0.0,0.0))), dimension(tauq1_shape__(1)) :: ta
     &uq1
        integer, dimension(1) :: tauq2_shape__
        complex(kind=kind((0.0,0.0))), dimension(tauq2_shape__(1)) :: ta
     &uq2
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunbdb
        fw_iserr__ = -1
        if ((ldx11) .ne. (x11_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x11                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx12) .ne. (x12_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x12                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx21) .ne. (x21_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x21                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx22) .ne. (x22_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x22                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunbdb(trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, 
     &ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, l
     &work, info)
        fw_iserr__ = 0
      end subroutine cunbdb_c
      subroutine cuncsd_c(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m,
     & p, q, x11_shape__, x11, ldx11, x12_shape__, x12, ldx12, x21_shape
     &__, x21, ldx21, x22_shape__, x22, ldx22, theta_shape__, theta, u1_
     &shape__, u1, ldu1, u2_shape__, u2, ldu2, v1t_shape__, v1t, ldv1t, 
     &v2t_shape__, v2t, ldv2t, work_shape__, work, lwork, rwork_shape__,
     & rwork, lrwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu1
        character(len=1, kind=kind('a')) :: jobu2
        character(len=1, kind=kind('a')) :: jobv1t
        character(len=1, kind=kind('a')) :: jobv2t
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: signs
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(2) :: x11_shape__
        complex(kind=kind((0.0,0.0))), dimension(x11_shape__(1), x11_sha
     &pe__(2)) :: x11
        integer :: ldx11
        integer, dimension(2) :: x12_shape__
        complex(kind=kind((0.0,0.0))), dimension(x12_shape__(1), x12_sha
     &pe__(2)) :: x12
        integer :: ldx12
        integer, dimension(2) :: x21_shape__
        complex(kind=kind((0.0,0.0))), dimension(x21_shape__(1), x21_sha
     &pe__(2)) :: x21
        integer :: ldx21
        integer, dimension(2) :: x22_shape__
        complex(kind=kind((0.0,0.0))), dimension(x22_shape__(1), x22_sha
     &pe__(2)) :: x22
        integer :: ldx22
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(2) :: u1_shape__
        complex(kind=kind((0.0,0.0))), dimension(u1_shape__(1), u1_shape
     &__(2)) :: u1
        integer :: ldu1
        integer, dimension(2) :: u2_shape__
        complex(kind=kind((0.0,0.0))), dimension(u2_shape__(1), u2_shape
     &__(2)) :: u2
        integer :: ldu2
        integer, dimension(2) :: v1t_shape__
        complex(kind=kind((0.0,0.0))), dimension(v1t_shape__(1), v1t_sha
     &pe__(2)) :: v1t
        integer :: ldv1t
        integer, dimension(2) :: v2t_shape__
        complex(kind=kind((0.0,0.0))), dimension(v2t_shape__(1), v2t_sha
     &pe__(2)) :: v2t
        integer :: ldv2t
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cuncsd
        fw_iserr__ = -1
        if ((ldx11) .ne. (x11_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x11                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx12) .ne. (x12_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x12                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx21) .ne. (x21_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x21                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx22) .ne. (x22_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x22                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu1) .ne. (u1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv1t) .ne. (v1t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v1t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv2t) .ne. (v2t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v2t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cuncsd(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q,
     & x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, 
     &u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwor
     &k, info)
        fw_iserr__ = 0
      end subroutine cuncsd_c
      subroutine cung2l_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cung2l
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cung2l(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine cung2l_c
      subroutine cung2r_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cung2r
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cung2r(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine cung2r_c
      subroutine cungbr_c(vect, m, n, k, a_shape__, a, lda, tau_shape__,
     & tau, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cungbr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cungbr(vect, m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cungbr_c
      subroutine cunghr_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunghr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunghr(n, ilo, ihi, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cunghr_c
      subroutine cungl2_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cungl2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cungl2(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine cungl2_c
      subroutine cunglq_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunglq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunglq(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cunglq_c
      subroutine cungql_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cungql
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cungql(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cungql_c
      subroutine cungqr_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cungqr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cungqr(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cungqr_c
      subroutine cungr2_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cungr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cungr2(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine cungr2_c
      subroutine cungrq_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cungrq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cungrq(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cungrq_c
      subroutine cungtr_c(uplo, n, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cungtr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cungtr(uplo, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine cungtr_c
      subroutine cunm2l_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunm2l
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunm2l(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine cunm2l_c
      subroutine cunm2r_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunm2r
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunm2r(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine cunm2r_c
      subroutine cunmbr_c(vect, side, trans, m, n, k, a_shape__, a, lda,
     & tau_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunmbr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunmbr(vect, side, trans, m, n, k, a, lda, tau, c, ldc, wor
     &k, lwork, info)
        fw_iserr__ = 0
      end subroutine cunmbr_c
      subroutine cunmhr_c(side, trans, m, n, ilo, ihi, a_shape__, a, lda
     &, tau_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, 
     &info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunmhr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunmhr(side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, wo
     &rk, lwork, info)
        fw_iserr__ = 0
      end subroutine cunmhr_c
      subroutine cunml2_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunml2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunml2(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine cunml2_c
      subroutine cunmlq_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunmlq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunmlq(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine cunmlq_c
      subroutine cunmql_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunmql
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunmql(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine cunmql_c
      subroutine cunmqr_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunmqr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunmqr(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine cunmqr_c
      subroutine cunmr2_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunmr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunmr2(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine cunmr2_c
      subroutine cunmr3_c(side, trans, m, n, k, l, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunmr3
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunmr3(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, 
     &info)
        fw_iserr__ = 0
      end subroutine cunmr3_c
      subroutine cunmrq_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunmrq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunmrq(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine cunmrq_c
      subroutine cunmrz_c(side, trans, m, n, k, l, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunmrz
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunmrz(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, 
     &lwork, info)
        fw_iserr__ = 0
      end subroutine cunmrz_c
      subroutine cunmtr_c(side, uplo, trans, m, n, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cunmtr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cunmtr(side, uplo, trans, m, n, a, lda, tau, c, ldc, work, 
     &lwork, info)
        fw_iserr__ = 0
      end subroutine cunmtr_c
      subroutine cupgtr_c(uplo, n, ap_shape__, ap, tau_shape__, tau, q_s
     &hape__, q, ldq, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: q_shape__
        complex(kind=kind((0.0,0.0))), dimension(q_shape__(1), q_shape__
     &(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cupgtr
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cupgtr(uplo, n, ap, tau, q, ldq, work, info)
        fw_iserr__ = 0
      end subroutine cupgtr_c
      subroutine cupmtr_c(side, uplo, trans, m, n, ap_shape__, ap, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex(kind=kind((0.0,0.0))), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: tau_shape__
        complex(kind=kind((0.0,0.0))), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex(kind=kind((0.0,0.0))), dimension(c_shape__(1), c_shape__
     &(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0,0.0))), dimension(work_shape__(1)) :: wor
     &k
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external cupmtr
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call cupmtr(side, uplo, trans, m, n, ap, tau, c, ldc, work, info
     &)
        fw_iserr__ = 0
      end subroutine cupmtr_c
      subroutine dbbcsd_c(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, 
     &theta_shape__, theta, phi_shape__, phi, u1_shape__, u1, ldu1, u2_s
     &hape__, u2, ldu2, v1t_shape__, v1t, ldv1t, v2t_shape__, v2t, ldv2t
     &, b11d_shape__, b11d, b11e_shape__, b11e, b12d_shape__, b12d, b12e
     &_shape__, b12e, b21d_shape__, b21d, b21e_shape__, b21e, b22d_shape
     &__, b22d, b22e_shape__, b22e, work_shape__, work, lwork, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu1
        character(len=1, kind=kind('a')) :: jobu2
        character(len=1, kind=kind('a')) :: jobv1t
        character(len=1, kind=kind('a')) :: jobv2t
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0D0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(1) :: phi_shape__
        real(kind=kind(0.0D0)), dimension(phi_shape__(1)) :: phi
        integer, dimension(2) :: u1_shape__
        real(kind=kind(0.0D0)), dimension(u1_shape__(1), u1_shape__(2)) 
     &:: u1
        integer :: ldu1
        integer, dimension(2) :: u2_shape__
        real(kind=kind(0.0D0)), dimension(u2_shape__(1), u2_shape__(2)) 
     &:: u2
        integer :: ldu2
        integer, dimension(2) :: v1t_shape__
        real(kind=kind(0.0D0)), dimension(v1t_shape__(1), v1t_shape__(2)
     &) :: v1t
        integer :: ldv1t
        integer, dimension(2) :: v2t_shape__
        real(kind=kind(0.0D0)), dimension(v2t_shape__(1), v2t_shape__(2)
     &) :: v2t
        integer :: ldv2t
        integer, dimension(1) :: b11d_shape__
        real(kind=kind(0.0D0)), dimension(b11d_shape__(1)) :: b11d
        integer, dimension(1) :: b11e_shape__
        real(kind=kind(0.0D0)), dimension(b11e_shape__(1)) :: b11e
        integer, dimension(1) :: b12d_shape__
        real(kind=kind(0.0D0)), dimension(b12d_shape__(1)) :: b12d
        integer, dimension(1) :: b12e_shape__
        real(kind=kind(0.0D0)), dimension(b12e_shape__(1)) :: b12e
        integer, dimension(1) :: b21d_shape__
        real(kind=kind(0.0D0)), dimension(b21d_shape__(1)) :: b21d
        integer, dimension(1) :: b21e_shape__
        real(kind=kind(0.0D0)), dimension(b21e_shape__(1)) :: b21e
        integer, dimension(1) :: b22d_shape__
        real(kind=kind(0.0D0)), dimension(b22d_shape__(1)) :: b22d
        integer, dimension(1) :: b22e_shape__
        real(kind=kind(0.0D0)), dimension(b22e_shape__(1)) :: b22e
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dbbcsd
        fw_iserr__ = -1
        if ((ldu1) .ne. (u1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv1t) .ne. (v1t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v1t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv2t) .ne. (v2t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v2t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dbbcsd(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta,
     & phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d
     &, b12e, b21d, b21e, b22d, b22e, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dbbcsd_c
      subroutine dbdsdc_c(uplo, compq, n, d_shape__, d, e_shape__, e, u_
     &shape__, u, ldu, vt_shape__, vt, ldvt, q_shape__, q, iq_shape__, i
     &q, work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: compq
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer :: ldvt
        integer, dimension(1) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1)) :: q
        integer, dimension(1) :: iq_shape__
        integer, dimension(iq_shape__(1)) :: iq
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dbdsdc
        fw_iserr__ = -1
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dbdsdc(uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work,
     & iwork, info)
        fw_iserr__ = 0
      end subroutine dbdsdc_c
      subroutine dbdsqr_c(uplo, n, ncvt, nru, ncc, d_shape__, d, e_shape
     &__, e, vt_shape__, vt, ldvt, u_shape__, u, ldu, c_shape__, c, ldc,
     & work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ncvt
        integer :: nru
        integer :: ncc
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer :: ldvt
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dbdsqr
        fw_iserr__ = -1
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dbdsqr(uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, 
     &ldc, work, info)
        fw_iserr__ = 0
      end subroutine dbdsqr_c
      subroutine ddisna_c(job, m, n, d_shape__, d, sep_shape__, sep, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        integer :: m
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: sep_shape__
        real(kind=kind(0.0D0)), dimension(sep_shape__(1)) :: sep
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ddisna
        fw_iserr__ = -1
        call ddisna(job, m, n, d, sep, info)
        fw_iserr__ = 0
      end subroutine ddisna_c
      subroutine dgbbrd_c(vect, m, n, ncc, kl, ku, ab_shape__, ab, ldab,
     & d_shape__, d, e_shape__, e, q_shape__, q, ldq, pt_shape__, pt, ld
     &pt, c_shape__, c, ldc, work_shape__, work, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        integer :: m
        integer :: n
        integer :: ncc
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(2) :: pt_shape__
        real(kind=kind(0.0D0)), dimension(pt_shape__(1), pt_shape__(2)) 
     &:: pt
        integer :: ldpt
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbbrd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldpt) .ne. (pt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("pt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbbrd(vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt,
     & ldpt, c, ldc, work, info)
        fw_iserr__ = 0
      end subroutine dgbbrd_c
      subroutine dgbcon_c(norm, n, kl, ku, ab_shape__, ab, ldab, ipiv_sh
     &ape__, ipiv, anorm, rcond, work_shape__, work, iwork_shape__, iwor
     &k, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbcon(norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work,
     & iwork, info)
        fw_iserr__ = 0
      end subroutine dgbcon_c
      subroutine dgbequ_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__,
     & r, c_shape__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbequ
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbequ(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, 
     &info)
        fw_iserr__ = 0
      end subroutine dgbequ_c
      subroutine dgbequb_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__
     &, r, c_shape__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbequb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbequb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax,
     & info)
        fw_iserr__ = 0
      end subroutine dgbequb_c
      subroutine dgbrfs_c(trans, n, kl, ku, nrhs, ab_shape__, ab, ldab, 
     &afb_shape__, afb, ldafb, ipiv_shape__, ipiv, b_shape__, b, ldb, x_
     &shape__, x, ldx, ferr_shape__, ferr, berr_shape__, berr, work_shap
     &e__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0D0)), dimension(afb_shape__(1), afb_shape__(2)
     &) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbrfs(trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, 
     &b, ldb, x, ldx, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dgbrfs_c
      subroutine dgbrfsx_c(trans, equed, n, kl, ku, nrhs, ab_shape__, ab
     &, ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, r_shape__, r,
     & c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, berr_s
     &hape__, berr, n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, er
     &r_bnds_comp_shape__, err_bnds_comp, nparams, params_shape__, param
     &s, work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0D0)), dimension(afb_shape__(1), afb_shape__(2)
     &) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbrfsx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbrfsx(trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb
     &, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_no
     &rm, err_bnds_comp, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dgbrfsx_c
      subroutine dgbsv_c(n, kl, ku, nrhs, ab_shape__, ab, ldab, ipiv_sha
     &pe__, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbsv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbsv(n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dgbsv_c
      subroutine dgbsvx_c(fact, trans, n, kl, ku, nrhs, ab_shape__, ab, 
     &ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, equed, r_shape_
     &_, r, c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, f
     &err_shape__, ferr, berr_shape__, berr, work_shape__, work, iwork_s
     &hape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0D0)), dimension(afb_shape__(1), afb_shape__(2)
     &) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbsvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbsvx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, 
     &ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork,
     & info)
        fw_iserr__ = 0
      end subroutine dgbsvx_c
      subroutine dgbsvxx_c(fact, trans, n, kl, ku, nrhs, ab_shape__, ab,
     & ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, equed, r_shape
     &__, r, c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, 
     &rpvgrw, berr_shape__, berr, n_err_bnds, err_bnds_norm_shape__, err
     &_bnds_norm, err_bnds_comp_shape__, err_bnds_comp, nparams, params_
     &shape__, params, work_shape__, work, iwork_shape__, iwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0D0)), dimension(afb_shape__(1), afb_shape__(2)
     &) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        real(kind=kind(0.0D0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbsvxx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbsvxx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,
     & ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnd
     &s, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine dgbsvxx_c
      subroutine dgbtf2_c(m, n, kl, ku, ab_shape__, ab, ldab, ipiv_shape
     &__, ipiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbtf2
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbtf2(m, n, kl, ku, ab, ldab, ipiv, info)
        fw_iserr__ = 0
      end subroutine dgbtf2_c
      subroutine dgbtrf_c(m, n, kl, ku, ab_shape__, ab, ldab, ipiv_shape
     &__, ipiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbtrf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbtrf(m, n, kl, ku, ab, ldab, ipiv, info)
        fw_iserr__ = 0
      end subroutine dgbtrf_c
      subroutine dgbtrs_c(trans, n, kl, ku, nrhs, ab_shape__, ab, ldab, 
     &ipiv_shape__, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgbtrs(trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info
     &)
        fw_iserr__ = 0
      end subroutine dgbtrs_c
      subroutine dgebak_c(job, side, n, ilo, ihi, scale_shape__, scale, 
     &m, v_shape__, v, ldv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: side
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0D0)), dimension(scale_shape__(1)) :: scale
        integer :: m
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgebak
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgebak(job, side, n, ilo, ihi, scale, m, v, ldv, info)
        fw_iserr__ = 0
      end subroutine dgebak_c
      subroutine dgebal_c(job, n, a_shape__, a, lda, ilo, ihi, scale_sha
     &pe__, scale, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0D0)), dimension(scale_shape__(1)) :: scale
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgebal
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgebal(job, n, a, lda, ilo, ihi, scale, info)
        fw_iserr__ = 0
      end subroutine dgebal_c
      subroutine dgebd2_c(m, n, a_shape__, a, lda, d_shape__, d, e_shape
     &__, e, tauq_shape__, tauq, taup_shape__, taup, work_shape__, work,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        real(kind=kind(0.0D0)), dimension(tauq_shape__(1)) :: tauq
        integer, dimension(1) :: taup_shape__
        real(kind=kind(0.0D0)), dimension(taup_shape__(1)) :: taup
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgebd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgebd2(m, n, a, lda, d, e, tauq, taup, work, info)
        fw_iserr__ = 0
      end subroutine dgebd2_c
      subroutine dgebrd_c(m, n, a_shape__, a, lda, d_shape__, d, e_shape
     &__, e, tauq_shape__, tauq, taup_shape__, taup, work_shape__, work,
     & lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        real(kind=kind(0.0D0)), dimension(tauq_shape__(1)) :: tauq
        integer, dimension(1) :: taup_shape__
        real(kind=kind(0.0D0)), dimension(taup_shape__(1)) :: taup
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgebrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgebrd(m, n, a, lda, d, e, tauq, taup, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgebrd_c
      subroutine dgecon_c(norm, n, a_shape__, a, lda, anorm, rcond, work
     &_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgecon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgecon(norm, n, a, lda, anorm, rcond, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dgecon_c
      subroutine dgeequ_c(m, n, a_shape__, a, lda, r_shape__, r, c_shape
     &__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeequ
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeequ(m, n, a, lda, r, c, rowcnd, colcnd, amax, info)
        fw_iserr__ = 0
      end subroutine dgeequ_c
      subroutine dgeequb_c(m, n, a_shape__, a, lda, r_shape__, r, c_shap
     &e__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeequb(m, n, a, lda, r, c, rowcnd, colcnd, amax, info)
        fw_iserr__ = 0
      end subroutine dgeequb_c
      subroutine dgees_c(jobvs, sort, select, n, a_shape__, a, lda, sdim
     &, wr_shape__, wr, wi_shape__, wi, vs_shape__, vs, ldvs, work_shape
     &__, work, lwork, bwork_shape__, bwork, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvs
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: sdim
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0D0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0D0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: vs_shape__
        real(kind=kind(0.0D0)), dimension(vs_shape__(1), vs_shape__(2)) 
     &:: vs
        integer :: ldvs
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgees
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvs) .ne. (vs_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vs                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgees(jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldv
     &s, work, lwork, bwork, info)
        fw_iserr__ = 0
      end subroutine dgees_c
      subroutine dgeesx_c(jobvs, sort, select, sense, n, a_shape__, a, l
     &da, sdim, wr_shape__, wr, wi_shape__, wi, vs_shape__, vs, ldvs, rc
     &onde, rcondv, work_shape__, work, lwork, iwork_shape__, iwork, liw
     &ork, bwork_shape__, bwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvs
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: select
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: sdim
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0D0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0D0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: vs_shape__
        real(kind=kind(0.0D0)), dimension(vs_shape__(1), vs_shape__(2)) 
     &:: vs
        integer :: ldvs
        real(kind=kind(0.0D0)) :: rconde
        real(kind=kind(0.0D0)) :: rcondv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeesx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvs) .ne. (vs_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vs                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeesx(jobvs, sort, select, sense, n, a, lda, sdim, wr, wi,
     & vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork, info
     &)
        fw_iserr__ = 0
      end subroutine dgeesx_c
      subroutine dgeev_c(jobvl, jobvr, n, a_shape__, a, lda, wr_shape__,
     & wr, wi_shape__, wi, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, w
     &ork_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0D0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0D0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1), vl_shape__(2)) 
     &:: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1), vr_shape__(2)) 
     &:: vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeev(jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, 
     &work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgeev_c
      subroutine dgeevx_c(balanc, jobvl, jobvr, sense, n, a_shape__, a, 
     &lda, wr_shape__, wr, wi_shape__, wi, vl_shape__, vl, ldvl, vr_shap
     &e__, vr, ldvr, ilo, ihi, scale_shape__, scale, abnrm, rconde_shape
     &__, rconde, rcondv_shape__, rcondv, work_shape__, work, lwork, iwo
     &rk_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: balanc
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0D0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0D0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1), vl_shape__(2)) 
     &:: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1), vr_shape__(2)) 
     &:: vr
        integer :: ldvr
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0D0)), dimension(scale_shape__(1)) :: scale
        real(kind=kind(0.0D0)) :: abnrm
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0D0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0D0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeevx(balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, 
     &ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwor
     &k, iwork, info)
        fw_iserr__ = 0
      end subroutine dgeevx_c
      subroutine dgegs_c(jobvsl, jobvsr, n, a_shape__, a, lda, b_shape__
     &, b, ldb, alphar_shape__, alphar, alphai_shape__, alphai, beta_sha
     &pe__, beta, vsl_shape__, vsl, ldvsl, vsr_shape__, vsr, ldvsr, work
     &_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0D0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0D0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vsl_shape__
        real(kind=kind(0.0D0)), dimension(vsl_shape__(1), vsl_shape__(2)
     &) :: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        real(kind=kind(0.0D0)), dimension(vsr_shape__(1), vsr_shape__(2)
     &) :: vsr
        integer :: ldvsr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgegs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgegs(jobvsl, jobvsr, n, a, lda, b, ldb, alphar, alphai, be
     &ta, vsl, ldvsl, vsr, ldvsr, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgegs_c
      subroutine dgegv_c(jobvl, jobvr, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, alphar_shape__, alphar, alphai_shape__, alphai, beta_shape
     &__, beta, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, work_shape__
     &, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0D0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0D0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1), vl_shape__(2)) 
     &:: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1), vr_shape__(2)) 
     &:: vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgegv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgegv(jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta
     &, vl, ldvl, vr, ldvr, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgegv_c
      subroutine dgehd2_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgehd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgehd2(n, ilo, ihi, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine dgehd2_c
      subroutine dgehrd_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgehrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgehrd(n, ilo, ihi, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgehrd_c
      subroutine dgejsv_c(joba, jobu, jobv, jobr, jobt, jobp, m, n, a_sh
     &ape__, a, lda, sva_shape__, sva, u_shape__, u, ldu, v_shape__, v, 
     &ldv, work_shape__, work, lwork, iwork_shape__, iwork, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1) :: joba
        character(len=1) :: jobu
        character(len=1) :: jobv
        character(len=1) :: jobr
        character(len=1) :: jobt
        character(len=1) :: jobp
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: sva_shape__
        real(kind=kind(0.0D0)), dimension(sva_shape__(1)) :: sva
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgejsv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (sva_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sva                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lwork) .lt. 0 .or. (lwork) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgejsv(joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sv
     &a, u, ldu, v, ldv, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine dgejsv_c
      subroutine dgelq2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgelq2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgelq2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine dgelq2_c
      subroutine dgelqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgelqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgelqf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgelqf_c
      subroutine dgels_c(trans, m, n, nrhs, a_shape__, a, lda, b_shape__
     &, b, ldb, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgels
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgels(trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgels_c
      subroutine dgelsd_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, s_shape__, s, rcond, rank, work_shape__, work, lwork, iwork_sh
     &ape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgelsd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgelsd(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lw
     &ork, iwork, info)
        fw_iserr__ = 0
      end subroutine dgelsd_c
      subroutine dgelss_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, s_shape__, s, rcond, rank, work_shape__, work, lwork, info, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgelss
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgelss(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lw
     &ork, info)
        fw_iserr__ = 0
      end subroutine dgelss_c
      subroutine dgelsx_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, jpvt_shape__, jpvt, rcond, rank, work_shape__, work, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        real(kind=kind(0.0D0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgelsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgelsx(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work,
     & info)
        fw_iserr__ = 0
      end subroutine dgelsx_c
      subroutine dgelsy_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, jpvt_shape__, jpvt, rcond, rank, work_shape__, work, lwork, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        real(kind=kind(0.0D0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgelsy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgelsy(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work,
     & lwork, info)
        fw_iserr__ = 0
      end subroutine dgelsy_c
      subroutine dgeql2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeql2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeql2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine dgeql2_c
      subroutine dgeqlf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeqlf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeqlf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgeqlf_c
      subroutine dgeqp3_c(m, n, a_shape__, a, lda, jpvt_shape__, jpvt, t
     &au_shape__, tau, work_shape__, work, lwork, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeqp3
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeqp3(m, n, a, lda, jpvt, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgeqp3_c
      subroutine dgeqpf_c(m, n, a_shape__, a, lda, jpvt_shape__, jpvt, t
     &au_shape__, tau, work_shape__, work, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeqpf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeqpf(m, n, a, lda, jpvt, tau, work, info)
        fw_iserr__ = 0
      end subroutine dgeqpf_c
      subroutine dgeqr2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeqr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeqr2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine dgeqr2_c
      subroutine dgeqr2p_c(m, n, a_shape__, a, lda, tau_shape__, tau, wo
     &rk_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeqr2p
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeqr2p(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine dgeqr2p_c
      subroutine dgeqrf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeqrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeqrf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgeqrf_c
      subroutine dgeqrfp_c(m, n, a_shape__, a, lda, tau_shape__, tau, wo
     &rk_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgeqrfp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgeqrfp(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgeqrfp_c
      subroutine dgerfs_c(trans, n, nrhs, a_shape__, a, lda, af_shape__,
     & af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ld
     &x, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, iwo
     &rk_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgerfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgerfs(trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, l
     &dx, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dgerfs_c
      subroutine dgerfsx_c(trans, equed, n, nrhs, a_shape__, a, lda, af_
     &shape__, af, ldaf, ipiv_shape__, ipiv, r_shape__, r, c_shape__, c,
     & b_shape__, b, ldb, x_shape__, x, ldx, rcond, berr_shape__, berr, 
     &n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_sh
     &ape__, err_bnds_comp, nparams, params_shape__, params, work_shape_
     &_, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgerfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgerfsx(trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c
     &, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds
     &_comp, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dgerfsx_c
      subroutine dgerq2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgerq2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgerq2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine dgerq2_c
      subroutine dgerqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgerqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgerqf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgerqf_c
      subroutine dgesc2_c(n, a_shape__, a, lda, rhs_shape__, rhs, ipiv_s
     &hape__, ipiv, jpiv_shape__, jpiv, scale, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: rhs_shape__
        real(kind=kind(0.0D0)), dimension(rhs_shape__(1)) :: rhs
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        real(kind=kind(0.0D0)) :: scale
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgesc2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgesc2(n, a, lda, rhs, ipiv, jpiv, scale)
        fw_iserr__ = 0
      end subroutine dgesc2_c
      subroutine dgesdd_c(jobz, m, n, a_shape__, a, lda, s_shape__, s, u
     &_shape__, u, ldu, vt_shape__, vt, ldvt, work_shape__, work, lwork,
     & iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer :: ldvt
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgesdd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgesdd(jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork
     &, iwork, info)
        fw_iserr__ = 0
      end subroutine dgesdd_c
      subroutine dgesv_c(n, nrhs, a_shape__, a, lda, ipiv_shape__, ipiv,
     & b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgesv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgesv(n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dgesv_c
      subroutine dgesvd_c(jobu, jobvt, m, n, a_shape__, a, lda, s_shape_
     &_, s, u_shape__, u, ldu, vt_shape__, vt, ldvt, work_shape__, work,
     & lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobvt
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer :: ldvt
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgesvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work
     &, lwork, info)
        fw_iserr__ = 0
      end subroutine dgesvd_c
      subroutine dgesvj_c(joba, jobu, jobv, m, n, a_shape__, a, lda, sva
     &_shape__, sva, mv, v_shape__, v, ldv, work_shape__, work, lwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1) :: joba
        character(len=1) :: jobu
        character(len=1) :: jobv
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: sva_shape__
        real(kind=kind(0.0D0)), dimension(sva_shape__(1)) :: sva
        integer :: mv
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgesvj
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (sva_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sva                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lwork) .lt. 0 .or. (lwork) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgesvj(joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, wor
     &k, lwork, info)
        fw_iserr__ = 0
      end subroutine dgesvj_c
      subroutine dgesvx_c(fact, trans, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, ipiv_shape__, ipiv, equed, r_shape__, r, c_shape_
     &_, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, ferr_shape__, f
     &err, berr_shape__, berr, work_shape__, work, iwork_shape__, iwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgesvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgesvx(fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed,
     & r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dgesvx_c
      subroutine dgesvxx_c(fact, trans, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, ipiv_shape__, ipiv, equed, r_shape__, r, c_shape
     &__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, rpvgrw, berr_s
     &hape__, berr, n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, er
     &r_bnds_comp_shape__, err_bnds_comp, nparams, params_shape__, param
     &s, work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        real(kind=kind(0.0D0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgesvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgesvxx(fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed
     &, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_
     &norm, err_bnds_comp, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dgesvxx_c
      subroutine dgetc2_c(n, a_shape__, a, lda, ipiv_shape__, ipiv, jpiv
     &_shape__, jpiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgetc2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgetc2(n, a, lda, ipiv, jpiv, info)
        fw_iserr__ = 0
      end subroutine dgetc2_c
      subroutine dgetf2_c(m, n, a_shape__, a, lda, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgetf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgetf2(m, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine dgetf2_c
      subroutine dgetrf_c(m, n, a_shape__, a, lda, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgetrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgetrf(m, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine dgetrf_c
      subroutine dgetri_c(n, a_shape__, a, lda, ipiv_shape__, ipiv, work
     &_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgetri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgetri(n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgetri_c
      subroutine dgetrs_c(trans, n, nrhs, a_shape__, a, lda, ipiv_shape_
     &_, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgetrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dgetrs_c
      subroutine dggbak_c(job, side, n, ilo, ihi, lscale_shape__, lscale
     &, rscale_shape__, rscale, m, v_shape__, v, ldv, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: side
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0D0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0D0)), dimension(rscale_shape__(1)) :: rscale
        integer :: m
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dggbak
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dggbak(job, side, n, ilo, ihi, lscale, rscale, m, v, ldv, i
     &nfo)
        fw_iserr__ = 0
      end subroutine dggbak_c
      subroutine dggbal_c(job, n, a_shape__, a, lda, b_shape__, b, ldb, 
     &ilo, ihi, lscale_shape__, lscale, rscale_shape__, rscale, work_sha
     &pe__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0D0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0D0)), dimension(rscale_shape__(1)) :: rscale
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dggbal
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dggbal(job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, wo
     &rk, info)
        fw_iserr__ = 0
      end subroutine dggbal_c
      subroutine dgges_c(jobvsl, jobvsr, sort, selctg, n, a_shape__, a, 
     &lda, b_shape__, b, ldb, sdim, alphar_shape__, alphar, alphai_shape
     &__, alphai, beta_shape__, beta, vsl_shape__, vsl, ldvsl, vsr_shape
     &__, vsr, ldvsr, work_shape__, work, lwork, bwork_shape__, bwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: selctg
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: sdim
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0D0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0D0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vsl_shape__
        real(kind=kind(0.0D0)), dimension(vsl_shape__(1), vsl_shape__(2)
     &) :: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        real(kind=kind(0.0D0)), dimension(vsr_shape__(1), vsr_shape__(2)
     &) :: vsr
        integer :: ldvsr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgges
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgges(jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim
     &, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork
     &, info)
        fw_iserr__ = 0
      end subroutine dgges_c
      subroutine dggesx_c(jobvsl, jobvsr, sort, selctg, sense, n, a_shap
     &e__, a, lda, b_shape__, b, ldb, sdim, alphar_shape__, alphar, alph
     &ai_shape__, alphai, beta_shape__, beta, vsl_shape__, vsl, ldvsl, v
     &sr_shape__, vsr, ldvsr, rconde_shape__, rconde, rcondv_shape__, rc
     &ondv, work_shape__, work, lwork, iwork_shape__, iwork, liwork, bwo
     &rk_shape__, bwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: selctg
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: sdim
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0D0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0D0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vsl_shape__
        real(kind=kind(0.0D0)), dimension(vsl_shape__(1), vsl_shape__(2)
     &) :: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        real(kind=kind(0.0D0)), dimension(vsr_shape__(1), vsr_shape__(2)
     &) :: vsr
        integer :: ldvsr
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0D0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0D0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dggesx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (rconde_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("rconde                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (rcondv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("rcondv                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dggesx(jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, l
     &db, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rc
     &ondv, work, lwork, iwork, liwork, bwork, info)
        fw_iserr__ = 0
      end subroutine dggesx_c
      subroutine dggev_c(jobvl, jobvr, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, alphar_shape__, alphar, alphai_shape__, alphai, beta_shape
     &__, beta, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, work_shape__
     &, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0D0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0D0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1), vl_shape__(2)) 
     &:: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1), vr_shape__(2)) 
     &:: vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dggev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dggev(jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta
     &, vl, ldvl, vr, ldvr, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dggev_c
      subroutine dggevx_c(balanc, jobvl, jobvr, sense, n, a_shape__, a, 
     &lda, b_shape__, b, ldb, alphar_shape__, alphar, alphai_shape__, al
     &phai, beta_shape__, beta, vl_shape__, vl, ldvl, vr_shape__, vr, ld
     &vr, ilo, ihi, lscale_shape__, lscale, rscale_shape__, rscale, abnr
     &m, bbnrm, rconde_shape__, rconde, rcondv_shape__, rcondv, work_sha
     &pe__, work, lwork, iwork_shape__, iwork, bwork_shape__, bwork, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: balanc
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0D0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0D0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1), vl_shape__(2)) 
     &:: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1), vr_shape__(2)) 
     &:: vr
        integer :: ldvr
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0D0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0D0)), dimension(rscale_shape__(1)) :: rscale
        real(kind=kind(0.0D0)) :: abnrm
        real(kind=kind(0.0D0)) :: bbnrm
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0D0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0D0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dggevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dggevx(balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alph
     &ar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, ab
     &nrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork, info)
        fw_iserr__ = 0
      end subroutine dggevx_c
      subroutine dggglm_c(n, m, p, a_shape__, a, lda, b_shape__, b, ldb,
     & d_shape__, d, x_shape__, x, y_shape__, y, work_shape__, work, lwo
     &rk, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: m
        integer :: p
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dggglm
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dggglm(n, m, p, a, lda, b, ldb, d, x, y, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dggglm_c
      subroutine dgghrd_c(compq, compz, n, ilo, ihi, a_shape__, a, lda, 
     &b_shape__, b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compq
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgghrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgghrd(compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z
     &, ldz, info)
        fw_iserr__ = 0
      end subroutine dgghrd_c
      subroutine dgglse_c(m, n, p, a_shape__, a, lda, b_shape__, b, ldb,
     & c_shape__, c, d_shape__, d, x_shape__, x, work_shape__, work, lwo
     &rk, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: p
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgglse
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgglse(m, n, p, a, lda, b, ldb, c, d, x, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgglse_c
      subroutine dggqrf_c(n, m, p, a_shape__, a, lda, taua_shape__, taua
     &, b_shape__, b, ldb, taub_shape__, taub, work_shape__, work, lwork
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: m
        integer :: p
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: taua_shape__
        real(kind=kind(0.0D0)), dimension(taua_shape__(1)) :: taua
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: taub_shape__
        real(kind=kind(0.0D0)), dimension(taub_shape__(1)) :: taub
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dggqrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dggqrf(n, m, p, a, lda, taua, b, ldb, taub, work, lwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine dggqrf_c
      subroutine dggrqf_c(m, p, n, a_shape__, a, lda, taua_shape__, taua
     &, b_shape__, b, ldb, taub_shape__, taub, work_shape__, work, lwork
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: p
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: taua_shape__
        real(kind=kind(0.0D0)), dimension(taua_shape__(1)) :: taua
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: taub_shape__
        real(kind=kind(0.0D0)), dimension(taub_shape__(1)) :: taub
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dggrqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dggrqf(m, p, n, a, lda, taua, b, ldb, taub, work, lwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine dggrqf_c
      subroutine dggsvd_c(jobu, jobv, jobq, m, n, p, k, l, a_shape__, a,
     & lda, b_shape__, b, ldb, alpha_shape__, alpha, beta_shape__, beta,
     & u_shape__, u, ldu, v_shape__, v, ldv, q_shape__, q, ldq, work_sha
     &pe__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: n
        integer :: p
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        real(kind=kind(0.0D0)), dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dggsvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dggsvd(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alp
     &ha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dggsvd_c
      subroutine dggsvp_c(jobu, jobv, jobq, m, p, n, a_shape__, a, lda, 
     &b_shape__, b, ldb, tola, tolb, k, l, u_shape__, u, ldu, v_shape__,
     & v, ldv, q_shape__, q, ldq, iwork_shape__, iwork, tau_shape__, tau
     &, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: p
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        real(kind=kind(0.0D0)) :: tola
        real(kind=kind(0.0D0)) :: tolb
        integer :: k
        integer :: l
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dggsvp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dggsvp(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tol
     &b, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info)
        fw_iserr__ = 0
      end subroutine dggsvp_c
      subroutine dgsvj0_c(jobv, m, n, a_shape__, a, lda, d_shape__, d, s
     &va_shape__, sva, mv, v_shape__, v, ldv, eps, sfmin, tol, nsweep, w
     &ork_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1) :: jobv
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: sva_shape__
        real(kind=kind(0.0D0)), dimension(sva_shape__(1)) :: sva
        integer :: mv
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        real(kind=kind(0.0D0)) :: eps
        real(kind=kind(0.0D0)) :: sfmin
        real(kind=kind(0.0D0)) :: tol
        integer :: nsweep
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgsvj0
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (sva_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sva                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lwork) .lt. 0 .or. (lwork) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgsvj0(jobv, m, n, a, lda, d, sva, mv, v, ldv, eps, sfmin, 
     &tol, nsweep, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgsvj0_c
      subroutine dgsvj1_c(jobv, m, n, n1, a_shape__, a, lda, d_shape__, 
     &d, sva_shape__, sva, mv, v_shape__, v, ldv, eps, sfmin, tol, nswee
     &p, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1) :: jobv
        integer :: m
        integer :: n
        integer :: n1
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: sva_shape__
        real(kind=kind(0.0D0)), dimension(sva_shape__(1)) :: sva
        integer :: mv
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        real(kind=kind(0.0D0)) :: eps
        real(kind=kind(0.0D0)) :: sfmin
        real(kind=kind(0.0D0)) :: tol
        integer :: nsweep
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgsvj1
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (sva_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sva                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lwork) .lt. 0 .or. (lwork) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgsvj1(jobv, m, n, n1, a, lda, d, sva, mv, v, ldv, eps, sfm
     &in, tol, nsweep, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dgsvj1_c
      subroutine dgtcon_c(norm, n, dl_shape__, dl, d_shape__, d, du_shap
     &e__, du, du2_shape__, du2, ipiv_shape__, ipiv, anorm, rcond, work_
     &shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0D0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0D0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0D0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgtcon
        fw_iserr__ = -1
        call dgtcon(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, i
     &work, info)
        fw_iserr__ = 0
      end subroutine dgtcon_c
      subroutine dgtrfs_c(trans, n, nrhs, dl_shape__, dl, d_shape__, d, 
     &du_shape__, du, dlf_shape__, dlf, df_shape__, df, duf_shape__, duf
     &, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape
     &__, x, ldx, ferr_shape__, ferr, berr_shape__, berr, work_shape__, 
     &work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0D0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0D0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: dlf_shape__
        real(kind=kind(0.0D0)), dimension(dlf_shape__(1)) :: dlf
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0D0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: duf_shape__
        real(kind=kind(0.0D0)), dimension(duf_shape__(1)) :: duf
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0D0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgtrfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgtrfs(trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, 
     &b, ldb, x, ldx, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dgtrfs_c
      subroutine dgtsv_c(n, nrhs, dl_shape__, dl, d_shape__, d, du_shape
     &__, du, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0D0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0D0)), dimension(du_shape__(1)) :: du
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgtsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgtsv(n, nrhs, dl, d, du, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dgtsv_c
      subroutine dgtsvx_c(fact, trans, n, nrhs, dl_shape__, dl, d_shape_
     &_, d, du_shape__, du, dlf_shape__, dlf, df_shape__, df, duf_shape_
     &_, duf, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b, ldb, x
     &_shape__, x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, w
     &ork_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0D0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0D0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: dlf_shape__
        real(kind=kind(0.0D0)), dimension(dlf_shape__(1)) :: dlf
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0D0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: duf_shape__
        real(kind=kind(0.0D0)), dimension(duf_shape__(1)) :: duf
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0D0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgtsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgtsvx(fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, 
     &ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dgtsvx_c
      subroutine dgttrf_c(n, dl_shape__, dl, d_shape__, d, du_shape__, d
     &u, du2_shape__, du2, ipiv_shape__, ipiv, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0D0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0D0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0D0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgttrf
        fw_iserr__ = -1
        call dgttrf(n, dl, d, du, du2, ipiv, info)
        fw_iserr__ = 0
      end subroutine dgttrf_c
      subroutine dgttrs_c(trans, n, nrhs, dl_shape__, dl, d_shape__, d, 
     &du_shape__, du, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b
     &, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0D0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0D0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0D0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgttrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dgttrs_c
      subroutine dgtts2_c(itrans, n, nrhs, dl_shape__, dl, d_shape__, d,
     & du_shape__, du, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, 
     &b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itrans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0D0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0D0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0D0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dgtts2
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dgtts2(itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb)
        fw_iserr__ = 0
      end subroutine dgtts2_c
      subroutine dhgeqz_c(job, compq, compz, n, ilo, ihi, h_shape__, h, 
     &ldh, t_shape__, t, ldt, alphar_shape__, alphar, alphai_shape__, al
     &phai, beta_shape__, beta, q_shape__, q, ldq, z_shape__, z, ldz, wo
     &rk_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compq
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0D0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0D0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dhgeqz
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dhgeqz(job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alph
     &ar, alphai, beta, q, ldq, z, ldz, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dhgeqz_c
      subroutine dhsein_c(side, eigsrc, initv, select_shape__, select, n
     &, h_shape__, h, ldh, wr_shape__, wr, wi_shape__, wi, vl_shape__, v
     &l, ldvl, vr_shape__, vr, ldvr, mm, m, work_shape__, work, ifaill_s
     &hape__, ifaill, ifailr_shape__, ifailr, info, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: eigsrc
        character(len=1, kind=kind('a')) :: initv
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0D0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0D0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1), vl_shape__(2)) 
     &:: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1), vr_shape__(2)) 
     &:: vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: ifaill_shape__
        integer, dimension(ifaill_shape__(1)) :: ifaill
        integer, dimension(1) :: ifailr_shape__
        integer, dimension(ifailr_shape__(1)) :: ifailr
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dhsein
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dhsein(side, eigsrc, initv, select, n, h, ldh, wr, wi, vl, 
     &ldvl, vr, ldvr, mm, m, work, ifaill, ifailr, info)
        fw_iserr__ = 0
      end subroutine dhsein_c
      subroutine dhseqr_c(job, compz, n, ilo, ihi, h_shape__, h, ldh, wr
     &_shape__, wr, wi_shape__, wi, z_shape__, z, ldz, work_shape__, wor
     &k, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0D0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0D0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dhseqr
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dhseqr(job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, wor
     &k, lwork, info)
        fw_iserr__ = 0
      end subroutine dhseqr_c
      subroutine disnan_c(fw_ret_arg, din, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: fw_ret_arg
        real(kind=kind(0.0D0)) :: din
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer(kind=kind(0)) :: disnan
        external disnan
        fw_iserr__ = -1
        fw_ret_arg = disnan(din)
        fw_iserr__ = 0
      end subroutine disnan_c
      subroutine dla_gbamv_c(trans, m, n, kl, ku, alpha, ab_shape__, ab,
     & ldab, x_shape__, x, incx, beta, y_shape__, y, incy, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: trans
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dla_gbamv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dla_gbamv(trans, m, n, kl, ku, alpha, ab, ldab, x, incx, be
     &ta, y, incy)
        fw_iserr__ = 0
      end subroutine dla_gbamv_c
      subroutine dla_gbrcond_c(fw_ret_arg, trans, n, kl, ku, ab_shape__,
     & ab, ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, cmode, c_s
     &hape__, c, info, work_shape__, work, iwork_shape__, iwork, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0D0)), dimension(afb_shape__(1), afb_shape__(2)
     &) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: cmode
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer :: info
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dla_gbrcond
        external dla_gbrcond
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dla_gbrcond(trans, n, kl, ku, ab, ldab, afb, ldafb,
     & ipiv, cmode, c, info, work, iwork)
        fw_iserr__ = 0
      end subroutine dla_gbrcond_c
      subroutine dla_gbrfsx_extended_c(prec_type, trans_type, n, kl, ku,
     & nrhs, ab_shape__, ab, ldab, afb_shape__, afb, ldafb, ipiv_shape__
     &, ipiv, colequ, c_shape__, c, b_shape__, b, ldb, y_shape__, y, ldy
     &, berr_out_shape__, berr_out, n_norms, err_bnds_norm_shape__, err_
     &bnds_norm, err_bnds_comp_shape__, err_bnds_comp, res_shape__, res,
     & ayb_shape__, ayb, dy_shape__, dy, y_tail_shape__, y_tail, rcond, 
     &ithresh, rthresh, dz_ub, ignore_cwise, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        integer :: trans_type
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0D0)), dimension(afb_shape__(1), afb_shape__(2)
     &) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1), y_shape__(2)) ::
     & y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0D0)), dimension(berr_out_shape__(1)) :: berr_o
     &ut
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        real(kind=kind(0.0D0)), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        real(kind=kind(0.0D0)), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        real(kind=kind(0.0D0)), dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0D0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0D0)) :: rthresh
        real(kind=kind(0.0D0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dla_gbrfsx_extended
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dla_gbrfsx_extended(prec_type, trans_type, n, kl, ku, nrhs,
     & ab, ldab, afb, ldafb, ipiv, colequ, c, b, ldb, y, ldy, berr_out, 
     &n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond
     &, ithresh, rthresh, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine dla_gbrfsx_extended_c
      subroutine dla_gbrpvgrw_c(fw_ret_arg, n, kl, ku, ncols, ab_shape__
     &, ab, ldab, afb_shape__, afb, ldafb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        integer :: n
        integer :: kl
        integer :: ku
        integer :: ncols
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0D0)), dimension(afb_shape__(1), afb_shape__(2)
     &) :: afb
        integer :: ldafb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dla_gbrpvgrw
        external dla_gbrpvgrw
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dla_gbrpvgrw(n, kl, ku, ncols, ab, ldab, afb, ldafb
     &)
        fw_iserr__ = 0
      end subroutine dla_gbrpvgrw_c
      subroutine dla_geamv_c(trans, m, n, alpha, a_shape__, a, lda, x_sh
     &ape__, x, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: trans
        integer :: m
        integer :: n
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dla_geamv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dla_geamv(trans, m, n, alpha, a, lda, x, incx, beta, y, inc
     &y)
        fw_iserr__ = 0
      end subroutine dla_geamv_c
      subroutine dla_gercond_c(fw_ret_arg, trans, n, a_shape__, a, lda, 
     &af_shape__, af, ldaf, ipiv_shape__, ipiv, cmode, c_shape__, c, inf
     &o, work_shape__, work, iwork_shape__, iwork, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: cmode
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer :: info
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dla_gercond
        external dla_gercond
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dla_gercond(trans, n, a, lda, af, ldaf, ipiv, cmode
     &, c, info, work, iwork)
        fw_iserr__ = 0
      end subroutine dla_gercond_c
      subroutine dla_gerfsx_extended_c(prec_type, trans_type, n, nrhs, a
     &_shape__, a, lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, colequ
     &, c_shape__, c, b_shape__, b, ldb, y_shape__, y, ldy, berr_out_sha
     &pe__, berr_out, n_norms, errs_n_shape__, errs_n, errs_c_shape__, e
     &rrs_c, res_shape__, res, ayb_shape__, ayb, dy_shape__, dy, y_tail_
     &shape__, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        integer :: trans_type
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1), y_shape__(2)) ::
     & y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0D0)), dimension(berr_out_shape__(1)) :: berr_o
     &ut
        integer :: n_norms
        integer, dimension(2) :: errs_n_shape__
        real(kind=kind(0.0D0)), dimension(errs_n_shape__(1), errs_n_shap
     &e__(2)) :: errs_n
        integer, dimension(2) :: errs_c_shape__
        real(kind=kind(0.0D0)), dimension(errs_c_shape__(1), errs_c_shap
     &e__(2)) :: errs_c
        integer, dimension(1) :: res_shape__
        real(kind=kind(0.0D0)), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        real(kind=kind(0.0D0)), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        real(kind=kind(0.0D0)), dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0D0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0D0)) :: rthresh
        real(kind=kind(0.0D0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dla_gerfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (errs_n_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("errs_n                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (errs_c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("errs_c                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dla_gerfsx_extended(prec_type, trans_type, n, nrhs, a, lda,
     & af, ldaf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err
     &s_n, errs_c, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub,
     & ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine dla_gerfsx_extended_c
      subroutine dla_lin_berr_c(n, nz, nrhs, res_shape__, res, ayb_shape
     &__, ayb, berr_shape__, berr, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nz
        integer :: nrhs
        integer, dimension(2) :: res_shape__
        real(kind=kind(0.0D0)), dimension(res_shape__(1), res_shape__(2)
     &) :: res
        integer, dimension(2) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1), ayb_shape__(2)
     &) :: ayb
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dla_lin_berr
        fw_iserr__ = -1
        if ((n) .ne. (res_shape__(1)) .or. (nrhs) .lt. 0 .or. (nrhs) .gt
     &. (res_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("res                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .ne. (ayb_shape__(1)) .or. (nrhs) .lt. 0 .or. (nrhs) .gt
     &. (ayb_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ayb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .lt. 0 .or. (nrhs) .gt. (berr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("berr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dla_lin_berr(n, nz, nrhs, res, ayb, berr)
        fw_iserr__ = 0
      end subroutine dla_lin_berr_c
      subroutine dla_porcond_c(fw_ret_arg, uplo, n, a_shape__, a, lda, a
     &f_shape__, af, ldaf, cmode, c_shape__, c, info, work_shape__, work
     &, iwork_shape__, iwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer :: cmode
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer :: info
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dla_porcond
        external dla_porcond
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dla_porcond(uplo, n, a, lda, af, ldaf, cmode, c, in
     &fo, work, iwork)
        fw_iserr__ = 0
      end subroutine dla_porcond_c
      subroutine dla_porfsx_extended_c(prec_type, uplo, n, nrhs, a_shape
     &__, a, lda, af_shape__, af, ldaf, colequ, c_shape__, c, b_shape__,
     & b, ldb, y_shape__, y, ldy, berr_out_shape__, berr_out, n_norms, e
     &rr_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bn
     &ds_comp, res_shape__, res, ayb_shape__, ayb, dy_shape__, dy, y_tai
     &l_shape__, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1), y_shape__(2)) ::
     & y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0D0)), dimension(berr_out_shape__(1)) :: berr_o
     &ut
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        real(kind=kind(0.0D0)), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        real(kind=kind(0.0D0)), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        real(kind=kind(0.0D0)), dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0D0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0D0)) :: rthresh
        real(kind=kind(0.0D0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dla_porfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dla_porfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, l
     &daf, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, 
     &err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_u
     &b, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine dla_porfsx_extended_c
      subroutine dla_porpvgrw_c(fw_ret_arg, uplo, ncols, a_shape__, a, l
     &da, af_shape__, af, ldaf, work_shape__, work, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1) :: uplo
        integer :: ncols
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dla_porpvgrw
        external dla_porpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dla_porpvgrw(uplo, ncols, a, lda, af, ldaf, work)
        fw_iserr__ = 0
      end subroutine dla_porpvgrw_c
      subroutine dla_rpvgrw_c(fw_ret_arg, n, ncols, a_shape__, a, lda, a
     &f_shape__, af, ldaf, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        integer :: n
        integer :: ncols
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dla_rpvgrw
        external dla_rpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dla_rpvgrw(n, ncols, a, lda, af, ldaf)
        fw_iserr__ = 0
      end subroutine dla_rpvgrw_c
      subroutine dla_syamv_c(uplo, n, alpha, a_shape__, a, lda, x_shape_
     &_, x, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: uplo
        integer :: n
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dla_syamv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dla_syamv(uplo, n, alpha, a, lda, x, incx, beta, y, incy)
        fw_iserr__ = 0
      end subroutine dla_syamv_c
      subroutine dla_syrcond_c(fw_ret_arg, uplo, n, a_shape__, a, lda, a
     &f_shape__, af, ldaf, ipiv_shape__, ipiv, cmode, c_shape__, c, info
     &, work_shape__, work, iwork_shape__, iwork, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: cmode
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer :: info
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dla_syrcond
        external dla_syrcond
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dla_syrcond(uplo, n, a, lda, af, ldaf, ipiv, cmode,
     & c, info, work, iwork)
        fw_iserr__ = 0
      end subroutine dla_syrcond_c
      subroutine dla_syrfsx_extended_c(prec_type, uplo, n, nrhs, a_shape
     &__, a, lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, colequ, c_sh
     &ape__, c, b_shape__, b, ldb, y_shape__, y, ldy, berr_out_shape__, 
     &berr_out, n_norms, err_bnds_norm_shape__, err_bnds_norm, err_bnds_
     &comp_shape__, err_bnds_comp, res_shape__, res, ayb_shape__, ayb, d
     &y_shape__, dy, y_tail_shape__, y_tail, rcond, ithresh, rthresh, dz
     &_ub, ignore_cwise, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1), y_shape__(2)) ::
     & y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0D0)), dimension(berr_out_shape__(1)) :: berr_o
     &ut
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        real(kind=kind(0.0D0)), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        real(kind=kind(0.0D0)), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        real(kind=kind(0.0D0)), dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0D0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0D0)) :: rthresh
        real(kind=kind(0.0D0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dla_syrfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dla_syrfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, l
     &daf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_
     &norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh
     &, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine dla_syrfsx_extended_c
      subroutine dla_syrpvgrw_c(fw_ret_arg, uplo, n, info, a_shape__, a,
     & lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, work_shape__, work
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1) :: uplo
        integer :: n
        integer :: info
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dla_syrpvgrw
        external dla_syrpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dla_syrpvgrw(uplo, n, info, a, lda, af, ldaf, ipiv,
     & work)
        fw_iserr__ = 0
      end subroutine dla_syrpvgrw_c
      subroutine dla_wwaddw_c(n, x_shape__, x, y_shape__, y, w_shape__, 
     &w, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dla_wwaddw
        fw_iserr__ = -1
        call dla_wwaddw(n, x, y, w)
        fw_iserr__ = 0
      end subroutine dla_wwaddw_c
      subroutine dlabad_c(small, large, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: small
        real(kind=kind(0.0D0)) :: large
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlabad
        fw_iserr__ = -1
        call dlabad(small, large)
        fw_iserr__ = 0
      end subroutine dlabad_c
      subroutine dlabrd_c(m, n, nb, a_shape__, a, lda, d_shape__, d, e_s
     &hape__, e, tauq_shape__, tauq, taup_shape__, taup, x_shape__, x, l
     &dx, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        real(kind=kind(0.0D0)), dimension(tauq_shape__(1)) :: tauq
        integer, dimension(1) :: taup_shape__
        real(kind=kind(0.0D0)), dimension(taup_shape__(1)) :: taup
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1), y_shape__(2)) ::
     & y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlabrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlabrd(m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y, ldy)
        fw_iserr__ = 0
      end subroutine dlabrd_c
      subroutine dlacn2_c(n, v_shape__, v, x_shape__, x, isgn_shape__, i
     &sgn, est, kase, isave_shape__, isave, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1)) :: v
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: isgn_shape__
        integer, dimension(isgn_shape__(1)) :: isgn
        real(kind=kind(0.0D0)) :: est
        integer :: kase
        integer, dimension(1) :: isave_shape__
        integer, dimension(isave_shape__(1)) :: isave
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlacn2
        fw_iserr__ = -1
        if ((3) .lt. 0 .or. (3) .gt. (isave_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("isave                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlacn2(n, v, x, isgn, est, kase, isave)
        fw_iserr__ = 0
      end subroutine dlacn2_c
      subroutine dlacon_c(n, v_shape__, v, x_shape__, x, isgn_shape__, i
     &sgn, est, kase, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1)) :: v
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: isgn_shape__
        integer, dimension(isgn_shape__(1)) :: isgn
        real(kind=kind(0.0D0)) :: est
        integer :: kase
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlacon
        fw_iserr__ = -1
        call dlacon(n, v, x, isgn, est, kase)
        fw_iserr__ = 0
      end subroutine dlacon_c
      subroutine dlacpy_c(uplo, m, n, a_shape__, a, lda, b_shape__, b, l
     &db, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlacpy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlacpy(uplo, m, n, a, lda, b, ldb)
        fw_iserr__ = 0
      end subroutine dlacpy_c
      subroutine dladiv_c(a, b, c, d, p, q, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: a
        real(kind=kind(0.0D0)) :: b
        real(kind=kind(0.0D0)) :: c
        real(kind=kind(0.0D0)) :: d
        real(kind=kind(0.0D0)) :: p
        real(kind=kind(0.0D0)) :: q
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dladiv
        fw_iserr__ = -1
        call dladiv(a, b, c, d, p, q)
        fw_iserr__ = 0
      end subroutine dladiv_c
      subroutine dlae2_c(a, b, c, rt1, rt2, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: a
        real(kind=kind(0.0D0)) :: b
        real(kind=kind(0.0D0)) :: c
        real(kind=kind(0.0D0)) :: rt1
        real(kind=kind(0.0D0)) :: rt2
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlae2
        fw_iserr__ = -1
        call dlae2(a, b, c, rt1, rt2)
        fw_iserr__ = 0
      end subroutine dlae2_c
      subroutine dlaebz_c(ijob, nitmax, n, mmax, minp, nbmin, abstol, re
     &ltol, pivmin, d_shape__, d, e_shape__, e, e2_shape__, e2, nval_sha
     &pe__, nval, ab_shape__, ab, c_shape__, c, mout, nab_shape__, nab, 
     &work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: ijob
        integer :: nitmax
        integer :: n
        integer :: mmax
        integer :: minp
        integer :: nbmin
        real(kind=kind(0.0D0)) :: abstol
        real(kind=kind(0.0D0)) :: reltol
        real(kind=kind(0.0D0)) :: pivmin
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0D0)), dimension(e2_shape__(1)) :: e2
        integer, dimension(1) :: nval_shape__
        integer, dimension(nval_shape__(1)) :: nval
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer :: mout
        integer, dimension(2) :: nab_shape__
        integer, dimension(nab_shape__(1), nab_shape__(2)) :: nab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaebz
        fw_iserr__ = -1
        if ((mmax) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((mmax) .ne. (nab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("nab                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaebz(ijob, nitmax, n, mmax, minp, nbmin, abstol, reltol, 
     &pivmin, d, e, e2, nval, ab, c, mout, nab, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dlaebz_c
      subroutine dlaed0_c(icompq, qsiz, n, d_shape__, d, e_shape__, e, q
     &_shape__, q, ldq, qstore_shape__, qstore, ldqs, work_shape__, work
     &, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: qsiz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(2) :: qstore_shape__
        real(kind=kind(0.0D0)), dimension(qstore_shape__(1), qstore_shap
     &e__(2)) :: qstore
        integer :: ldqs
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaed0
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldqs) .ne. (qstore_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("qstore                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaed0(icompq, qsiz, n, d, e, q, ldq, qstore, ldqs, work, i
     &work, info)
        fw_iserr__ = 0
      end subroutine dlaed0_c
      subroutine dlaed1_c(n, d_shape__, d, q_shape__, q, ldq, indxq_shap
     &e__, indxq, rho, cutpnt, work_shape__, work, iwork_shape__, iwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        real(kind=kind(0.0D0)) :: rho
        integer :: cutpnt
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaed1
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaed1(n, d, q, ldq, indxq, rho, cutpnt, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dlaed1_c
      subroutine dlaed2_c(k, n, n1, d_shape__, d, q_shape__, q, ldq, ind
     &xq_shape__, indxq, rho, z_shape__, z, dlamda_shape__, dlamda, w_sh
     &ape__, w, q2_shape__, q2, indx_shape__, indx, indxc_shape__, indxc
     &, indxp_shape__, indxp, coltyp_shape__, coltyp, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: k
        integer :: n
        integer :: n1
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        real(kind=kind(0.0D0)) :: rho
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: dlamda_shape__
        real(kind=kind(0.0D0)), dimension(dlamda_shape__(1)) :: dlamda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: q2_shape__
        real(kind=kind(0.0D0)), dimension(q2_shape__(1)) :: q2
        integer, dimension(1) :: indx_shape__
        integer, dimension(indx_shape__(1)) :: indx
        integer, dimension(1) :: indxc_shape__
        integer, dimension(indxc_shape__(1)) :: indxc
        integer, dimension(1) :: indxp_shape__
        integer, dimension(indxp_shape__(1)) :: indxp
        integer, dimension(1) :: coltyp_shape__
        integer, dimension(coltyp_shape__(1)) :: coltyp
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaed2
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaed2(k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w, q2, i
     &ndx, indxc, indxp, coltyp, info)
        fw_iserr__ = 0
      end subroutine dlaed2_c
      subroutine dlaed3_c(k, n, n1, d_shape__, d, q_shape__, q, ldq, rho
     &, dlamda_shape__, dlamda, q2_shape__, q2, indx_shape__, indx, ctot
     &_shape__, ctot, w_shape__, w, s_shape__, s, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: k
        integer :: n
        integer :: n1
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        real(kind=kind(0.0D0)) :: rho
        integer, dimension(1) :: dlamda_shape__
        real(kind=kind(0.0D0)), dimension(dlamda_shape__(1)) :: dlamda
        integer, dimension(1) :: q2_shape__
        real(kind=kind(0.0D0)), dimension(q2_shape__(1)) :: q2
        integer, dimension(1) :: indx_shape__
        integer, dimension(indx_shape__(1)) :: indx
        integer, dimension(1) :: ctot_shape__
        integer, dimension(ctot_shape__(1)) :: ctot
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaed3
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaed3(k, n, n1, d, q, ldq, rho, dlamda, q2, indx, ctot, w,
     & s, info)
        fw_iserr__ = 0
      end subroutine dlaed3_c
      subroutine dlaed4_c(n, i, d_shape__, d, z_shape__, z, delta_shape_
     &_, delta, rho, dlam, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: i
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: delta_shape__
        real(kind=kind(0.0D0)), dimension(delta_shape__(1)) :: delta
        real(kind=kind(0.0D0)) :: rho
        real(kind=kind(0.0D0)) :: dlam
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaed4
        fw_iserr__ = -1
        call dlaed4(n, i, d, z, delta, rho, dlam, info)
        fw_iserr__ = 0
      end subroutine dlaed4_c
      subroutine dlaed5_c(i, d_shape__, d, z_shape__, z, delta_shape__, 
     &delta, rho, dlam, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: delta_shape__
        real(kind=kind(0.0D0)), dimension(delta_shape__(1)) :: delta
        real(kind=kind(0.0D0)) :: rho
        real(kind=kind(0.0D0)) :: dlam
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaed5
        fw_iserr__ = -1
        if ((2) .lt. 0 .or. (2) .gt. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (delta_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("delta                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaed5(i, d, z, delta, rho, dlam)
        fw_iserr__ = 0
      end subroutine dlaed5_c
      subroutine dlaed6_c(kniter, orgati, rho, d_shape__, d, z_shape__, 
     &z, finit, tau, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: kniter
        integer(kind=kind(0)) :: orgati
        real(kind=kind(0.0D0)) :: rho
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        real(kind=kind(0.0D0)) :: finit
        real(kind=kind(0.0D0)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaed6
        fw_iserr__ = -1
        if ((3) .lt. 0 .or. (3) .gt. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((3) .lt. 0 .or. (3) .gt. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaed6(kniter, orgati, rho, d, z, finit, tau, info)
        fw_iserr__ = 0
      end subroutine dlaed6_c
      subroutine dlaed7_c(icompq, n, qsiz, tlvls, curlvl, curpbm, d_shap
     &e__, d, q_shape__, q, ldq, indxq_shape__, indxq, rho, cutpnt, qsto
     &re_shape__, qstore, qptr_shape__, qptr, prmptr_shape__, prmptr, pe
     &rm_shape__, perm, givptr_shape__, givptr, givcol_shape__, givcol, 
     &givnum_shape__, givnum, work_shape__, work, iwork_shape__, iwork, 
     &info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: n
        integer :: qsiz
        integer :: tlvls
        integer :: curlvl
        integer :: curpbm
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        real(kind=kind(0.0D0)) :: rho
        integer :: cutpnt
        integer, dimension(1) :: qstore_shape__
        real(kind=kind(0.0D0)), dimension(qstore_shape__(1)) :: qstore
        integer, dimension(1) :: qptr_shape__
        integer, dimension(qptr_shape__(1)) :: qptr
        integer, dimension(1) :: prmptr_shape__
        integer, dimension(prmptr_shape__(1)) :: prmptr
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaed7
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaed7(icompq, n, qsiz, tlvls, curlvl, curpbm, d, q, ldq, i
     &ndxq, rho, cutpnt, qstore, qptr, prmptr, perm, givptr, givcol, giv
     &num, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dlaed7_c
      subroutine dlaed8_c(icompq, k, n, qsiz, d_shape__, d, q_shape__, q
     &, ldq, indxq_shape__, indxq, rho, cutpnt, z_shape__, z, dlamda_sha
     &pe__, dlamda, q2_shape__, q2, ldq2, w_shape__, w, perm_shape__, pe
     &rm, givptr, givcol_shape__, givcol, givnum_shape__, givnum, indxp_
     &shape__, indxp, indx_shape__, indx, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: k
        integer :: n
        integer :: qsiz
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        real(kind=kind(0.0D0)) :: rho
        integer :: cutpnt
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: dlamda_shape__
        real(kind=kind(0.0D0)), dimension(dlamda_shape__(1)) :: dlamda
        integer, dimension(2) :: q2_shape__
        real(kind=kind(0.0D0)), dimension(q2_shape__(1), q2_shape__(2)) 
     &:: q2
        integer :: ldq2
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer, dimension(1) :: indxp_shape__
        integer, dimension(indxp_shape__(1)) :: indxp
        integer, dimension(1) :: indx_shape__
        integer, dimension(indx_shape__(1)) :: indx
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaed8
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq2) .ne. (q2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaed8(icompq, k, n, qsiz, d, q, ldq, indxq, rho, cutpnt, z
     &, dlamda, q2, ldq2, w, perm, givptr, givcol, givnum, indxp, indx, 
     &info)
        fw_iserr__ = 0
      end subroutine dlaed8_c
      subroutine dlaed9_c(k, kstart, kstop, n, d_shape__, d, q_shape__, 
     &q, ldq, rho, dlamda_shape__, dlamda, w_shape__, w, s_shape__, s, l
     &ds, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: k
        integer :: kstart
        integer :: kstop
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        real(kind=kind(0.0D0)) :: rho
        integer, dimension(1) :: dlamda_shape__
        real(kind=kind(0.0D0)), dimension(dlamda_shape__(1)) :: dlamda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1), s_shape__(2)) ::
     & s
        integer :: lds
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaed9
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lds) .ne. (s_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("s                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaed9(k, kstart, kstop, n, d, q, ldq, rho, dlamda, w, s, l
     &ds, info)
        fw_iserr__ = 0
      end subroutine dlaed9_c
      subroutine dlaeda_c(n, tlvls, curlvl, curpbm, prmptr_shape__, prmp
     &tr, perm_shape__, perm, givptr_shape__, givptr, givcol_shape__, gi
     &vcol, givnum_shape__, givnum, q_shape__, q, qptr_shape__, qptr, z_
     &shape__, z, ztemp_shape__, ztemp, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: tlvls
        integer :: curlvl
        integer :: curpbm
        integer, dimension(1) :: prmptr_shape__
        integer, dimension(prmptr_shape__(1)) :: prmptr
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer, dimension(1) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1)) :: q
        integer, dimension(1) :: qptr_shape__
        integer, dimension(qptr_shape__(1)) :: qptr
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: ztemp_shape__
        real(kind=kind(0.0D0)), dimension(ztemp_shape__(1)) :: ztemp
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaeda
        fw_iserr__ = -1
        if ((2) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaeda(n, tlvls, curlvl, curpbm, prmptr, perm, givptr, givc
     &ol, givnum, q, qptr, z, ztemp, info)
        fw_iserr__ = 0
      end subroutine dlaeda_c
      subroutine dlaein_c(rightv, noinit, n, h_shape__, h, ldh, wr, wi, 
     &vr_shape__, vr, vi_shape__, vi, b_shape__, b, ldb, work_shape__, w
     &ork, eps3, smlnum, bignum, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: rightv
        integer(kind=kind(0)) :: noinit
        integer :: n
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        real(kind=kind(0.0D0)) :: wr
        real(kind=kind(0.0D0)) :: wi
        integer, dimension(1) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1)) :: vr
        integer, dimension(1) :: vi_shape__
        real(kind=kind(0.0D0)), dimension(vi_shape__(1)) :: vi
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        real(kind=kind(0.0D0)) :: eps3
        real(kind=kind(0.0D0)) :: smlnum
        real(kind=kind(0.0D0)) :: bignum
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaein
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaein(rightv, noinit, n, h, ldh, wr, wi, vr, vi, b, ldb, w
     &ork, eps3, smlnum, bignum, info)
        fw_iserr__ = 0
      end subroutine dlaein_c
      subroutine dlaev2_c(a, b, c, rt1, rt2, cs1, sn1, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: a
        real(kind=kind(0.0D0)) :: b
        real(kind=kind(0.0D0)) :: c
        real(kind=kind(0.0D0)) :: rt1
        real(kind=kind(0.0D0)) :: rt2
        real(kind=kind(0.0D0)) :: cs1
        real(kind=kind(0.0D0)) :: sn1
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaev2
        fw_iserr__ = -1
        call dlaev2(a, b, c, rt1, rt2, cs1, sn1)
        fw_iserr__ = 0
      end subroutine dlaev2_c
      subroutine dlaexc_c(wantq, n, t_shape__, t, ldt, q_shape__, q, ldq
     &, j1, n1, n2, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantq
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer :: j1
        integer :: n1
        integer :: n2
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaexc
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaexc(wantq, n, t, ldt, q, ldq, j1, n1, n2, work, info)
        fw_iserr__ = 0
      end subroutine dlaexc_c
      subroutine dlag2_c(a_shape__, a, lda, b_shape__, b, ldb, safmin, s
     &cale1, scale2, wr1, wr2, wi, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        real(kind=kind(0.0D0)) :: safmin
        real(kind=kind(0.0D0)) :: scale1
        real(kind=kind(0.0D0)) :: scale2
        real(kind=kind(0.0D0)) :: wr1
        real(kind=kind(0.0D0)) :: wr2
        real(kind=kind(0.0D0)) :: wi
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlag2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlag2(a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2, wi)
        fw_iserr__ = 0
      end subroutine dlag2_c
      subroutine dlag2s_c(m, n, a_shape__, a, lda, sa_shape__, sa, ldsa,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: sa_shape__
        real(kind=kind(0.0)), dimension(sa_shape__(1), sa_shape__(2)) ::
     & sa
        integer :: ldsa
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlag2s
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldsa) .ne. (sa_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sa                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlag2s(m, n, a, lda, sa, ldsa, info)
        fw_iserr__ = 0
      end subroutine dlag2s_c
      subroutine dlags2_c(upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, 
     &snv, csq, snq, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: upper
        real(kind=kind(0.0D0)) :: a1
        real(kind=kind(0.0D0)) :: a2
        real(kind=kind(0.0D0)) :: a3
        real(kind=kind(0.0D0)) :: b1
        real(kind=kind(0.0D0)) :: b2
        real(kind=kind(0.0D0)) :: b3
        real(kind=kind(0.0D0)) :: csu
        real(kind=kind(0.0D0)) :: snu
        real(kind=kind(0.0D0)) :: csv
        real(kind=kind(0.0D0)) :: snv
        real(kind=kind(0.0D0)) :: csq
        real(kind=kind(0.0D0)) :: snq
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlags2
        fw_iserr__ = -1
        call dlags2(upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, snv, c
     &sq, snq)
        fw_iserr__ = 0
      end subroutine dlags2_c
      subroutine dlagtf_c(n, a_shape__, a, lambda, b_shape__, b, c_shape
     &__, c, tol, d_shape__, d, in_shape__, in, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1)) :: a
        real(kind=kind(0.0D0)) :: lambda
        integer, dimension(1) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1)) :: b
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: tol
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: in_shape__
        integer, dimension(in_shape__(1)) :: in
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlagtf
        fw_iserr__ = -1
        call dlagtf(n, a, lambda, b, c, tol, d, in, info)
        fw_iserr__ = 0
      end subroutine dlagtf_c
      subroutine dlagtm_c(trans, n, nrhs, alpha, dl_shape__, dl, d_shape
     &__, d, du_shape__, du, x_shape__, x, ldx, beta, b_shape__, b, ldb,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0D0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0D0)), dimension(du_shape__(1)) :: du
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlagtm
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlagtm(trans, n, nrhs, alpha, dl, d, du, x, ldx, beta, b, l
     &db)
        fw_iserr__ = 0
      end subroutine dlagtm_c
      subroutine dlagts_c(job, n, a_shape__, a, b_shape__, b, c_shape__,
     & c, d_shape__, d, in_shape__, in, y_shape__, y, tol, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: job
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1)) :: a
        integer, dimension(1) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1)) :: b
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: in_shape__
        integer, dimension(in_shape__(1)) :: in
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        real(kind=kind(0.0D0)) :: tol
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlagts
        fw_iserr__ = -1
        call dlagts(job, n, a, b, c, d, in, y, tol, info)
        fw_iserr__ = 0
      end subroutine dlagts_c
      subroutine dlagv2_c(a_shape__, a, lda, b_shape__, b, ldb, alphar_s
     &hape__, alphar, alphai_shape__, alphai, beta_shape__, beta, csl, s
     &nl, csr, snr, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0D0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0D0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        real(kind=kind(0.0D0)) :: csl
        real(kind=kind(0.0D0)) :: snl
        real(kind=kind(0.0D0)) :: csr
        real(kind=kind(0.0D0)) :: snr
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlagv2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (alphar_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("alphar                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (alphai_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("alphai                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (beta_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("beta                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlagv2(a, lda, b, ldb, alphar, alphai, beta, csl, snl, csr,
     & snr)
        fw_iserr__ = 0
      end subroutine dlagv2_c
      subroutine dlahqr_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &wr_shape__, wr, wi_shape__, wi, iloz, ihiz, z_shape__, z, ldz, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0D0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0D0)), dimension(wi_shape__(1)) :: wi
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlahqr
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlahqr(wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihi
     &z, z, ldz, info)
        fw_iserr__ = 0
      end subroutine dlahqr_c
      subroutine dlahr2_c(n, k, nb, a_shape__, a, lda, tau_shape__, tau,
     & t_shape__, t, ldt, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: k
        integer :: nb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1), y_shape__(2)) ::
     & y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlahr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nb) .lt. 0 .or. (nb) .gt. (tau_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tau                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (t
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (y
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlahr2(n, k, nb, a, lda, tau, t, ldt, y, ldy)
        fw_iserr__ = 0
      end subroutine dlahr2_c
      subroutine dlahrd_c(n, k, nb, a_shape__, a, lda, tau_shape__, tau,
     & t_shape__, t, ldt, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: k
        integer :: nb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1), y_shape__(2)) ::
     & y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlahrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nb) .lt. 0 .or. (nb) .gt. (tau_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tau                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (t
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (y
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlahrd(n, k, nb, a, lda, tau, t, ldt, y, ldy)
        fw_iserr__ = 0
      end subroutine dlahrd_c
      subroutine dlaic1_c(job, j, x_shape__, x, sest, w_shape__, w, gamm
     &a, sestpr, s, c, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: job
        integer :: j
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0D0)) :: sest
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        real(kind=kind(0.0D0)) :: gamma
        real(kind=kind(0.0D0)) :: sestpr
        real(kind=kind(0.0D0)) :: s
        real(kind=kind(0.0D0)) :: c
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaic1
        fw_iserr__ = -1
        if ((j) .lt. 0 .or. (j) .gt. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((j) .lt. 0 .or. (j) .gt. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaic1(job, j, x, sest, w, gamma, sestpr, s, c)
        fw_iserr__ = 0
      end subroutine dlaic1_c
      subroutine dlaisnan_c(fw_ret_arg, din1, din2, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: fw_ret_arg
        real(kind=kind(0.0D0)) :: din1
        real(kind=kind(0.0D0)) :: din2
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer(kind=kind(0)) :: dlaisnan
        external dlaisnan
        fw_iserr__ = -1
        fw_ret_arg = dlaisnan(din1, din2)
        fw_iserr__ = 0
      end subroutine dlaisnan_c
      subroutine dlaln2_c(ltrans, na, nw, smin, ca, a_shape__, a, lda, d
     &1, d2, b_shape__, b, ldb, wr, wi, x_shape__, x, ldx, scale, xnorm,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: ltrans
        integer :: na
        integer :: nw
        real(kind=kind(0.0D0)) :: smin
        real(kind=kind(0.0D0)) :: ca
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        real(kind=kind(0.0D0)) :: d1
        real(kind=kind(0.0D0)) :: d2
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        real(kind=kind(0.0D0)) :: wr
        real(kind=kind(0.0D0)) :: wi
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: scale
        real(kind=kind(0.0D0)) :: xnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaln2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaln2(ltrans, na, nw, smin, ca, a, lda, d1, d2, b, ldb, wr
     &, wi, x, ldx, scale, xnorm, info)
        fw_iserr__ = 0
      end subroutine dlaln2_c
      subroutine dlals0_c(icompq, nl, nr, sqre, nrhs, b_shape__, b, ldb,
     & bx_shape__, bx, ldbx, perm_shape__, perm, givptr, givcol_shape__,
     & givcol, ldgcol, givnum_shape__, givnum, ldgnum, poles_shape__, po
     &les, difl_shape__, difl, difr_shape__, difr, z_shape__, z, k, c, s
     &, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: nl
        integer :: nr
        integer :: sqre
        integer :: nrhs
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: bx_shape__
        real(kind=kind(0.0D0)), dimension(bx_shape__(1), bx_shape__(2)) 
     &:: bx
        integer :: ldbx
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer :: ldgnum
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0D0)), dimension(poles_shape__(1), poles_shape_
     &_(2)) :: poles
        integer, dimension(1) :: difl_shape__
        real(kind=kind(0.0D0)), dimension(difl_shape__(1)) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0D0)), dimension(difr_shape__(1), difr_shape__(
     &2)) :: difr
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer :: k
        real(kind=kind(0.0D0)) :: c
        real(kind=kind(0.0D0)) :: s
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlals0
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbx) .ne. (bx_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bx                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlals0(icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx, perm, 
     &givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z, k, c
     &, s, work, info)
        fw_iserr__ = 0
      end subroutine dlals0_c
      subroutine dlalsa_c(icompq, smlsiz, n, nrhs, b_shape__, b, ldb, bx
     &_shape__, bx, ldbx, u_shape__, u, ldu, vt_shape__, vt, k_shape__, 
     &k, difl_shape__, difl, difr_shape__, difr, z_shape__, z, poles_sha
     &pe__, poles, givptr_shape__, givptr, givcol_shape__, givcol, ldgco
     &l, perm_shape__, perm, givnum_shape__, givnum, c_shape__, c, s_sha
     &pe__, s, work_shape__, work, iwork_shape__, iwork, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: smlsiz
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: bx_shape__
        real(kind=kind(0.0D0)), dimension(bx_shape__(1), bx_shape__(2)) 
     &:: bx
        integer :: ldbx
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer, dimension(2) :: difl_shape__
        real(kind=kind(0.0D0)), dimension(difl_shape__(1), difl_shape__(
     &2)) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0D0)), dimension(difr_shape__(1), difr_shape__(
     &2)) :: difr
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0D0)), dimension(poles_shape__(1), poles_shape_
     &_(2)) :: poles
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: perm_shape__
        integer, dimension(perm_shape__(1), perm_shape__(2)) :: perm
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlalsa
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbx) .ne. (bx_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bx                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difl                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (perm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("perm                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlalsa(icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, v
     &t, k, difl, difr, z, poles, givptr, givcol, ldgcol, perm, givnum, 
     &c, s, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dlalsa_c
      subroutine dlalsd_c(uplo, smlsiz, n, nrhs, d_shape__, d, e_shape__
     &, e, b_shape__, b, ldb, rcond, rank, work_shape__, work, iwork_sha
     &pe__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: smlsiz
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        real(kind=kind(0.0D0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlalsd
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlalsd(uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond, rank, wo
     &rk, iwork, info)
        fw_iserr__ = 0
      end subroutine dlalsd_c
      subroutine dlamrg_c(n1, n2, a_shape__, a, dtrd1, dtrd2, index_shap
     &e__, index, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n1
        integer :: n2
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1)) :: a
        integer :: dtrd1
        integer :: dtrd2
        integer, dimension(1) :: index_shape__
        integer, dimension(index_shape__(1)) :: index
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlamrg
        fw_iserr__ = -1
        call dlamrg(n1, n2, a, dtrd1, dtrd2, index)
        fw_iserr__ = 0
      end subroutine dlamrg_c
      subroutine dlaneg_c(fw_ret_arg, n, d_shape__, d, lld_shape__, lld,
     & sigma, pivmin, r, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: lld_shape__
        real(kind=kind(0.0D0)), dimension(lld_shape__(1)) :: lld
        real(kind=kind(0.0D0)) :: sigma
        real(kind=kind(0.0D0)) :: pivmin
        integer :: r
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: dlaneg
        external dlaneg
        fw_iserr__ = -1
        fw_ret_arg = dlaneg(n, d, lld, sigma, pivmin, r)
        fw_iserr__ = 0
      end subroutine dlaneg_c
      subroutine dlangb_c(fw_ret_arg, norm, n, kl, ku, ab_shape__, ab, l
     &dab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlangb
        external dlangb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dlangb(norm, n, kl, ku, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine dlangb_c
      subroutine dlange_c(fw_ret_arg, norm, m, n, a_shape__, a, lda, wor
     &k_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlange
        external dlange
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dlange(norm, m, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine dlange_c
      subroutine dlangt_c(fw_ret_arg, norm, n, dl_shape__, dl, d_shape__
     &, d, du_shape__, du, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0D0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0D0)), dimension(du_shape__(1)) :: du
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlangt
        external dlangt
        fw_iserr__ = -1
        fw_ret_arg = dlangt(norm, n, dl, d, du)
        fw_iserr__ = 0
      end subroutine dlangt_c
      subroutine dlanhs_c(fw_ret_arg, norm, n, a_shape__, a, lda, work_s
     &hape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlanhs
        external dlanhs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dlanhs(norm, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine dlanhs_c
      subroutine dlansb_c(fw_ret_arg, norm, uplo, n, k, ab_shape__, ab, 
     &ldab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: k
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlansb
        external dlansb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dlansb(norm, uplo, n, k, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine dlansb_c
      subroutine dlansf_c(fw_ret_arg, norm, transr, uplo, n, a_shape__, 
     &a, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1)) :: a
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlansf
        external dlansf
        fw_iserr__ = -1
        fw_ret_arg = dlansf(norm, transr, uplo, n, a, work)
        fw_iserr__ = 0
      end subroutine dlansf_c
      subroutine dlansp_c(fw_ret_arg, norm, uplo, n, ap_shape__, ap, wor
     &k_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlansp
        external dlansp
        fw_iserr__ = -1
        fw_ret_arg = dlansp(norm, uplo, n, ap, work)
        fw_iserr__ = 0
      end subroutine dlansp_c
      subroutine dlanst_c(fw_ret_arg, norm, n, d_shape__, d, e_shape__, 
     &e, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlanst
        external dlanst
        fw_iserr__ = -1
        fw_ret_arg = dlanst(norm, n, d, e)
        fw_iserr__ = 0
      end subroutine dlanst_c
      subroutine dlansy_c(fw_ret_arg, norm, uplo, n, a_shape__, a, lda, 
     &work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlansy
        external dlansy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dlansy(norm, uplo, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine dlansy_c
      subroutine dlantb_c(fw_ret_arg, norm, uplo, diag, n, k, ab_shape__
     &, ab, ldab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: k
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlantb
        external dlantb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dlantb(norm, uplo, diag, n, k, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine dlantb_c
      subroutine dlantp_c(fw_ret_arg, norm, uplo, diag, n, ap_shape__, a
     &p, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlantp
        external dlantp
        fw_iserr__ = -1
        fw_ret_arg = dlantp(norm, uplo, diag, n, ap, work)
        fw_iserr__ = 0
      end subroutine dlantp_c
      subroutine dlantr_c(fw_ret_arg, norm, uplo, diag, m, n, a_shape__,
     & a, lda, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlantr
        external dlantr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = dlantr(norm, uplo, diag, m, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine dlantr_c
      subroutine dlanv2_c(a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: a
        real(kind=kind(0.0D0)) :: b
        real(kind=kind(0.0D0)) :: c
        real(kind=kind(0.0D0)) :: d
        real(kind=kind(0.0D0)) :: rt1r
        real(kind=kind(0.0D0)) :: rt1i
        real(kind=kind(0.0D0)) :: rt2r
        real(kind=kind(0.0D0)) :: rt2i
        real(kind=kind(0.0D0)) :: cs
        real(kind=kind(0.0D0)) :: sn
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlanv2
        fw_iserr__ = -1
        call dlanv2(a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn)
        fw_iserr__ = 0
      end subroutine dlanv2_c
      subroutine dlapll_c(n, x_shape__, x, incx, y_shape__, y, incy, ssm
     &in, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer :: incy
        real(kind=kind(0.0D0)) :: ssmin
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlapll
        fw_iserr__ = -1
        call dlapll(n, x, incx, y, incy, ssmin)
        fw_iserr__ = 0
      end subroutine dlapll_c
      subroutine dlapmr_c(forwrd, m, n, x_shape__, x, ldx, k_shape__, k,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: forwrd
        integer :: m
        integer :: n
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlapmr
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlapmr(forwrd, m, n, x, ldx, k)
        fw_iserr__ = 0
      end subroutine dlapmr_c
      subroutine dlapmt_c(forwrd, m, n, x_shape__, x, ldx, k_shape__, k,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: forwrd
        integer :: m
        integer :: n
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlapmt
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlapmt(forwrd, m, n, x, ldx, k)
        fw_iserr__ = 0
      end subroutine dlapmt_c
      subroutine dlapy2_c(fw_ret_arg, x, y, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        real(kind=kind(0.0D0)) :: x
        real(kind=kind(0.0D0)) :: y
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlapy2
        external dlapy2
        fw_iserr__ = -1
        fw_ret_arg = dlapy2(x, y)
        fw_iserr__ = 0
      end subroutine dlapy2_c
      subroutine dlapy3_c(fw_ret_arg, x, y, z, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        real(kind=kind(0.0D0)) :: x
        real(kind=kind(0.0D0)) :: y
        real(kind=kind(0.0D0)) :: z
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dlapy3
        external dlapy3
        fw_iserr__ = -1
        fw_ret_arg = dlapy3(x, y, z)
        fw_iserr__ = 0
      end subroutine dlapy3_c
      subroutine dlaqgb_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__,
     & r, c_shape__, c, rowcnd, colcnd, amax, equed, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqgb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqgb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, 
     &equed)
        fw_iserr__ = 0
      end subroutine dlaqgb_c
      subroutine dlaqge_c(m, n, a_shape__, a, lda, r_shape__, r, c_shape
     &__, c, rowcnd, colcnd, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqge
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqge(m, n, a, lda, r, c, rowcnd, colcnd, amax, equed)
        fw_iserr__ = 0
      end subroutine dlaqge_c
      subroutine dlaqp2_c(m, n, offset, a_shape__, a, lda, jpvt_shape__,
     & jpvt, tau_shape__, tau, vn1_shape__, vn1, vn2_shape__, vn2, work_
     &shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: offset
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: vn1_shape__
        real(kind=kind(0.0D0)), dimension(vn1_shape__(1)) :: vn1
        integer, dimension(1) :: vn2_shape__
        real(kind=kind(0.0D0)), dimension(vn2_shape__(1)) :: vn2
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqp2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqp2(m, n, offset, a, lda, jpvt, tau, vn1, vn2, work)
        fw_iserr__ = 0
      end subroutine dlaqp2_c
      subroutine dlaqps_c(m, n, offset, nb, kb, a_shape__, a, lda, jpvt_
     &shape__, jpvt, tau_shape__, tau, vn1_shape__, vn1, vn2_shape__, vn
     &2, auxv_shape__, auxv, f_shape__, f, ldf, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: offset
        integer :: nb
        integer :: kb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: vn1_shape__
        real(kind=kind(0.0D0)), dimension(vn1_shape__(1)) :: vn1
        integer, dimension(1) :: vn2_shape__
        real(kind=kind(0.0D0)), dimension(vn2_shape__(1)) :: vn2
        integer, dimension(1) :: auxv_shape__
        real(kind=kind(0.0D0)), dimension(auxv_shape__(1)) :: auxv
        integer, dimension(2) :: f_shape__
        real(kind=kind(0.0D0)), dimension(f_shape__(1), f_shape__(2)) ::
     & f
        integer :: ldf
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqps
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqps(m, n, offset, nb, kb, a, lda, jpvt, tau, vn1, vn2, a
     &uxv, f, ldf)
        fw_iserr__ = 0
      end subroutine dlaqps_c
      subroutine dlaqr0_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &wr_shape__, wr, wi_shape__, wi, iloz, ihiz, z_shape__, z, ldz, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0D0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0D0)), dimension(wi_shape__(1)) :: wi
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqr0
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqr0(wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihi
     &z, z, ldz, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dlaqr0_c
      subroutine dlaqr1_c(n, h_shape__, h, ldh, sr1, si1, sr2, si2, v_sh
     &ape__, v, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        real(kind=kind(0.0D0)) :: sr1
        real(kind=kind(0.0D0)) :: si1
        real(kind=kind(0.0D0)) :: sr2
        real(kind=kind(0.0D0)) :: si2
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1)) :: v
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqr1
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqr1(n, h, ldh, sr1, si1, sr2, si2, v)
        fw_iserr__ = 0
      end subroutine dlaqr1_c
      subroutine dlaqr2_c(wantt, wantz, n, ktop, kbot, nw, h_shape__, h,
     & ldh, iloz, ihiz, z_shape__, z, ldz, ns, nd, sr_shape__, sr, si_sh
     &ape__, si, v_shape__, v, ldv, nh, t_shape__, t, ldt, nv, wv_shape_
     &_, wv, ldwv, work_shape__, work, lwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nw
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer :: ns
        integer :: nd
        integer, dimension(1) :: sr_shape__
        real(kind=kind(0.0D0)), dimension(sr_shape__(1)) :: sr
        integer, dimension(1) :: si_shape__
        real(kind=kind(0.0D0)), dimension(si_shape__(1)) :: si
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer :: nh
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer :: nv
        integer, dimension(2) :: wv_shape__
        real(kind=kind(0.0D0)), dimension(wv_shape__(1), wv_shape__(2)) 
     &:: wv
        integer :: ldwv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqr2
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqr2(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz,
     & z, ldz, ns, nd, sr, si, v, ldv, nh, t, ldt, nv, wv, ldwv, work, l
     &work)
        fw_iserr__ = 0
      end subroutine dlaqr2_c
      subroutine dlaqr3_c(wantt, wantz, n, ktop, kbot, nw, h_shape__, h,
     & ldh, iloz, ihiz, z_shape__, z, ldz, ns, nd, sr_shape__, sr, si_sh
     &ape__, si, v_shape__, v, ldv, nh, t_shape__, t, ldt, nv, wv_shape_
     &_, wv, ldwv, work_shape__, work, lwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nw
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer :: ns
        integer :: nd
        integer, dimension(1) :: sr_shape__
        real(kind=kind(0.0D0)), dimension(sr_shape__(1)) :: sr
        integer, dimension(1) :: si_shape__
        real(kind=kind(0.0D0)), dimension(si_shape__(1)) :: si
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer :: nh
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer :: nv
        integer, dimension(2) :: wv_shape__
        real(kind=kind(0.0D0)), dimension(wv_shape__(1), wv_shape__(2)) 
     &:: wv
        integer :: ldwv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqr3
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqr3(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz,
     & z, ldz, ns, nd, sr, si, v, ldv, nh, t, ldt, nv, wv, ldwv, work, l
     &work)
        fw_iserr__ = 0
      end subroutine dlaqr3_c
      subroutine dlaqr4_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &wr_shape__, wr, wi_shape__, wi, iloz, ihiz, z_shape__, z, ldz, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0D0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0D0)), dimension(wi_shape__(1)) :: wi
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqr4
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqr4(wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihi
     &z, z, ldz, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dlaqr4_c
      subroutine dlaqr5_c(wantt, wantz, kacc22, n, ktop, kbot, nshfts, s
     &r_shape__, sr, si_shape__, si, h_shape__, h, ldh, iloz, ihiz, z_sh
     &ape__, z, ldz, v_shape__, v, ldv, u_shape__, u, ldu, nv, wv_shape_
     &_, wv, ldwv, nh, wh_shape__, wh, ldwh, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: kacc22
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nshfts
        integer, dimension(1) :: sr_shape__
        real(kind=kind(0.0D0)), dimension(sr_shape__(1)) :: sr
        integer, dimension(1) :: si_shape__
        real(kind=kind(0.0D0)), dimension(si_shape__(1)) :: si
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0D0)), dimension(h_shape__(1), h_shape__(2)) ::
     & h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer :: nv
        integer, dimension(2) :: wv_shape__
        real(kind=kind(0.0D0)), dimension(wv_shape__(1), wv_shape__(2)) 
     &:: wv
        integer :: ldwv
        integer :: nh
        integer, dimension(2) :: wh_shape__
        real(kind=kind(0.0D0)), dimension(wh_shape__(1), wh_shape__(2)) 
     &:: wh
        integer :: ldwh
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqr5
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwh) .ne. (wh_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wh                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqr5(wantt, wantz, kacc22, n, ktop, kbot, nshfts, sr, si,
     & h, ldh, iloz, ihiz, z, ldz, v, ldv, u, ldu, nv, wv, ldwv, nh, wh,
     & ldwh)
        fw_iserr__ = 0
      end subroutine dlaqr5_c
      subroutine dlaqsb_c(uplo, n, kd, ab_shape__, ab, ldab, s_shape__, 
     &s, scond, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqsb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqsb(uplo, n, kd, ab, ldab, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine dlaqsb_c
      subroutine dlaqsp_c(uplo, n, ap_shape__, ap, s_shape__, s, scond, 
     &amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqsp
        fw_iserr__ = -1
        call dlaqsp(uplo, n, ap, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine dlaqsp_c
      subroutine dlaqsy_c(uplo, n, a_shape__, a, lda, s_shape__, s, scon
     &d, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqsy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqsy(uplo, n, a, lda, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine dlaqsy_c
      subroutine dlaqtr_c(ltran, lreal, n, t_shape__, t, ldt, b_shape__,
     & b, w, scale, x_shape__, x, work_shape__, work, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: ltran
        integer(kind=kind(0)) :: lreal
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(1) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1)) :: b
        real(kind=kind(0.0D0)) :: w
        real(kind=kind(0.0D0)) :: scale
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaqtr
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaqtr(ltran, lreal, n, t, ldt, b, w, scale, x, work, info)
        fw_iserr__ = 0
      end subroutine dlaqtr_c
      subroutine dlar1v_c(n, b1, bn, lambda, d_shape__, d, l_shape__, l,
     & ld_shape__, ld, lld_shape__, lld, pivmin, gaptol, z_shape__, z, w
     &antnc, negcnt, ztz, mingma, r, isuppz_shape__, isuppz, nrminv, res
     &id, rqcorr, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: b1
        integer :: bn
        real(kind=kind(0.0D0)) :: lambda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: l_shape__
        real(kind=kind(0.0D0)), dimension(l_shape__(1)) :: l
        integer, dimension(1) :: ld_shape__
        real(kind=kind(0.0D0)), dimension(ld_shape__(1)) :: ld
        integer, dimension(1) :: lld_shape__
        real(kind=kind(0.0D0)), dimension(lld_shape__(1)) :: lld
        real(kind=kind(0.0D0)) :: pivmin
        real(kind=kind(0.0D0)) :: gaptol
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer(kind=kind(0)) :: wantnc
        integer :: negcnt
        real(kind=kind(0.0D0)) :: ztz
        real(kind=kind(0.0D0)) :: mingma
        integer :: r
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        real(kind=kind(0.0D0)) :: nrminv
        real(kind=kind(0.0D0)) :: resid
        real(kind=kind(0.0D0)) :: rqcorr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlar1v
        fw_iserr__ = -1
        call dlar1v(n, b1, bn, lambda, d, l, ld, lld, pivmin, gaptol, z,
     & wantnc, negcnt, ztz, mingma, r, isuppz, nrminv, resid, rqcorr, wo
     &rk)
        fw_iserr__ = 0
      end subroutine dlar1v_c
      subroutine dlar2v_c(n, x_shape__, x, y_shape__, y, z_shape__, z, i
     &ncx, c_shape__, c, s_shape__, s, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer :: incx
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlar2v
        fw_iserr__ = -1
        call dlar2v(n, x, y, z, incx, c, s, incc)
        fw_iserr__ = 0
      end subroutine dlar2v_c
      subroutine dlarf_c(side, m, n, v_shape__, v, incv, tau, c_shape__,
     & c, ldc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1)) :: v
        integer :: incv
        real(kind=kind(0.0D0)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarf
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlarf(side, m, n, v, incv, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine dlarf_c
      subroutine dlarfb_c(side, trans, direct, storev, m, n, k, v_shape_
     &_, v, ldv, t_shape__, t, ldt, c_shape__, c, ldc, work_shape__, wor
     &k, ldwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(2) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1), work_shape__(
     &2)) :: work
        integer :: ldwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarfb
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlarfb(side, trans, direct, storev, m, n, k, v, ldv, t, ldt
     &, c, ldc, work, ldwork)
        fw_iserr__ = 0
      end subroutine dlarfb_c
      subroutine dlarfg_c(n, alpha, x_shape__, x, incx, tau, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: tau
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarfg
        fw_iserr__ = -1
        call dlarfg(n, alpha, x, incx, tau)
        fw_iserr__ = 0
      end subroutine dlarfg_c
      subroutine dlarfgp_c(n, alpha, x_shape__, x, incx, tau, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: tau
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarfgp
        fw_iserr__ = -1
        call dlarfgp(n, alpha, x, incx, tau)
        fw_iserr__ = 0
      end subroutine dlarfgp_c
      subroutine dlarft_c(direct, storev, n, k, v_shape__, v, ldv, tau_s
     &hape__, tau, t_shape__, t, ldt, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarft
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlarft(direct, storev, n, k, v, ldv, tau, t, ldt)
        fw_iserr__ = 0
      end subroutine dlarft_c
      subroutine dlarfx_c(side, m, n, v_shape__, v, tau, c_shape__, c, l
     &dc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1)) :: v
        real(kind=kind(0.0D0)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarfx
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlarfx(side, m, n, v, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine dlarfx_c
      subroutine dlargv_c(n, x_shape__, x, incx, y_shape__, y, incy, c_s
     &hape__, c, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlargv
        fw_iserr__ = -1
        call dlargv(n, x, incx, y, incy, c, incc)
        fw_iserr__ = 0
      end subroutine dlargv_c
      subroutine dlarnv_c(idist, iseed_shape__, iseed, n, x_shape__, x, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: idist
        integer, dimension(1) :: iseed_shape__
        integer, dimension(iseed_shape__(1)) :: iseed
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarnv
        fw_iserr__ = -1
        if ((4) .lt. 0 .or. (4) .gt. (iseed_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("iseed                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlarnv(idist, iseed, n, x)
        fw_iserr__ = 0
      end subroutine dlarnv_c
      subroutine dlarra_c(n, d_shape__, d, e_shape__, e, e2_shape__, e2,
     & spltol, tnrm, nsplit, isplit_shape__, isplit, info, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0D0)), dimension(e2_shape__(1)) :: e2
        real(kind=kind(0.0D0)) :: spltol
        real(kind=kind(0.0D0)) :: tnrm
        integer :: nsplit
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarra
        fw_iserr__ = -1
        call dlarra(n, d, e, e2, spltol, tnrm, nsplit, isplit, info)
        fw_iserr__ = 0
      end subroutine dlarra_c
      subroutine dlarrb_c(n, d_shape__, d, lld_shape__, lld, ifirst, ila
     &st, rtol1, rtol2, offset, w_shape__, w, wgap_shape__, wgap, werr_s
     &hape__, werr, work_shape__, work, iwork_shape__, iwork, pivmin, sp
     &diam, twist, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: lld_shape__
        real(kind=kind(0.0D0)), dimension(lld_shape__(1)) :: lld
        integer :: ifirst
        integer :: ilast
        real(kind=kind(0.0D0)) :: rtol1
        real(kind=kind(0.0D0)) :: rtol2
        integer :: offset
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: wgap_shape__
        real(kind=kind(0.0D0)), dimension(wgap_shape__(1)) :: wgap
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0D0)), dimension(werr_shape__(1)) :: werr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        real(kind=kind(0.0D0)) :: pivmin
        real(kind=kind(0.0D0)) :: spdiam
        integer :: twist
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarrb
        fw_iserr__ = -1
        call dlarrb(n, d, lld, ifirst, ilast, rtol1, rtol2, offset, w, w
     &gap, werr, work, iwork, pivmin, spdiam, twist, info)
        fw_iserr__ = 0
      end subroutine dlarrb_c
      subroutine dlarrc_c(jobt, n, vl, vu, d_shape__, d, e_shape__, e, p
     &ivmin, eigcnt, lcnt, rcnt, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobt
        integer :: n
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0D0)) :: pivmin
        integer :: eigcnt
        integer :: lcnt
        integer :: rcnt
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarrc
        fw_iserr__ = -1
        call dlarrc(jobt, n, vl, vu, d, e, pivmin, eigcnt, lcnt, rcnt, i
     &nfo)
        fw_iserr__ = 0
      end subroutine dlarrc_c
      subroutine dlarrd_c(range, order, n, vl, vu, il, iu, gers_shape__,
     & gers, reltol, d_shape__, d, e_shape__, e, e2_shape__, e2, pivmin,
     & nsplit, isplit_shape__, isplit, m, w_shape__, w, werr_shape__, we
     &rr, wl, wu, iblock_shape__, iblock, indexw_shape__, indexw, work_s
     &hape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: order
        integer :: n
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        integer, dimension(1) :: gers_shape__
        real(kind=kind(0.0D0)), dimension(gers_shape__(1)) :: gers
        real(kind=kind(0.0D0)) :: reltol
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0D0)), dimension(e2_shape__(1)) :: e2
        real(kind=kind(0.0D0)) :: pivmin
        integer :: nsplit
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0D0)), dimension(werr_shape__(1)) :: werr
        real(kind=kind(0.0D0)) :: wl
        real(kind=kind(0.0D0)) :: wu
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: indexw_shape__
        integer, dimension(indexw_shape__(1)) :: indexw
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarrd
        fw_iserr__ = -1
        call dlarrd(range, order, n, vl, vu, il, iu, gers, reltol, d, e,
     & e2, pivmin, nsplit, isplit, m, w, werr, wl, wu, iblock, indexw, w
     &ork, iwork, info)
        fw_iserr__ = 0
      end subroutine dlarrd_c
      subroutine dlarre_c(range, n, vl, vu, il, iu, d_shape__, d, e_shap
     &e__, e, e2_shape__, e2, rtol1, rtol2, spltol, nsplit, isplit_shape
     &__, isplit, m, w_shape__, w, werr_shape__, werr, wgap_shape__, wga
     &p, iblock_shape__, iblock, indexw_shape__, indexw, gers_shape__, g
     &ers, pivmin, work_shape__, work, iwork_shape__, iwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: range
        integer :: n
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0D0)), dimension(e2_shape__(1)) :: e2
        real(kind=kind(0.0D0)) :: rtol1
        real(kind=kind(0.0D0)) :: rtol2
        real(kind=kind(0.0D0)) :: spltol
        integer :: nsplit
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0D0)), dimension(werr_shape__(1)) :: werr
        integer, dimension(1) :: wgap_shape__
        real(kind=kind(0.0D0)), dimension(wgap_shape__(1)) :: wgap
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: indexw_shape__
        integer, dimension(indexw_shape__(1)) :: indexw
        integer, dimension(1) :: gers_shape__
        real(kind=kind(0.0D0)), dimension(gers_shape__(1)) :: gers
        real(kind=kind(0.0D0)) :: pivmin
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarre
        fw_iserr__ = -1
        call dlarre(range, n, vl, vu, il, iu, d, e, e2, rtol1, rtol2, sp
     &ltol, nsplit, isplit, m, w, werr, wgap, iblock, indexw, gers, pivm
     &in, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dlarre_c
      subroutine dlarrf_c(n, d_shape__, d, l_shape__, l, ld_shape__, ld,
     & clstrt, clend, w_shape__, w, wgap_shape__, wgap, werr_shape__, we
     &rr, spdiam, clgapl, clgapr, pivmin, sigma, dplus_shape__, dplus, l
     &plus_shape__, lplus, work_shape__, work, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: l_shape__
        real(kind=kind(0.0D0)), dimension(l_shape__(1)) :: l
        integer, dimension(1) :: ld_shape__
        real(kind=kind(0.0D0)), dimension(ld_shape__(1)) :: ld
        integer :: clstrt
        integer :: clend
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: wgap_shape__
        real(kind=kind(0.0D0)), dimension(wgap_shape__(1)) :: wgap
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0D0)), dimension(werr_shape__(1)) :: werr
        real(kind=kind(0.0D0)) :: spdiam
        real(kind=kind(0.0D0)) :: clgapl
        real(kind=kind(0.0D0)) :: clgapr
        real(kind=kind(0.0D0)) :: pivmin
        real(kind=kind(0.0D0)) :: sigma
        integer, dimension(1) :: dplus_shape__
        real(kind=kind(0.0D0)), dimension(dplus_shape__(1)) :: dplus
        integer, dimension(1) :: lplus_shape__
        real(kind=kind(0.0D0)), dimension(lplus_shape__(1)) :: lplus
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarrf
        fw_iserr__ = -1
        call dlarrf(n, d, l, ld, clstrt, clend, w, wgap, werr, spdiam, c
     &lgapl, clgapr, pivmin, sigma, dplus, lplus, work, info)
        fw_iserr__ = 0
      end subroutine dlarrf_c
      subroutine dlarrj_c(n, d_shape__, d, e2_shape__, e2, ifirst, ilast
     &, rtol, offset, w_shape__, w, werr_shape__, werr, work_shape__, wo
     &rk, iwork_shape__, iwork, pivmin, spdiam, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0D0)), dimension(e2_shape__(1)) :: e2
        integer :: ifirst
        integer :: ilast
        real(kind=kind(0.0D0)) :: rtol
        integer :: offset
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0D0)), dimension(werr_shape__(1)) :: werr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        real(kind=kind(0.0D0)) :: pivmin
        real(kind=kind(0.0D0)) :: spdiam
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarrj
        fw_iserr__ = -1
        call dlarrj(n, d, e2, ifirst, ilast, rtol, offset, w, werr, work
     &, iwork, pivmin, spdiam, info)
        fw_iserr__ = 0
      end subroutine dlarrj_c
      subroutine dlarrk_c(n, iw, gl, gu, d_shape__, d, e2_shape__, e2, p
     &ivmin, reltol, w, werr, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: iw
        real(kind=kind(0.0D0)) :: gl
        real(kind=kind(0.0D0)) :: gu
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0D0)), dimension(e2_shape__(1)) :: e2
        real(kind=kind(0.0D0)) :: pivmin
        real(kind=kind(0.0D0)) :: reltol
        real(kind=kind(0.0D0)) :: w
        real(kind=kind(0.0D0)) :: werr
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarrk
        fw_iserr__ = -1
        call dlarrk(n, iw, gl, gu, d, e2, pivmin, reltol, w, werr, info)
        fw_iserr__ = 0
      end subroutine dlarrk_c
      subroutine dlarrr_c(n, d_shape__, d, e_shape__, e, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarrr
        fw_iserr__ = -1
        call dlarrr(n, d, e, info)
        fw_iserr__ = 0
      end subroutine dlarrr_c
      subroutine dlarrv_c(n, vl, vu, d_shape__, d, l_shape__, l, pivmin,
     & isplit_shape__, isplit, m, dol, dou, minrgp, rtol1, rtol2, w_shap
     &e__, w, werr_shape__, werr, wgap_shape__, wgap, iblock_shape__, ib
     &lock, indexw_shape__, indexw, gers_shape__, gers, z_shape__, z, ld
     &z, isuppz_shape__, isuppz, work_shape__, work, iwork_shape__, iwor
     &k, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: l_shape__
        real(kind=kind(0.0D0)), dimension(l_shape__(1)) :: l
        real(kind=kind(0.0D0)) :: pivmin
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer :: m
        integer :: dol
        integer :: dou
        real(kind=kind(0.0D0)) :: minrgp
        real(kind=kind(0.0D0)) :: rtol1
        real(kind=kind(0.0D0)) :: rtol2
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0D0)), dimension(werr_shape__(1)) :: werr
        integer, dimension(1) :: wgap_shape__
        real(kind=kind(0.0D0)), dimension(wgap_shape__(1)) :: wgap
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: indexw_shape__
        integer, dimension(indexw_shape__(1)) :: indexw
        integer, dimension(1) :: gers_shape__
        real(kind=kind(0.0D0)), dimension(gers_shape__(1)) :: gers
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarrv
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlarrv(n, vl, vu, d, l, pivmin, isplit, m, dol, dou, minrgp
     &, rtol1, rtol2, w, werr, wgap, iblock, indexw, gers, z, ldz, isupp
     &z, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dlarrv_c
      subroutine dlarscl2_c(m, n, d_shape__, d, x_shape__, x, ldx, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarscl2
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlarscl2(m, n, d, x, ldx)
        fw_iserr__ = 0
      end subroutine dlarscl2_c
      subroutine dlartg_c(f, g, cs, sn, r, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: f
        real(kind=kind(0.0D0)) :: g
        real(kind=kind(0.0D0)) :: cs
        real(kind=kind(0.0D0)) :: sn
        real(kind=kind(0.0D0)) :: r
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlartg
        fw_iserr__ = -1
        call dlartg(f, g, cs, sn, r)
        fw_iserr__ = 0
      end subroutine dlartg_c
      subroutine dlartgp_c(f, g, cs, sn, r, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: f
        real(kind=kind(0.0D0)) :: g
        real(kind=kind(0.0D0)) :: cs
        real(kind=kind(0.0D0)) :: sn
        real(kind=kind(0.0D0)) :: r
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlartgp
        fw_iserr__ = -1
        call dlartgp(f, g, cs, sn, r)
        fw_iserr__ = 0
      end subroutine dlartgp_c
      subroutine dlartgs_c(x, y, sigma, cs, sn, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: x
        real(kind=kind(0.0D0)) :: y
        real(kind=kind(0.0D0)) :: sigma
        real(kind=kind(0.0D0)) :: cs
        real(kind=kind(0.0D0)) :: sn
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlartgs
        fw_iserr__ = -1
        call dlartgs(x, y, sigma, cs, sn)
        fw_iserr__ = 0
      end subroutine dlartgs_c
      subroutine dlartv_c(n, x_shape__, x, incx, y_shape__, y, incy, c_s
     &hape__, c, s_shape__, s, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlartv
        fw_iserr__ = -1
        call dlartv(n, x, incx, y, incy, c, s, incc)
        fw_iserr__ = 0
      end subroutine dlartv_c
      subroutine dlaruv_c(iseed_shape__, iseed, n, x_shape__, x, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer, dimension(1) :: iseed_shape__
        integer, dimension(iseed_shape__(1)) :: iseed
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaruv
        fw_iserr__ = -1
        if ((4) .lt. 0 .or. (4) .gt. (iseed_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("iseed                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaruv(iseed, n, x)
        fw_iserr__ = 0
      end subroutine dlaruv_c
      subroutine dlarz_c(side, m, n, l, v_shape__, v, incv, tau, c_shape
     &__, c, ldc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer :: l
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1)) :: v
        integer :: incv
        real(kind=kind(0.0D0)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarz
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlarz(side, m, n, l, v, incv, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine dlarz_c
      subroutine dlarzb_c(side, trans, direct, storev, m, n, k, l, v_sha
     &pe__, v, ldv, t_shape__, t, ldt, c_shape__, c, ldc, work_shape__, 
     &work, ldwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(2) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1), work_shape__(
     &2)) :: work
        integer :: ldwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarzb
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlarzb(side, trans, direct, storev, m, n, k, l, v, ldv, t, 
     &ldt, c, ldc, work, ldwork)
        fw_iserr__ = 0
      end subroutine dlarzb_c
      subroutine dlarzt_c(direct, storev, n, k, v_shape__, v, ldv, tau_s
     &hape__, tau, t_shape__, t, ldt, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlarzt
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlarzt(direct, storev, n, k, v, ldv, tau, t, ldt)
        fw_iserr__ = 0
      end subroutine dlarzt_c
      subroutine dlas2_c(f, g, h, ssmin, ssmax, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: f
        real(kind=kind(0.0D0)) :: g
        real(kind=kind(0.0D0)) :: h
        real(kind=kind(0.0D0)) :: ssmin
        real(kind=kind(0.0D0)) :: ssmax
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlas2
        fw_iserr__ = -1
        call dlas2(f, g, h, ssmin, ssmax)
        fw_iserr__ = 0
      end subroutine dlas2_c
      subroutine dlascl_c(type, kl, ku, cfrom, cto, m, n, a_shape__, a, 
     &lda, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: type
        integer :: kl
        integer :: ku
        real(kind=kind(0.0D0)) :: cfrom
        real(kind=kind(0.0D0)) :: cto
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlascl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlascl(type, kl, ku, cfrom, cto, m, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine dlascl_c
      subroutine dlascl2_c(m, n, d_shape__, d, x_shape__, x, ldx, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlascl2
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlascl2(m, n, d, x, ldx)
        fw_iserr__ = 0
      end subroutine dlascl2_c
      subroutine dlasd0_c(n, sqre, d_shape__, d, e_shape__, e, u_shape__
     &, u, ldu, vt_shape__, vt, ldvt, smlsiz, iwork_shape__, iwork, work
     &_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: sqre
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer :: ldvt
        integer :: smlsiz
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasd0
        fw_iserr__ = -1
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasd0(n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork, work
     &, info)
        fw_iserr__ = 0
      end subroutine dlasd0_c
      subroutine dlasd1_c(nl, nr, sqre, d_shape__, d, alpha, beta, u_sha
     &pe__, u, ldu, vt_shape__, vt, ldvt, idxq_shape__, idxq, iwork_shap
     &e__, iwork, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: nl
        integer :: nr
        integer :: sqre
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        real(kind=kind(0.0D0)) :: alpha
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer :: ldvt
        integer, dimension(1) :: idxq_shape__
        integer, dimension(idxq_shape__(1)) :: idxq
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasd1
        fw_iserr__ = -1
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasd1(nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt, idxq
     &, iwork, work, info)
        fw_iserr__ = 0
      end subroutine dlasd1_c
      subroutine dlasd2_c(nl, nr, sqre, k, d_shape__, d, z_shape__, z, a
     &lpha, beta, u_shape__, u, ldu, vt_shape__, vt, ldvt, dsigma_shape_
     &_, dsigma, u2_shape__, u2, ldu2, vt2_shape__, vt2, ldvt2, idxp_sha
     &pe__, idxp, idx_shape__, idx, idxc_shape__, idxc, idxq_shape__, id
     &xq, coltyp_shape__, coltyp, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: nl
        integer :: nr
        integer :: sqre
        integer :: k
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        real(kind=kind(0.0D0)) :: alpha
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer :: ldvt
        integer, dimension(1) :: dsigma_shape__
        real(kind=kind(0.0D0)), dimension(dsigma_shape__(1)) :: dsigma
        integer, dimension(2) :: u2_shape__
        real(kind=kind(0.0D0)), dimension(u2_shape__(1), u2_shape__(2)) 
     &:: u2
        integer :: ldu2
        integer, dimension(2) :: vt2_shape__
        real(kind=kind(0.0D0)), dimension(vt2_shape__(1), vt2_shape__(2)
     &) :: vt2
        integer :: ldvt2
        integer, dimension(1) :: idxp_shape__
        integer, dimension(idxp_shape__(1)) :: idxp
        integer, dimension(1) :: idx_shape__
        integer, dimension(idx_shape__(1)) :: idx
        integer, dimension(1) :: idxc_shape__
        integer, dimension(idxc_shape__(1)) :: idxc
        integer, dimension(1) :: idxq_shape__
        integer, dimension(idxq_shape__(1)) :: idxq
        integer, dimension(1) :: coltyp_shape__
        integer, dimension(coltyp_shape__(1)) :: coltyp
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasd2
        fw_iserr__ = -1
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt2) .ne. (vt2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt2                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasd2(nl, nr, sqre, k, d, z, alpha, beta, u, ldu, vt, ldvt
     &, dsigma, u2, ldu2, vt2, ldvt2, idxp, idx, idxc, idxq, coltyp, inf
     &o)
        fw_iserr__ = 0
      end subroutine dlasd2_c
      subroutine dlasd3_c(nl, nr, sqre, k, d_shape__, d, q_shape__, q, l
     &dq, dsigma_shape__, dsigma, u_shape__, u, ldu, u2_shape__, u2, ldu
     &2, vt_shape__, vt, ldvt, vt2_shape__, vt2, ldvt2, idxc_shape__, id
     &xc, ctot_shape__, ctot, z_shape__, z, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: nl
        integer :: nr
        integer :: sqre
        integer :: k
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: dsigma_shape__
        real(kind=kind(0.0D0)), dimension(dsigma_shape__(1)) :: dsigma
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: u2_shape__
        real(kind=kind(0.0D0)), dimension(u2_shape__(1), u2_shape__(2)) 
     &:: u2
        integer :: ldu2
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer :: ldvt
        integer, dimension(2) :: vt2_shape__
        real(kind=kind(0.0D0)), dimension(vt2_shape__(1), vt2_shape__(2)
     &) :: vt2
        integer :: ldvt2
        integer, dimension(1) :: idxc_shape__
        integer, dimension(idxc_shape__(1)) :: idxc
        integer, dimension(1) :: ctot_shape__
        integer, dimension(ctot_shape__(1)) :: ctot
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasd3
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt2) .ne. (vt2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt2                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasd3(nl, nr, sqre, k, d, q, ldq, dsigma, u, ldu, u2, ldu2
     &, vt, ldvt, vt2, ldvt2, idxc, ctot, z, info)
        fw_iserr__ = 0
      end subroutine dlasd3_c
      subroutine dlasd4_c(n, i, d_shape__, d, z_shape__, z, delta_shape_
     &_, delta, rho, sigma, work_shape__, work, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: i
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: delta_shape__
        real(kind=kind(0.0D0)), dimension(delta_shape__(1)) :: delta
        real(kind=kind(0.0D0)) :: rho
        real(kind=kind(0.0D0)) :: sigma
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasd4
        fw_iserr__ = -1
        call dlasd4(n, i, d, z, delta, rho, sigma, work, info)
        fw_iserr__ = 0
      end subroutine dlasd4_c
      subroutine dlasd5_c(i, d_shape__, d, z_shape__, z, delta_shape__, 
     &delta, rho, dsigma, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: delta_shape__
        real(kind=kind(0.0D0)), dimension(delta_shape__(1)) :: delta
        real(kind=kind(0.0D0)) :: rho
        real(kind=kind(0.0D0)) :: dsigma
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasd5
        fw_iserr__ = -1
        if ((2) .lt. 0 .or. (2) .gt. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (delta_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("delta                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasd5(i, d, z, delta, rho, dsigma, work)
        fw_iserr__ = 0
      end subroutine dlasd5_c
      subroutine dlasd6_c(icompq, nl, nr, sqre, d_shape__, d, vf_shape__
     &, vf, vl_shape__, vl, alpha, beta, idxq_shape__, idxq, perm_shape_
     &_, perm, givptr, givcol_shape__, givcol, ldgcol, givnum_shape__, g
     &ivnum, ldgnum, poles_shape__, poles, difl_shape__, difl, difr_shap
     &e__, difr, z_shape__, z, k, c, s, work_shape__, work, iwork_shape_
     &_, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: nl
        integer :: nr
        integer :: sqre
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: vf_shape__
        real(kind=kind(0.0D0)), dimension(vf_shape__(1)) :: vf
        integer, dimension(1) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1)) :: vl
        real(kind=kind(0.0D0)) :: alpha
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: idxq_shape__
        integer, dimension(idxq_shape__(1)) :: idxq
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer :: ldgnum
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0D0)), dimension(poles_shape__(1), poles_shape_
     &_(2)) :: poles
        integer, dimension(1) :: difl_shape__
        real(kind=kind(0.0D0)), dimension(difl_shape__(1)) :: difl
        integer, dimension(1) :: difr_shape__
        real(kind=kind(0.0D0)), dimension(difr_shape__(1)) :: difr
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer :: k
        real(kind=kind(0.0D0)) :: c
        real(kind=kind(0.0D0)) :: s
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasd6
        fw_iserr__ = -1
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasd6(icompq, nl, nr, sqre, d, vf, vl, alpha, beta, idxq, 
     &perm, givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z
     &, k, c, s, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dlasd6_c
      subroutine dlasd7_c(icompq, nl, nr, sqre, k, d_shape__, d, z_shape
     &__, z, zw_shape__, zw, vf_shape__, vf, vfw_shape__, vfw, vl_shape_
     &_, vl, vlw_shape__, vlw, alpha, beta, dsigma_shape__, dsigma, idx_
     &shape__, idx, idxp_shape__, idxp, idxq_shape__, idxq, perm_shape__
     &, perm, givptr, givcol_shape__, givcol, ldgcol, givnum_shape__, gi
     &vnum, ldgnum, c, s, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: nl
        integer :: nr
        integer :: sqre
        integer :: k
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: zw_shape__
        real(kind=kind(0.0D0)), dimension(zw_shape__(1)) :: zw
        integer, dimension(1) :: vf_shape__
        real(kind=kind(0.0D0)), dimension(vf_shape__(1)) :: vf
        integer, dimension(1) :: vfw_shape__
        real(kind=kind(0.0D0)), dimension(vfw_shape__(1)) :: vfw
        integer, dimension(1) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1)) :: vl
        integer, dimension(1) :: vlw_shape__
        real(kind=kind(0.0D0)), dimension(vlw_shape__(1)) :: vlw
        real(kind=kind(0.0D0)) :: alpha
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: dsigma_shape__
        real(kind=kind(0.0D0)), dimension(dsigma_shape__(1)) :: dsigma
        integer, dimension(1) :: idx_shape__
        integer, dimension(idx_shape__(1)) :: idx
        integer, dimension(1) :: idxp_shape__
        integer, dimension(idxp_shape__(1)) :: idxp
        integer, dimension(1) :: idxq_shape__
        integer, dimension(idxq_shape__(1)) :: idxq
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer :: ldgnum
        real(kind=kind(0.0D0)) :: c
        real(kind=kind(0.0D0)) :: s
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasd7
        fw_iserr__ = -1
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasd7(icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl, vlw,
     & alpha, beta, dsigma, idx, idxp, idxq, perm, givptr, givcol, ldgco
     &l, givnum, ldgnum, c, s, info)
        fw_iserr__ = 0
      end subroutine dlasd7_c
      subroutine dlasd8_c(icompq, k, d_shape__, d, z_shape__, z, vf_shap
     &e__, vf, vl_shape__, vl, difl_shape__, difl, difr_shape__, difr, l
     &ddifr, dsigma_shape__, dsigma, work_shape__, work, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: k
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: vf_shape__
        real(kind=kind(0.0D0)), dimension(vf_shape__(1)) :: vf
        integer, dimension(1) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1)) :: vl
        integer, dimension(1) :: difl_shape__
        real(kind=kind(0.0D0)), dimension(difl_shape__(1)) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0D0)), dimension(difr_shape__(1), difr_shape__(
     &2)) :: difr
        integer :: lddifr
        integer, dimension(1) :: dsigma_shape__
        real(kind=kind(0.0D0)), dimension(dsigma_shape__(1)) :: dsigma
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasd8
        fw_iserr__ = -1
        if ((lddifr) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasd8(icompq, k, d, z, vf, vl, difl, difr, lddifr, dsigma,
     & work, info)
        fw_iserr__ = 0
      end subroutine dlasd8_c
      subroutine dlasda_c(icompq, smlsiz, n, sqre, d_shape__, d, e_shape
     &__, e, u_shape__, u, ldu, vt_shape__, vt, k_shape__, k, difl_shape
     &__, difl, difr_shape__, difr, z_shape__, z, poles_shape__, poles, 
     &givptr_shape__, givptr, givcol_shape__, givcol, ldgcol, perm_shape
     &__, perm, givnum_shape__, givnum, c_shape__, c, s_shape__, s, work
     &_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: smlsiz
        integer :: n
        integer :: sqre
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer, dimension(2) :: difl_shape__
        real(kind=kind(0.0D0)), dimension(difl_shape__(1), difl_shape__(
     &2)) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0D0)), dimension(difr_shape__(1), difr_shape__(
     &2)) :: difr
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0D0)), dimension(poles_shape__(1), poles_shape_
     &_(2)) :: poles
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: perm_shape__
        integer, dimension(perm_shape__(1), perm_shape__(2)) :: perm
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasda
        fw_iserr__ = -1
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difl                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (perm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("perm                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasda(icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k, difl, 
     &difr, z, poles, givptr, givcol, ldgcol, perm, givnum, c, s, work, 
     &iwork, info)
        fw_iserr__ = 0
      end subroutine dlasda_c
      subroutine dlasdq_c(uplo, sqre, n, ncvt, nru, ncc, d_shape__, d, e
     &_shape__, e, vt_shape__, vt, ldvt, u_shape__, u, ldu, c_shape__, c
     &, ldc, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: sqre
        integer :: n
        integer :: ncvt
        integer :: nru
        integer :: ncc
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer :: ldvt
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasdq
        fw_iserr__ = -1
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasdq(uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ld
     &u, c, ldc, work, info)
        fw_iserr__ = 0
      end subroutine dlasdq_c
      subroutine dlasdt_c(n, lvl, nd, inode_shape__, inode, ndiml_shape_
     &_, ndiml, ndimr_shape__, ndimr, msub, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: lvl
        integer :: nd
        integer, dimension(1) :: inode_shape__
        integer, dimension(inode_shape__(1)) :: inode
        integer, dimension(1) :: ndiml_shape__
        integer, dimension(ndiml_shape__(1)) :: ndiml
        integer, dimension(1) :: ndimr_shape__
        integer, dimension(ndimr_shape__(1)) :: ndimr
        integer :: msub
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasdt
        fw_iserr__ = -1
        call dlasdt(n, lvl, nd, inode, ndiml, ndimr, msub)
        fw_iserr__ = 0
      end subroutine dlasdt_c
      subroutine dlaset_c(uplo, m, n, alpha, beta, a_shape__, a, lda, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: m
        integer :: n
        real(kind=kind(0.0D0)) :: alpha
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaset
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaset(uplo, m, n, alpha, beta, a, lda)
        fw_iserr__ = 0
      end subroutine dlaset_c
      subroutine dlasq1_c(n, d_shape__, d, e_shape__, e, work_shape__, w
     &ork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasq1
        fw_iserr__ = -1
        call dlasq1(n, d, e, work, info)
        fw_iserr__ = 0
      end subroutine dlasq1_c
      subroutine dlasq2_c(n, z_shape__, z, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasq2
        fw_iserr__ = -1
        call dlasq2(n, z, info)
        fw_iserr__ = 0
      end subroutine dlasq2_c
      subroutine dlasq3_c(i0, n0, z_shape__, z, pp, dmin, sigma, desig, 
     &qmax, nfail, iter, ndiv, ieee, ttype, dmin1, dmin2, dn, dn1, dn2, 
     &g, tau, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i0
        integer :: n0
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer :: pp
        real(kind=kind(0.0D0)) :: dmin
        real(kind=kind(0.0D0)) :: sigma
        real(kind=kind(0.0D0)) :: desig
        real(kind=kind(0.0D0)) :: qmax
        integer :: nfail
        integer :: iter
        integer :: ndiv
        integer(kind=kind(0)) :: ieee
        integer :: ttype
        real(kind=kind(0.0D0)) :: dmin1
        real(kind=kind(0.0D0)) :: dmin2
        real(kind=kind(0.0D0)) :: dn
        real(kind=kind(0.0D0)) :: dn1
        real(kind=kind(0.0D0)) :: dn2
        real(kind=kind(0.0D0)) :: g
        real(kind=kind(0.0D0)) :: tau
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasq3
        fw_iserr__ = -1
        call dlasq3(i0, n0, z, pp, dmin, sigma, desig, qmax, nfail, iter
     &, ndiv, ieee, ttype, dmin1, dmin2, dn, dn1, dn2, g, tau)
        fw_iserr__ = 0
      end subroutine dlasq3_c
      subroutine dlasq4_c(i0, n0, z_shape__, z, pp, n0in, dmin, dmin1, d
     &min2, dn, dn1, dn2, tau, ttype, g, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i0
        integer :: n0
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer :: pp
        integer :: n0in
        real(kind=kind(0.0D0)) :: dmin
        real(kind=kind(0.0D0)) :: dmin1
        real(kind=kind(0.0D0)) :: dmin2
        real(kind=kind(0.0D0)) :: dn
        real(kind=kind(0.0D0)) :: dn1
        real(kind=kind(0.0D0)) :: dn2
        real(kind=kind(0.0D0)) :: tau
        integer :: ttype
        real(kind=kind(0.0D0)) :: g
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasq4
        fw_iserr__ = -1
        call dlasq4(i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn, dn1, dn
     &2, tau, ttype, g)
        fw_iserr__ = 0
      end subroutine dlasq4_c
      subroutine dlasq5_c(i0, n0, z_shape__, z, pp, tau, dmin, dmin1, dm
     &in2, dn, dnm1, dnm2, ieee, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i0
        integer :: n0
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer :: pp
        real(kind=kind(0.0D0)) :: tau
        real(kind=kind(0.0D0)) :: dmin
        real(kind=kind(0.0D0)) :: dmin1
        real(kind=kind(0.0D0)) :: dmin2
        real(kind=kind(0.0D0)) :: dn
        real(kind=kind(0.0D0)) :: dnm1
        real(kind=kind(0.0D0)) :: dnm2
        integer(kind=kind(0)) :: ieee
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasq5
        fw_iserr__ = -1
        call dlasq5(i0, n0, z, pp, tau, dmin, dmin1, dmin2, dn, dnm1, dn
     &m2, ieee)
        fw_iserr__ = 0
      end subroutine dlasq5_c
      subroutine dlasq6_c(i0, n0, z_shape__, z, pp, dmin, dmin1, dmin2, 
     &dn, dnm1, dnm2, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i0
        integer :: n0
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer :: pp
        real(kind=kind(0.0D0)) :: dmin
        real(kind=kind(0.0D0)) :: dmin1
        real(kind=kind(0.0D0)) :: dmin2
        real(kind=kind(0.0D0)) :: dn
        real(kind=kind(0.0D0)) :: dnm1
        real(kind=kind(0.0D0)) :: dnm2
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasq6
        fw_iserr__ = -1
        call dlasq6(i0, n0, z, pp, dmin, dmin1, dmin2, dn, dnm1, dnm2)
        fw_iserr__ = 0
      end subroutine dlasq6_c
      subroutine dlasr_c(side, pivot, direct, m, n, c_shape__, c, s_shap
     &e__, s, a_shape__, a, lda, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: pivot
        character(len=1, kind=kind('a')) :: direct
        integer :: m
        integer :: n
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasr(side, pivot, direct, m, n, c, s, a, lda)
        fw_iserr__ = 0
      end subroutine dlasr_c
      subroutine dlasrt_c(id, n, d_shape__, d, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: id
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasrt
        fw_iserr__ = -1
        call dlasrt(id, n, d, info)
        fw_iserr__ = 0
      end subroutine dlasrt_c
      subroutine dlassq_c(n, x_shape__, x, incx, scale, sumsq, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: scale
        real(kind=kind(0.0D0)) :: sumsq
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlassq
        fw_iserr__ = -1
        call dlassq(n, x, incx, scale, sumsq)
        fw_iserr__ = 0
      end subroutine dlassq_c
      subroutine dlasv2_c(f, g, h, ssmin, ssmax, snr, csr, snl, csl, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: f
        real(kind=kind(0.0D0)) :: g
        real(kind=kind(0.0D0)) :: h
        real(kind=kind(0.0D0)) :: ssmin
        real(kind=kind(0.0D0)) :: ssmax
        real(kind=kind(0.0D0)) :: snr
        real(kind=kind(0.0D0)) :: csr
        real(kind=kind(0.0D0)) :: snl
        real(kind=kind(0.0D0)) :: csl
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasv2
        fw_iserr__ = -1
        call dlasv2(f, g, h, ssmin, ssmax, snr, csr, snl, csl)
        fw_iserr__ = 0
      end subroutine dlasv2_c
      subroutine dlaswp_c(n, a_shape__, a, lda, k1, k2, ipiv_shape__, ip
     &iv, incx, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: k1
        integer :: k2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlaswp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlaswp(n, a, lda, k1, k2, ipiv, incx)
        fw_iserr__ = 0
      end subroutine dlaswp_c
      subroutine dlasy2_c(ltranl, ltranr, isgn, n1, n2, tl_shape__, tl, 
     &ldtl, tr_shape__, tr, ldtr, b_shape__, b, ldb, scale, x_shape__, x
     &, ldx, xnorm, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: ltranl
        integer(kind=kind(0)) :: ltranr
        integer :: isgn
        integer :: n1
        integer :: n2
        integer, dimension(2) :: tl_shape__
        real(kind=kind(0.0D0)), dimension(tl_shape__(1), tl_shape__(2)) 
     &:: tl
        integer :: ldtl
        integer, dimension(2) :: tr_shape__
        real(kind=kind(0.0D0)), dimension(tr_shape__(1), tr_shape__(2)) 
     &:: tr
        integer :: ldtr
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        real(kind=kind(0.0D0)) :: scale
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: xnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasy2
        fw_iserr__ = -1
        if ((ldtl) .ne. (tl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldtr) .ne. (tr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasy2(ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr, ldtr, b,
     & ldb, scale, x, ldx, xnorm, info)
        fw_iserr__ = 0
      end subroutine dlasy2_c
      subroutine dlasyf_c(uplo, n, nb, kb, a_shape__, a, lda, ipiv_shape
     &__, ipiv, w_shape__, w, ldw, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nb
        integer :: kb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1), w_shape__(2)) ::
     & w
        integer :: ldw
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlasyf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldw) .ne. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlasyf(uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)
        fw_iserr__ = 0
      end subroutine dlasyf_c
      subroutine dlat2s_c(uplo, n, a_shape__, a, lda, sa_shape__, sa, ld
     &sa, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: sa_shape__
        real(kind=kind(0.0)), dimension(sa_shape__(1), sa_shape__(2)) ::
     & sa
        integer :: ldsa
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlat2s
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldsa) .ne. (sa_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sa                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlat2s(uplo, n, a, lda, sa, ldsa, info)
        fw_iserr__ = 0
      end subroutine dlat2s_c
      subroutine dlatbs_c(uplo, trans, diag, normin, n, kd, ab_shape__, 
     &ab, ldab, x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0D0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0D0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlatbs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlatbs(uplo, trans, diag, normin, n, kd, ab, ldab, x, scale
     &, cnorm, info)
        fw_iserr__ = 0
      end subroutine dlatbs_c
      subroutine dlatdf_c(ijob, n, z_shape__, z, ldz, rhs_shape__, rhs, 
     &rdsum, rdscal, ipiv_shape__, ipiv, jpiv_shape__, jpiv, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: ijob
        integer :: n
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: rhs_shape__
        real(kind=kind(0.0D0)), dimension(rhs_shape__(1)) :: rhs
        real(kind=kind(0.0D0)) :: rdsum
        real(kind=kind(0.0D0)) :: rdscal
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlatdf
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlatdf(ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv, jpiv)
        fw_iserr__ = 0
      end subroutine dlatdf_c
      subroutine dlatps_c(uplo, trans, diag, normin, n, ap_shape__, ap, 
     &x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0D0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0D0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlatps
        fw_iserr__ = -1
        call dlatps(uplo, trans, diag, normin, n, ap, x, scale, cnorm, i
     &nfo)
        fw_iserr__ = 0
      end subroutine dlatps_c
      subroutine dlatrd_c(uplo, n, nb, a_shape__, a, lda, e_shape__, e, 
     &tau_shape__, tau, w_shape__, w, ldw, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1), w_shape__(2)) ::
     & w
        integer :: ldw
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlatrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldw) .ne. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlatrd(uplo, n, nb, a, lda, e, tau, w, ldw)
        fw_iserr__ = 0
      end subroutine dlatrd_c
      subroutine dlatrs_c(uplo, trans, diag, normin, n, a_shape__, a, ld
     &a, x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iserr__, fw
     &_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0D0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0D0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlatrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlatrs(uplo, trans, diag, normin, n, a, lda, x, scale, cnor
     &m, info)
        fw_iserr__ = 0
      end subroutine dlatrs_c
      subroutine dlatrz_c(m, n, l, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: l
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlatrz
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlatrz(m, n, l, a, lda, tau, work)
        fw_iserr__ = 0
      end subroutine dlatrz_c
      subroutine dlatzm_c(side, m, n, v_shape__, v, incv, tau, c1_shape_
     &_, c1, c2_shape__, c2, ldc, work_shape__, work, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1)) :: v
        integer :: incv
        real(kind=kind(0.0D0)) :: tau
        integer, dimension(2) :: c1_shape__
        real(kind=kind(0.0D0)), dimension(c1_shape__(1), c1_shape__(2)) 
     &:: c1
        integer, dimension(2) :: c2_shape__
        real(kind=kind(0.0D0)), dimension(c2_shape__(1), c2_shape__(2)) 
     &:: c2
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlatzm
        fw_iserr__ = -1
        if ((ldc) .ne. (c1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlatzm(side, m, n, v, incv, tau, c1, c2, ldc, work)
        fw_iserr__ = 0
      end subroutine dlatzm_c
      subroutine dlauu2_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlauu2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlauu2(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine dlauu2_c
      subroutine dlauum_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dlauum
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dlauum(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine dlauum_c
      subroutine dopgtr_c(uplo, n, ap_shape__, ap, tau_shape__, tau, q_s
     &hape__, q, ldq, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dopgtr
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dopgtr(uplo, n, ap, tau, q, ldq, work, info)
        fw_iserr__ = 0
      end subroutine dopgtr_c
      subroutine dopmtr_c(side, uplo, trans, m, n, ap_shape__, ap, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dopmtr
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dopmtr(side, uplo, trans, m, n, ap, tau, c, ldc, work, info
     &)
        fw_iserr__ = 0
      end subroutine dopmtr_c
      subroutine dorbdb_c(trans, signs, m, p, q, x11_shape__, x11, ldx11
     &, x12_shape__, x12, ldx12, x21_shape__, x21, ldx21, x22_shape__, x
     &22, ldx22, theta_shape__, theta, phi_shape__, phi, taup1_shape__, 
     &taup1, taup2_shape__, taup2, tauq1_shape__, tauq1, tauq2_shape__, 
     &tauq2, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: signs
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(2) :: x11_shape__
        real(kind=kind(0.0D0)), dimension(x11_shape__(1), x11_shape__(2)
     &) :: x11
        integer :: ldx11
        integer, dimension(2) :: x12_shape__
        real(kind=kind(0.0D0)), dimension(x12_shape__(1), x12_shape__(2)
     &) :: x12
        integer :: ldx12
        integer, dimension(2) :: x21_shape__
        real(kind=kind(0.0D0)), dimension(x21_shape__(1), x21_shape__(2)
     &) :: x21
        integer :: ldx21
        integer, dimension(2) :: x22_shape__
        real(kind=kind(0.0D0)), dimension(x22_shape__(1), x22_shape__(2)
     &) :: x22
        integer :: ldx22
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0D0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(1) :: phi_shape__
        real(kind=kind(0.0D0)), dimension(phi_shape__(1)) :: phi
        integer, dimension(1) :: taup1_shape__
        real(kind=kind(0.0D0)), dimension(taup1_shape__(1)) :: taup1
        integer, dimension(1) :: taup2_shape__
        real(kind=kind(0.0D0)), dimension(taup2_shape__(1)) :: taup2
        integer, dimension(1) :: tauq1_shape__
        real(kind=kind(0.0D0)), dimension(tauq1_shape__(1)) :: tauq1
        integer, dimension(1) :: tauq2_shape__
        real(kind=kind(0.0D0)), dimension(tauq2_shape__(1)) :: tauq2
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorbdb
        fw_iserr__ = -1
        if ((ldx11) .ne. (x11_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x11                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx12) .ne. (x12_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x12                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx21) .ne. (x21_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x21                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx22) .ne. (x22_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x22                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorbdb(trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, 
     &ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, l
     &work, info)
        fw_iserr__ = 0
      end subroutine dorbdb_c
      subroutine dorcsd_c(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m,
     & p, q, x11_shape__, x11, ldx11, x12_shape__, x12, ldx12, x21_shape
     &__, x21, ldx21, x22_shape__, x22, ldx22, theta_shape__, theta, u1_
     &shape__, u1, ldu1, u2_shape__, u2, ldu2, v1t_shape__, v1t, ldv1t, 
     &v2t_shape__, v2t, ldv2t, work_shape__, work, lwork, iwork_shape__,
     & iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu1
        character(len=1, kind=kind('a')) :: jobu2
        character(len=1, kind=kind('a')) :: jobv1t
        character(len=1, kind=kind('a')) :: jobv2t
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: signs
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(2) :: x11_shape__
        real(kind=kind(0.0D0)), dimension(x11_shape__(1), x11_shape__(2)
     &) :: x11
        integer :: ldx11
        integer, dimension(2) :: x12_shape__
        real(kind=kind(0.0D0)), dimension(x12_shape__(1), x12_shape__(2)
     &) :: x12
        integer :: ldx12
        integer, dimension(2) :: x21_shape__
        real(kind=kind(0.0D0)), dimension(x21_shape__(1), x21_shape__(2)
     &) :: x21
        integer :: ldx21
        integer, dimension(2) :: x22_shape__
        real(kind=kind(0.0D0)), dimension(x22_shape__(1), x22_shape__(2)
     &) :: x22
        integer :: ldx22
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0D0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(2) :: u1_shape__
        real(kind=kind(0.0D0)), dimension(u1_shape__(1), u1_shape__(2)) 
     &:: u1
        integer :: ldu1
        integer, dimension(2) :: u2_shape__
        real(kind=kind(0.0D0)), dimension(u2_shape__(1), u2_shape__(2)) 
     &:: u2
        integer :: ldu2
        integer, dimension(2) :: v1t_shape__
        real(kind=kind(0.0D0)), dimension(v1t_shape__(1), v1t_shape__(2)
     &) :: v1t
        integer :: ldv1t
        integer, dimension(2) :: v2t_shape__
        real(kind=kind(0.0D0)), dimension(v2t_shape__(1), v2t_shape__(2)
     &) :: v2t
        integer :: ldv2t
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorcsd
        fw_iserr__ = -1
        if ((ldx11) .ne. (x11_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x11                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx12) .ne. (x12_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x12                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx21) .ne. (x21_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x21                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx22) .ne. (x22_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x22                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu1) .ne. (u1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv1t) .ne. (v1t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v1t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv2t) .ne. (v2t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v2t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorcsd(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q,
     & x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, 
     &u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine dorcsd_c
      subroutine dorg2l_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorg2l
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorg2l(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine dorg2l_c
      subroutine dorg2r_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorg2r
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorg2r(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine dorg2r_c
      subroutine dorgbr_c(vect, m, n, k, a_shape__, a, lda, tau_shape__,
     & tau, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorgbr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorgbr(vect, m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dorgbr_c
      subroutine dorghr_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorghr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorghr(n, ilo, ihi, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dorghr_c
      subroutine dorgl2_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorgl2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorgl2(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine dorgl2_c
      subroutine dorglq_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorglq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorglq(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dorglq_c
      subroutine dorgql_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorgql
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorgql(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dorgql_c
      subroutine dorgqr_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorgqr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorgqr(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dorgqr_c
      subroutine dorgr2_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorgr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorgr2(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine dorgr2_c
      subroutine dorgrq_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorgrq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorgrq(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dorgrq_c
      subroutine dorgtr_c(uplo, n, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorgtr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorgtr(uplo, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dorgtr_c
      subroutine dorm2l_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorm2l
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorm2l(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine dorm2l_c
      subroutine dorm2r_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorm2r
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorm2r(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine dorm2r_c
      subroutine dormbr_c(vect, side, trans, m, n, k, a_shape__, a, lda,
     & tau_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dormbr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dormbr(vect, side, trans, m, n, k, a, lda, tau, c, ldc, wor
     &k, lwork, info)
        fw_iserr__ = 0
      end subroutine dormbr_c
      subroutine dormhr_c(side, trans, m, n, ilo, ihi, a_shape__, a, lda
     &, tau_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, 
     &info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dormhr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dormhr(side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, wo
     &rk, lwork, info)
        fw_iserr__ = 0
      end subroutine dormhr_c
      subroutine dorml2_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dorml2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dorml2(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine dorml2_c
      subroutine dormlq_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dormlq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dormlq(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine dormlq_c
      subroutine dormql_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dormql
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dormql(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine dormql_c
      subroutine dormqr_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dormqr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dormqr(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine dormqr_c
      subroutine dormr2_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dormr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dormr2(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine dormr2_c
      subroutine dormr3_c(side, trans, m, n, k, l, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dormr3
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dormr3(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, 
     &info)
        fw_iserr__ = 0
      end subroutine dormr3_c
      subroutine dormrq_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dormrq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dormrq(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine dormrq_c
      subroutine dormrz_c(side, trans, m, n, k, l, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dormrz
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dormrz(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, 
     &lwork, info)
        fw_iserr__ = 0
      end subroutine dormrz_c
      subroutine dormtr_c(side, uplo, trans, m, n, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dormtr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dormtr(side, uplo, trans, m, n, a, lda, tau, c, ldc, work, 
     &lwork, info)
        fw_iserr__ = 0
      end subroutine dormtr_c
      subroutine dpbcon_c(uplo, n, kd, ab_shape__, ab, ldab, anorm, rcon
     &d, work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpbcon(uplo, n, kd, ab, ldab, anorm, rcond, work, iwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine dpbcon_c
      subroutine dpbequ_c(uplo, n, kd, ab_shape__, ab, ldab, s_shape__, 
     &s, scond, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpbequ
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpbequ(uplo, n, kd, ab, ldab, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine dpbequ_c
      subroutine dpbrfs_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, afb_s
     &hape__, afb, ldafb, b_shape__, b, ldb, x_shape__, x, ldx, ferr_sha
     &pe__, ferr, berr_shape__, berr, work_shape__, work, iwork_shape__,
     & iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0D0)), dimension(afb_shape__(1), afb_shape__(2)
     &) :: afb
        integer :: ldafb
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpbrfs(uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, 
     &ldx, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dpbrfs_c
      subroutine dpbstf_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpbstf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpbstf(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine dpbstf_c
      subroutine dpbsv_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, b_shap
     &e__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpbsv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpbsv(uplo, n, kd, nrhs, ab, ldab, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dpbsv_c
      subroutine dpbsvx_c(fact, uplo, n, kd, nrhs, ab_shape__, ab, ldab,
     & afb_shape__, afb, ldafb, equed, s_shape__, s, b_shape__, b, ldb, 
     &x_shape__, x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, 
     &work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0D0)), dimension(afb_shape__(1), afb_shape__(2)
     &) :: afb
        integer :: ldafb
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpbsvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpbsvx(fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed
     &, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dpbsvx_c
      subroutine dpbtf2_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpbtf2
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpbtf2(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine dpbtf2_c
      subroutine dpbtrf_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpbtrf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpbtrf(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine dpbtrf_c
      subroutine dpbtrs_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, b_sha
     &pe__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpbtrs(uplo, n, kd, nrhs, ab, ldab, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dpbtrs_c
      subroutine dpftrf_c(transr, uplo, n, a_shape__, a, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpftrf
        fw_iserr__ = -1
        call dpftrf(transr, uplo, n, a, info)
        fw_iserr__ = 0
      end subroutine dpftrf_c
      subroutine dpftri_c(transr, uplo, n, a_shape__, a, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpftri
        fw_iserr__ = -1
        call dpftri(transr, uplo, n, a, info)
        fw_iserr__ = 0
      end subroutine dpftri_c
      subroutine dpftrs_c(transr, uplo, n, nrhs, a_shape__, a, b_shape__
     &, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1)) :: a
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpftrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpftrs(transr, uplo, n, nrhs, a, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dpftrs_c
      subroutine dpocon_c(uplo, n, a_shape__, a, lda, anorm, rcond, work
     &_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpocon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpocon(uplo, n, a, lda, anorm, rcond, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dpocon_c
      subroutine dpoequ_c(n, a_shape__, a, lda, s_shape__, s, scond, ama
     &x, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpoequ
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpoequ(n, a, lda, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine dpoequ_c
      subroutine dpoequb_c(n, a_shape__, a, lda, s_shape__, s, scond, am
     &ax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpoequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpoequb(n, a, lda, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine dpoequb_c
      subroutine dporfs_c(uplo, n, nrhs, a_shape__, a, lda, af_shape__, 
     &af, ldaf, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr
     &, berr_shape__, berr, work_shape__, work, iwork_shape__, iwork, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dporfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dporfs(uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, fer
     &r, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dporfs_c
      subroutine dporfsx_c(uplo, equed, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, s_shape__, s, b_shape__, b, ldb, x_shape__, x, l
     &dx, rcond, berr_shape__, berr, n_err_bnds, err_bnds_norm_shape__, 
     &err_bnds_norm, err_bnds_comp_shape__, err_bnds_comp, nparams, para
     &ms_shape__, params, work_shape__, work, iwork_shape__, iwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dporfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dporfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, 
     &x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, npa
     &rams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dporfsx_c
      subroutine dposv_c(uplo, n, nrhs, a_shape__, a, lda, b_shape__, b,
     & ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dposv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dposv(uplo, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dposv_c
      subroutine dposvx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sha
     &pe__, af, ldaf, equed, s_shape__, s, b_shape__, b, ldb, x_shape__,
     & x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape
     &__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dposvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dposvx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, 
     &ldb, x, ldx, rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dposvx_c
      subroutine dposvxx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, equed, s_shape__, s, b_shape__, b, ldb, x_shape__
     &, x, ldx, rcond, rpvgrw, berr_shape__, berr, n_err_bnds, err_bnds_
     &norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bnds_comp,
     & nparams, params_shape__, params, work_shape__, work, iwork_shape_
     &_, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        real(kind=kind(0.0D0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dposvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dposvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b,
     & ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_
     &bnds_comp, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dposvxx_c
      subroutine dpotf2_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpotf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpotf2(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine dpotf2_c
      subroutine dpotrf_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpotrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpotrf(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine dpotrf_c
      subroutine dpotri_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpotri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpotri(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine dpotri_c
      subroutine dpotrs_c(uplo, n, nrhs, a_shape__, a, lda, b_shape__, b
     &, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpotrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpotrs(uplo, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dpotrs_c
      subroutine dppcon_c(uplo, n, ap_shape__, ap, anorm, rcond, work_sh
     &ape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dppcon
        fw_iserr__ = -1
        call dppcon(uplo, n, ap, anorm, rcond, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dppcon_c
      subroutine dppequ_c(uplo, n, ap_shape__, ap, s_shape__, s, scond, 
     &amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dppequ
        fw_iserr__ = -1
        call dppequ(uplo, n, ap, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine dppequ_c
      subroutine dpprfs_c(uplo, n, nrhs, ap_shape__, ap, afp_shape__, af
     &p, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_
     &shape__, berr, work_shape__, work, iwork_shape__, iwork, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        real(kind=kind(0.0D0)), dimension(afp_shape__(1)) :: afp
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpprfs(uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, 
     &work, iwork, info)
        fw_iserr__ = 0
      end subroutine dpprfs_c
      subroutine dppsv_c(uplo, n, nrhs, ap_shape__, ap, b_shape__, b, ld
     &b, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dppsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dppsv(uplo, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dppsv_c
      subroutine dppsvx_c(fact, uplo, n, nrhs, ap_shape__, ap, afp_shape
     &__, afp, equed, s_shape__, s, b_shape__, b, ldb, x_shape__, x, ldx
     &, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, wor
     &k, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        real(kind=kind(0.0D0)), dimension(afp_shape__(1)) :: afp
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dppsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dppsvx(fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, l
     &dx, rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dppsvx_c
      subroutine dpptrf_c(uplo, n, ap_shape__, ap, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpptrf
        fw_iserr__ = -1
        call dpptrf(uplo, n, ap, info)
        fw_iserr__ = 0
      end subroutine dpptrf_c
      subroutine dpptri_c(uplo, n, ap_shape__, ap, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpptri
        fw_iserr__ = -1
        call dpptri(uplo, n, ap, info)
        fw_iserr__ = 0
      end subroutine dpptri_c
      subroutine dpptrs_c(uplo, n, nrhs, ap_shape__, ap, b_shape__, b, l
     &db, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpptrs(uplo, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dpptrs_c
      subroutine dpstf2_c(uplo, n, a_shape__, a, lda, piv_shape__, piv, 
     &rank, tol, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: piv_shape__
        integer, dimension(piv_shape__(1)) :: piv
        integer :: rank
        real(kind=kind(0.0D0)) :: tol
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpstf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (piv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("piv                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2*n) .lt. 0 .or. (2*n) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpstf2(uplo, n, a, lda, piv, rank, tol, work, info)
        fw_iserr__ = 0
      end subroutine dpstf2_c
      subroutine dpstrf_c(uplo, n, a_shape__, a, lda, piv_shape__, piv, 
     &rank, tol, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: piv_shape__
        integer, dimension(piv_shape__(1)) :: piv
        integer :: rank
        real(kind=kind(0.0D0)) :: tol
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpstrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (piv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("piv                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2*n) .lt. 0 .or. (2*n) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpstrf(uplo, n, a, lda, piv, rank, tol, work, info)
        fw_iserr__ = 0
      end subroutine dpstrf_c
      subroutine dptcon_c(n, d_shape__, d, e_shape__, e, anorm, rcond, w
     &ork_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dptcon
        fw_iserr__ = -1
        call dptcon(n, d, e, anorm, rcond, work, info)
        fw_iserr__ = 0
      end subroutine dptcon_c
      subroutine dpteqr_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpteqr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpteqr(compz, n, d, e, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine dpteqr_c
      subroutine dptrfs_c(n, nrhs, d_shape__, d, e_shape__, e, df_shape_
     &_, df, ef_shape__, ef, b_shape__, b, ldb, x_shape__, x, ldx, ferr_
     &shape__, ferr, berr_shape__, berr, work_shape__, work, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0D0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: ef_shape__
        real(kind=kind(0.0D0)), dimension(ef_shape__(1)) :: ef
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dptrfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dptrfs(n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, w
     &ork, info)
        fw_iserr__ = 0
      end subroutine dptrfs_c
      subroutine dptsv_c(n, nrhs, d_shape__, d, e_shape__, e, b_shape__,
     & b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dptsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dptsv(n, nrhs, d, e, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dptsv_c
      subroutine dptsvx_c(fact, n, nrhs, d_shape__, d, e_shape__, e, df_
     &shape__, df, ef_shape__, ef, b_shape__, b, ldb, x_shape__, x, ldx,
     & rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0D0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: ef_shape__
        real(kind=kind(0.0D0)), dimension(ef_shape__(1)) :: ef
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dptsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, 
     &ferr, berr, work, info)
        fw_iserr__ = 0
      end subroutine dptsvx_c
      subroutine dpttrf_c(n, d_shape__, d, e_shape__, e, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpttrf
        fw_iserr__ = -1
        call dpttrf(n, d, e, info)
        fw_iserr__ = 0
      end subroutine dpttrf_c
      subroutine dpttrs_c(n, nrhs, d_shape__, d, e_shape__, e, b_shape__
     &, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dpttrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dpttrs(n, nrhs, d, e, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dpttrs_c
      subroutine dptts2_c(n, nrhs, d_shape__, d, e_shape__, e, b_shape__
     &, b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dptts2
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dptts2(n, nrhs, d, e, b, ldb)
        fw_iserr__ = 0
      end subroutine dptts2_c
      subroutine drscl_c(n, sa, sx_shape__, sx, incx, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0D0)) :: sa
        integer, dimension(1) :: sx_shape__
        real(kind=kind(0.0D0)), dimension(sx_shape__(1)) :: sx
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external drscl
        fw_iserr__ = -1
        call drscl(n, sa, sx, incx)
        fw_iserr__ = 0
      end subroutine drscl_c
      subroutine dsbev_c(jobz, uplo, n, kd, ab_shape__, ab, ldab, w_shap
     &e__, w, z_shape__, z, ldz, work_shape__, work, info, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsbev
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsbev(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine dsbev_c
      subroutine dsbevd_c(jobz, uplo, n, kd, ab_shape__, ab, ldab, w_sha
     &pe__, w, z_shape__, z, ldz, work_shape__, work, lwork, iwork_shape
     &__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsbevd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsbevd(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork,
     & iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine dsbevd_c
      subroutine dsbevx_c(jobz, range, uplo, n, kd, ab_shape__, ab, ldab
     &, q_shape__, q, ldq, vl, vu, il, iu, abstol, m, w_shape__, w, z_sh
     &ape__, z, ldz, work_shape__, work, iwork_shape__, iwork, ifail_sha
     &pe__, ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsbevx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsbevx(jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, 
     &il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine dsbevx_c
      subroutine dsbgst_c(vect, uplo, n, ka, kb, ab_shape__, ab, ldab, b
     &b_shape__, bb, ldbb, x_shape__, x, ldx, work_shape__, work, info, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        real(kind=kind(0.0D0)), dimension(bb_shape__(1), bb_shape__(2)) 
     &:: bb
        integer :: ldbb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsbgst
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsbgst(vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, w
     &ork, info)
        fw_iserr__ = 0
      end subroutine dsbgst_c
      subroutine dsbgv_c(jobz, uplo, n, ka, kb, ab_shape__, ab, ldab, bb
     &_shape__, bb, ldbb, w_shape__, w, z_shape__, z, ldz, work_shape__,
     & work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        real(kind=kind(0.0D0)), dimension(bb_shape__(1), bb_shape__(2)) 
     &:: bb
        integer :: ldbb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsbgv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsbgv(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz,
     & work, info)
        fw_iserr__ = 0
      end subroutine dsbgv_c
      subroutine dsbgvd_c(jobz, uplo, n, ka, kb, ab_shape__, ab, ldab, b
     &b_shape__, bb, ldbb, w_shape__, w, z_shape__, z, ldz, work_shape__
     &, work, lwork, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        real(kind=kind(0.0D0)), dimension(bb_shape__(1), bb_shape__(2)) 
     &:: bb
        integer :: ldbb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsbgvd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsbgvd(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz
     &, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine dsbgvd_c
      subroutine dsbgvx_c(jobz, range, uplo, n, ka, kb, ab_shape__, ab, 
     &ldab, bb_shape__, bb, ldbb, q_shape__, q, ldq, vl, vu, il, iu, abs
     &tol, m, w_shape__, w, z_shape__, z, ldz, work_shape__, work, iwork
     &_shape__, iwork, ifail_shape__, ifail, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        real(kind=kind(0.0D0)), dimension(bb_shape__(1), bb_shape__(2)) 
     &:: bb
        integer :: ldbb
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsbgvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsbgvx(jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q,
     & ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, in
     &fo)
        fw_iserr__ = 0
      end subroutine dsbgvx_c
      subroutine dsbtrd_c(vect, uplo, n, kd, ab_shape__, ab, ldab, d_sha
     &pe__, d, e_shape__, e, q_shape__, q, ldq, work_shape__, work, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsbtrd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsbtrd(vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine dsbtrd_c
      subroutine dsfrk_c(transr, uplo, trans, n, k, alpha, a_shape__, a,
     & lda, beta, c_shape__, c, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: k
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsfrk
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsfrk(transr, uplo, trans, n, k, alpha, a, lda, beta, c)
        fw_iserr__ = 0
      end subroutine dsfrk_c
      subroutine dsgesv_c(n, nrhs, a_shape__, a, lda, ipiv_shape__, ipiv
     &, b_shape__, b, ldb, x_shape__, x, ldx, work_shape__, work, swork_
     &shape__, swork, iter, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(2) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1), work_shape__(
     &2)) :: work
        integer, dimension(1) :: swork_shape__
        real(kind=kind(0.0)), dimension(swork_shape__(1)) :: swork
        integer :: iter
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsgesv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsgesv(n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, 
     &iter, info)
        fw_iserr__ = 0
      end subroutine dsgesv_c
      subroutine dspcon_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, a
     &norm, rcond, work_shape__, work, iwork_shape__, iwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dspcon
        fw_iserr__ = -1
        call dspcon(uplo, n, ap, ipiv, anorm, rcond, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dspcon_c
      subroutine dspev_c(jobz, uplo, n, ap_shape__, ap, w_shape__, w, z_
     &shape__, z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dspev
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dspev(jobz, uplo, n, ap, w, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine dspev_c
      subroutine dspevd_c(jobz, uplo, n, ap_shape__, ap, w_shape__, w, z
     &_shape__, z, ldz, work_shape__, work, lwork, iwork_shape__, iwork,
     & liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dspevd
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dspevd(jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, li
     &work, info)
        fw_iserr__ = 0
      end subroutine dspevd_c
      subroutine dspevx_c(jobz, range, uplo, n, ap_shape__, ap, vl, vu, 
     &il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, work_shape__, 
     &work, iwork_shape__, iwork, ifail_shape__, ifail, info, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dspevx
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dspevx(jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m,
     & w, z, ldz, work, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine dspevx_c
      subroutine dspgst_c(itype, uplo, n, ap_shape__, ap, bp_shape__, bp
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        real(kind=kind(0.0D0)), dimension(bp_shape__(1)) :: bp
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dspgst
        fw_iserr__ = -1
        call dspgst(itype, uplo, n, ap, bp, info)
        fw_iserr__ = 0
      end subroutine dspgst_c
      subroutine dspgv_c(itype, jobz, uplo, n, ap_shape__, ap, bp_shape_
     &_, bp, w_shape__, w, z_shape__, z, ldz, work_shape__, work, info, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        real(kind=kind(0.0D0)), dimension(bp_shape__(1)) :: bp
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dspgv
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dspgv(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine dspgv_c
      subroutine dspgvd_c(itype, jobz, uplo, n, ap_shape__, ap, bp_shape
     &__, bp, w_shape__, w, z_shape__, z, ldz, work_shape__, work, lwork
     &, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        real(kind=kind(0.0D0)), dimension(bp_shape__(1)) :: bp
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dspgvd
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dspgvd(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork
     &, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine dspgvd_c
      subroutine dspgvx_c(itype, jobz, range, uplo, n, ap_shape__, ap, b
     &p_shape__, bp, vl, vu, il, iu, abstol, m, w_shape__, w, z_shape__,
     & z, ldz, work_shape__, work, iwork_shape__, iwork, ifail_shape__, 
     &ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        real(kind=kind(0.0D0)), dimension(bp_shape__(1)) :: bp
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dspgvx
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dspgvx(itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu,
     & abstol, m, w, z, ldz, work, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine dspgvx_c
      subroutine dsposv_c(uplo, n, nrhs, a_shape__, a, lda, b_shape__, b
     &, ldb, x_shape__, x, ldx, work_shape__, work, swork_shape__, swork
     &, iter, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(2) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1), work_shape__(
     &2)) :: work
        integer, dimension(1) :: swork_shape__
        real(kind=kind(0.0)), dimension(swork_shape__(1)) :: swork
        integer :: iter
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsposv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsposv(uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, 
     &iter, info)
        fw_iserr__ = 0
      end subroutine dsposv_c
      subroutine dsprfs_c(uplo, n, nrhs, ap_shape__, ap, afp_shape__, af
     &p, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx, ferr_
     &shape__, ferr, berr_shape__, berr, work_shape__, work, iwork_shape
     &__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        real(kind=kind(0.0D0)), dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsprfs(uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, 
     &berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dsprfs_c
      subroutine dspsv_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, ip
     &iv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dspsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dspsv(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dspsv_c
      subroutine dspsvx_c(fact, uplo, n, nrhs, ap_shape__, ap, afp_shape
     &__, afp, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx,
     & rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work
     &, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        real(kind=kind(0.0D0)), dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dspsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dspsvx(fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, 
     &rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dspsvx_c
      subroutine dsptrd_c(uplo, n, ap_shape__, ap, d_shape__, d, e_shape
     &__, e, tau_shape__, tau, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsptrd
        fw_iserr__ = -1
        call dsptrd(uplo, n, ap, d, e, tau, info)
        fw_iserr__ = 0
      end subroutine dsptrd_c
      subroutine dsptrf_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsptrf
        fw_iserr__ = -1
        call dsptrf(uplo, n, ap, ipiv, info)
        fw_iserr__ = 0
      end subroutine dsptrf_c
      subroutine dsptri_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, w
     &ork_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsptri
        fw_iserr__ = -1
        call dsptri(uplo, n, ap, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine dsptri_c
      subroutine dsptrs_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, i
     &piv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsptrs(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dsptrs_c
      subroutine dstebz_c(range, order, n, vl, vu, il, iu, abstol, d_sha
     &pe__, d, e_shape__, e, m, nsplit, w_shape__, w, iblock_shape__, ib
     &lock, isplit_shape__, isplit, work_shape__, work, iwork_shape__, i
     &work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: order
        integer :: n
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer :: m
        integer :: nsplit
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dstebz
        fw_iserr__ = -1
        call dstebz(range, order, n, vl, vu, il, iu, abstol, d, e, m, ns
     &plit, w, iblock, isplit, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dstebz_c
      subroutine dstedc_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, lwork, iwork_shape__, iwork, liwork
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dstedc
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dstedc(compz, n, d, e, z, ldz, work, lwork, iwork, liwork, 
     &info)
        fw_iserr__ = 0
      end subroutine dstedc_c
      subroutine dstegr_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, isuppz_s
     &hape__, isuppz, work_shape__, work, lwork, iwork_shape__, iwork, l
     &iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dstegr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dstegr(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, 
     &z, ldz, isuppz, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine dstegr_c
      subroutine dstein_c(n, d_shape__, d, e_shape__, e, m, w_shape__, w
     &, iblock_shape__, iblock, isplit_shape__, isplit, z_shape__, z, ld
     &z, work_shape__, work, iwork_shape__, iwork, ifail_shape__, ifail,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dstein
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dstein(n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, 
     &ifail, info)
        fw_iserr__ = 0
      end subroutine dstein_c
      subroutine dstemr_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, m, w_shape__, w, z_shape__, z, ldz, nzc, isuppz_shap
     &e__, isuppz, tryrac, work_shape__, work, lwork, iwork_shape__, iwo
     &rk, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer :: nzc
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer(kind=kind(0)) :: tryrac
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dstemr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dstemr(jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, 
     &nzc, isuppz, tryrac, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine dstemr_c
      subroutine dsteqr_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsteqr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsteqr(compz, n, d, e, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine dsteqr_c
      subroutine dsterf_c(n, d_shape__, d, e_shape__, e, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsterf
        fw_iserr__ = -1
        call dsterf(n, d, e, info)
        fw_iserr__ = 0
      end subroutine dsterf_c
      subroutine dstev_c(jobz, n, d_shape__, d, e_shape__, e, z_shape__,
     & z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dstev
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dstev(jobz, n, d, e, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine dstev_c
      subroutine dstevd_c(jobz, n, d_shape__, d, e_shape__, e, z_shape__
     &, z, ldz, work_shape__, work, lwork, iwork_shape__, iwork, liwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dstevd
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dstevd(jobz, n, d, e, z, ldz, work, lwork, iwork, liwork, i
     &nfo)
        fw_iserr__ = 0
      end subroutine dstevd_c
      subroutine dstevr_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, isuppz_s
     &hape__, isuppz, work_shape__, work, lwork, iwork_shape__, iwork, l
     &iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dstevr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dstevr(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, 
     &z, ldz, isuppz, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine dstevr_c
      subroutine dstevx_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, work_sha
     &pe__, work, iwork_shape__, iwork, ifail_shape__, ifail, info, fw_i
     &serr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dstevx
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dstevx(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, 
     &z, ldz, work, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine dstevx_c
      subroutine dsycon_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, anorm, rcond, work_shape__, work, iwork_shape__, iwork, info, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsycon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsycon(uplo, n, a, lda, ipiv, anorm, rcond, work, iwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine dsycon_c
      subroutine dsyconv_c(uplo, way, n, a_shape__, a, lda, ipiv_shape__
     &, ipiv, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: way
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsyconv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsyconv(uplo, way, n, a, lda, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine dsyconv_c
      subroutine dsyequb_c(uplo, n, a_shape__, a, lda, s_shape__, s, sco
     &nd, amax, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsyequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsyequb(uplo, n, a, lda, s, scond, amax, work, info)
        fw_iserr__ = 0
      end subroutine dsyequb_c
      subroutine dsyev_c(jobz, uplo, n, a_shape__, a, lda, w_shape__, w,
     & work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsyev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsyev(jobz, uplo, n, a, lda, w, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dsyev_c
      subroutine dsyevd_c(jobz, uplo, n, a_shape__, a, lda, w_shape__, w
     &, work_shape__, work, lwork, iwork_shape__, iwork, liwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsyevd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsyevd(jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork
     &, info)
        fw_iserr__ = 0
      end subroutine dsyevd_c
      subroutine dsyevr_c(jobz, range, uplo, n, a_shape__, a, lda, vl, v
     &u, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, isuppz_shap
     &e__, isuppz, work_shape__, work, lwork, iwork_shape__, iwork, liwo
     &rk, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsyevr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsyevr(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol
     &, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine dsyevr_c
      subroutine dsyevx_c(jobz, range, uplo, n, a_shape__, a, lda, vl, v
     &u, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, work_shape_
     &_, work, lwork, iwork_shape__, iwork, ifail_shape__, ifail, info, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsyevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsyevx(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol
     &, m, w, z, ldz, work, lwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine dsyevx_c
      subroutine dsygs2_c(itype, uplo, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsygs2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsygs2(itype, uplo, n, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dsygs2_c
      subroutine dsygst_c(itype, uplo, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsygst
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsygst(itype, uplo, n, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dsygst_c
      subroutine dsygv_c(itype, jobz, uplo, n, a_shape__, a, lda, b_shap
     &e__, b, ldb, w_shape__, w, work_shape__, work, lwork, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsygv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsygv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork,
     & info)
        fw_iserr__ = 0
      end subroutine dsygv_c
      subroutine dsygvd_c(itype, jobz, uplo, n, a_shape__, a, lda, b_sha
     &pe__, b, ldb, w_shape__, w, work_shape__, work, lwork, iwork_shape
     &__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsygvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsygvd(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork
     &, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine dsygvd_c
      subroutine dsygvx_c(itype, jobz, range, uplo, n, a_shape__, a, lda
     &, b_shape__, b, ldb, vl, vu, il, iu, abstol, m, w_shape__, w, z_sh
     &ape__, z, ldz, work_shape__, work, lwork, iwork_shape__, iwork, if
     &ail_shape__, ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsygvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsygvx(itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu,
     & il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine dsygvx_c
      subroutine dsyrfs_c(uplo, n, nrhs, a_shape__, a, lda, af_shape__, 
     &af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx
     &, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, iwor
     &k_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsyrfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsyrfs(uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ld
     &x, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dsyrfs_c
      subroutine dsyrfsx_c(uplo, equed, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, ipiv_shape__, ipiv, s_shape__, s, b_shape__, b, 
     &ldb, x_shape__, x, ldx, rcond, berr_shape__, berr, n_err_bnds, err
     &_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bnds
     &_comp, nparams, params_shape__, params, work_shape__, work, iwork_
     &shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsyrfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsyrfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b,
     & ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_com
     &p, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dsyrfsx_c
      subroutine dsysv_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__,
     & ipiv, b_shape__, b, ldb, work_shape__, work, lwork, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsysv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsysv(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine dsysv_c
      subroutine dsysvx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sha
     &pe__, af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, 
     &x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape_
     &_, work, lwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsysvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsysvx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     & x, ldx, rcond, ferr, berr, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine dsysvx_c
      subroutine dsysvxx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, ipiv_shape__, ipiv, equed, s_shape__, s, b_shape_
     &_, b, ldb, x_shape__, x, ldx, rcond, rpvgrw, berr_shape__, berr, n
     &_err_bnds, err_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_sha
     &pe__, err_bnds_comp, nparams, params_shape__, params, work_shape__
     &, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0D0)), dimension(af_shape__(1), af_shape__(2)) 
     &:: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        real(kind=kind(0.0D0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsysvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsysvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed,
     & s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm
     &, err_bnds_comp, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dsysvxx_c
      subroutine dsyswapr_c(uplo, n, a_shape__, a, i1, i2, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: i1
        integer :: i2
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsyswapr
        fw_iserr__ = -1
        if ((n) .ne. (a_shape__(1)) .or. (n) .lt. 0 .or. (n) .gt. (a_sha
     &pe__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsyswapr(uplo, n, a, i1, i2)
        fw_iserr__ = 0
      end subroutine dsyswapr_c
      subroutine dsytd2_c(uplo, n, a_shape__, a, lda, d_shape__, d, e_sh
     &ape__, e, tau_shape__, tau, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsytd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsytd2(uplo, n, a, lda, d, e, tau, info)
        fw_iserr__ = 0
      end subroutine dsytd2_c
      subroutine dsytf2_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsytf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsytf2(uplo, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine dsytf2_c
      subroutine dsytrd_c(uplo, n, a_shape__, a, lda, d_shape__, d, e_sh
     &ape__, e, tau_shape__, tau, work_shape__, work, lwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsytrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsytrd(uplo, n, a, lda, d, e, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dsytrd_c
      subroutine dsytrf_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsytrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsytrf(uplo, n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dsytrf_c
      subroutine dsytri_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsytri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsytri(uplo, n, a, lda, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine dsytri_c
      subroutine dsytri2_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipi
     &v, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsytri2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsytri2(uplo, n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dsytri2_c
      subroutine dsytri2x_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ip
     &iv, work_shape__, work, nb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1), work_shape__(
     &2)) :: work
        integer :: nb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsytri2x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n+nb+1) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsytri2x(uplo, n, a, lda, ipiv, work, nb, info)
        fw_iserr__ = 0
      end subroutine dsytri2x_c
      subroutine dsytrs_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__
     &, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsytrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsytrs(uplo, n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dsytrs_c
      subroutine dsytrs2_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape_
     &_, ipiv, b_shape__, b, ldb, work_shape__, work, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dsytrs2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dsytrs2(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, info)
        fw_iserr__ = 0
      end subroutine dsytrs2_c
      subroutine dtbcon_c(norm, uplo, diag, n, kd, ab_shape__, ab, ldab,
     & rcond, work_shape__, work, iwork_shape__, iwork, info, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtbcon(norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwor
     &k, info)
        fw_iserr__ = 0
      end subroutine dtbcon_c
      subroutine dtbrfs_c(uplo, trans, diag, n, kd, nrhs, ab_shape__, ab
     &, ldab, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, 
     &berr_shape__, berr, work_shape__, work, iwork_shape__, iwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtbrfs(uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x,
     & ldx, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dtbrfs_c
      subroutine dtbtrs_c(uplo, trans, diag, n, kd, nrhs, ab_shape__, ab
     &, ldab, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0D0)), dimension(ab_shape__(1), ab_shape__(2)) 
     &:: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtbtrs(uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, in
     &fo)
        fw_iserr__ = 0
      end subroutine dtbtrs_c
      subroutine dtfsm_c(transr, side, uplo, trans, diag, m, n, alpha, a
     &_shape__, a, b_shape__, b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: m
        integer :: n
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1)) :: a
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtfsm
        fw_iserr__ = -1
        if (((ldb-1) - (0) + 1) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtfsm(transr, side, uplo, trans, diag, m, n, alpha, a, b, l
     &db)
        fw_iserr__ = 0
      end subroutine dtfsm_c
      subroutine dtftri_c(transr, uplo, diag, n, a_shape__, a, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtftri
        fw_iserr__ = -1
        call dtftri(transr, uplo, diag, n, a, info)
        fw_iserr__ = 0
      end subroutine dtftri_c
      subroutine dtfttp_c(transr, uplo, n, arf_shape__, arf, ap_shape__,
     & ap, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: arf_shape__
        real(kind=kind(0.0D0)), dimension(arf_shape__(1)) :: arf
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtfttp
        fw_iserr__ = -1
        call dtfttp(transr, uplo, n, arf, ap, info)
        fw_iserr__ = 0
      end subroutine dtfttp_c
      subroutine dtfttr_c(transr, uplo, n, arf_shape__, arf, a_shape__, 
     &a, lda, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: arf_shape__
        real(kind=kind(0.0D0)), dimension(arf_shape__(1)) :: arf
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtfttr
        fw_iserr__ = -1
        if (((lda-1) - (0) + 1) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtfttr(transr, uplo, n, arf, a, lda, info)
        fw_iserr__ = 0
      end subroutine dtfttr_c
      subroutine dtgevc_c(side, howmny, select_shape__, select, n, s_sha
     &pe__, s, lds, p_shape__, p, ldp, vl_shape__, vl, ldvl, vr_shape__,
     & vr, ldvr, mm, m, work_shape__, work, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1), s_shape__(2)) ::
     & s
        integer :: lds
        integer, dimension(2) :: p_shape__
        real(kind=kind(0.0D0)), dimension(p_shape__(1), p_shape__(2)) ::
     & p
        integer :: ldp
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1), vl_shape__(2)) 
     &:: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1), vr_shape__(2)) 
     &:: vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtgevc
        fw_iserr__ = -1
        if ((lds) .ne. (s_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("s                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldp) .ne. (p_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("p                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtgevc(side, howmny, select, n, s, lds, p, ldp, vl, ldvl, v
     &r, ldvr, mm, m, work, info)
        fw_iserr__ = 0
      end subroutine dtgevc_c
      subroutine dtgex2_c(wantq, wantz, n, a_shape__, a, lda, b_shape__,
     & b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, j1, n1, n2, work_sh
     &ape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer :: j1
        integer :: n1
        integer :: n2
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtgex2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtgex2(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, j1,
     & n1, n2, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dtgex2_c
      subroutine dtgexc_c(wantq, wantz, n, a_shape__, a, lda, b_shape__,
     & b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, ifst, ilst, work_sh
     &ape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer :: ifst
        integer :: ilst
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtgexc
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtgexc(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifs
     &t, ilst, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dtgexc_c
      subroutine dtgsen_c(ijob, wantq, wantz, select_shape__, select, n,
     & a_shape__, a, lda, b_shape__, b, ldb, alphar_shape__, alphar, alp
     &hai_shape__, alphai, beta_shape__, beta, q_shape__, q, ldq, z_shap
     &e__, z, ldz, m, pl, pr, dif_shape__, dif, work_shape__, work, lwor
     &k, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: ijob
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0D0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0D0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer :: ldz
        integer :: m
        real(kind=kind(0.0D0)) :: pl
        real(kind=kind(0.0D0)) :: pr
        integer, dimension(1) :: dif_shape__
        real(kind=kind(0.0D0)), dimension(dif_shape__(1)) :: dif
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtgsen
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtgsen(ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha
     &r, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwor
     &k, liwork, info)
        fw_iserr__ = 0
      end subroutine dtgsen_c
      subroutine dtgsja_c(jobu, jobv, jobq, m, p, n, k, l, a_shape__, a,
     & lda, b_shape__, b, ldb, tola, tolb, alpha_shape__, alpha, beta_sh
     &ape__, beta, u_shape__, u, ldu, v_shape__, v, ldv, q_shape__, q, l
     &dq, work_shape__, work, ncycle, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: p
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        real(kind=kind(0.0D0)) :: tola
        real(kind=kind(0.0D0)) :: tolb
        integer, dimension(1) :: alpha_shape__
        real(kind=kind(0.0D0)), dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0D0)), dimension(v_shape__(1), v_shape__(2)) ::
     & v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: ncycle
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtgsja
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtgsja(jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tol
     &a, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle, info)
        fw_iserr__ = 0
      end subroutine dtgsja_c
      subroutine dtgsna_c(job, howmny, select_shape__, select, n, a_shap
     &e__, a, lda, b_shape__, b, ldb, vl_shape__, vl, ldvl, vr_shape__, 
     &vr, ldvr, s_shape__, s, dif_shape__, dif, mm, m, work_shape__, wor
     &k, lwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1), vl_shape__(2)) 
     &:: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1), vr_shape__(2)) 
     &:: vr
        integer :: ldvr
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: dif_shape__
        real(kind=kind(0.0D0)), dimension(dif_shape__(1)) :: dif
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtgsna
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtgsna(job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr
     &, ldvr, s, dif, mm, m, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine dtgsna_c
      subroutine dtgsy2_c(trans, ijob, m, n, a_shape__, a, lda, b_shape_
     &_, b, ldb, c_shape__, c, ldc, d_shape__, d, ldd, e_shape__, e, lde
     &, f_shape__, f, ldf, scale, rdsum, rdscal, iwork_shape__, iwork, p
     &q, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: ijob
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(2) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1), d_shape__(2)) ::
     & d
        integer :: ldd
        integer, dimension(2) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1), e_shape__(2)) ::
     & e
        integer :: lde
        integer, dimension(2) :: f_shape__
        real(kind=kind(0.0D0)), dimension(f_shape__(1), f_shape__(2)) ::
     & f
        integer :: ldf
        real(kind=kind(0.0D0)) :: scale
        real(kind=kind(0.0D0)) :: rdsum
        real(kind=kind(0.0D0)) :: rdscal
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: pq
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtgsy2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldd) .ne. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lde) .ne. (e_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("e                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtgsy2(trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e
     &, lde, f, ldf, scale, rdsum, rdscal, iwork, pq, info)
        fw_iserr__ = 0
      end subroutine dtgsy2_c
      subroutine dtgsyl_c(trans, ijob, m, n, a_shape__, a, lda, b_shape_
     &_, b, ldb, c_shape__, c, ldc, d_shape__, d, ldd, e_shape__, e, lde
     &, f_shape__, f, ldf, scale, dif, work_shape__, work, lwork, iwork_
     &shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: ijob
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        integer, dimension(2) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1), d_shape__(2)) ::
     & d
        integer :: ldd
        integer, dimension(2) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1), e_shape__(2)) ::
     & e
        integer :: lde
        integer, dimension(2) :: f_shape__
        real(kind=kind(0.0D0)), dimension(f_shape__(1), f_shape__(2)) ::
     & f
        integer :: ldf
        real(kind=kind(0.0D0)) :: scale
        real(kind=kind(0.0D0)) :: dif
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtgsyl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldd) .ne. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lde) .ne. (e_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("e                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtgsyl(trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e
     &, lde, f, ldf, scale, dif, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine dtgsyl_c
      subroutine dtpcon_c(norm, uplo, diag, n, ap_shape__, ap, rcond, wo
     &rk_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtpcon
        fw_iserr__ = -1
        call dtpcon(norm, uplo, diag, n, ap, rcond, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dtpcon_c
      subroutine dtprfs_c(uplo, trans, diag, n, nrhs, ap_shape__, ap, b_
     &shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_shape
     &__, berr, work_shape__, work, iwork_shape__, iwork, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtprfs(uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr
     &, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dtprfs_c
      subroutine dtptri_c(uplo, diag, n, ap_shape__, ap, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtptri
        fw_iserr__ = -1
        call dtptri(uplo, diag, n, ap, info)
        fw_iserr__ = 0
      end subroutine dtptri_c
      subroutine dtptrs_c(uplo, trans, diag, n, nrhs, ap_shape__, ap, b_
     &shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtptrs(uplo, trans, diag, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dtptrs_c
      subroutine dtpttf_c(transr, uplo, n, ap_shape__, ap, arf_shape__, 
     &arf, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: arf_shape__
        real(kind=kind(0.0D0)), dimension(arf_shape__(1)) :: arf
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtpttf
        fw_iserr__ = -1
        call dtpttf(transr, uplo, n, ap, arf, info)
        fw_iserr__ = 0
      end subroutine dtpttf_c
      subroutine dtpttr_c(uplo, n, ap_shape__, ap, a_shape__, a, lda, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtpttr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtpttr(uplo, n, ap, a, lda, info)
        fw_iserr__ = 0
      end subroutine dtpttr_c
      subroutine dtrcon_c(norm, uplo, diag, n, a_shape__, a, lda, rcond,
     & work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrcon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrcon(norm, uplo, diag, n, a, lda, rcond, work, iwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine dtrcon_c
      subroutine dtrevc_c(side, howmny, select_shape__, select, n, t_sha
     &pe__, t, ldt, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, mm, m, w
     &ork_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1), vl_shape__(2)) 
     &:: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1), vr_shape__(2)) 
     &:: vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrevc
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrevc(side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr,
     & mm, m, work, info)
        fw_iserr__ = 0
      end subroutine dtrevc_c
      subroutine dtrexc_c(compq, n, t_shape__, t, ldt, q_shape__, q, ldq
     &, ifst, ilst, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compq
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer :: ifst
        integer :: ilst
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrexc
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrexc(compq, n, t, ldt, q, ldq, ifst, ilst, work, info)
        fw_iserr__ = 0
      end subroutine dtrexc_c
      subroutine dtrrfs_c(uplo, trans, diag, n, nrhs, a_shape__, a, lda,
     & b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_sh
     &ape__, berr, work_shape__, work, iwork_shape__, iwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0D0)), dimension(x_shape__(1), x_shape__(2)) ::
     & x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrrfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrrfs(uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, 
     &ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine dtrrfs_c
      subroutine dtrsen_c(job, compq, select_shape__, select, n, t_shape
     &__, t, ldt, q_shape__, q, ldq, wr_shape__, wr, wi_shape__, wi, m, 
     &s, sep, work_shape__, work, lwork, iwork_shape__, iwork, liwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compq
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0D0)), dimension(q_shape__(1), q_shape__(2)) ::
     & q
        integer :: ldq
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0D0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0D0)), dimension(wi_shape__(1)) :: wi
        integer :: m
        real(kind=kind(0.0D0)) :: s
        real(kind=kind(0.0D0)) :: sep
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrsen
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrsen(job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s,
     & sep, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine dtrsen_c
      subroutine dtrsna_c(job, howmny, select_shape__, select, n, t_shap
     &e__, t, ldt, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, s_shape__
     &, s, sep_shape__, sep, mm, m, work_shape__, work, ldwork, iwork_sh
     &ape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0D0)), dimension(t_shape__(1), t_shape__(2)) ::
     & t
        integer :: ldt
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0D0)), dimension(vl_shape__(1), vl_shape__(2)) 
     &:: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0D0)), dimension(vr_shape__(1), vr_shape__(2)) 
     &:: vr
        integer :: ldvr
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: sep_shape__
        real(kind=kind(0.0D0)), dimension(sep_shape__(1)) :: sep
        integer :: mm
        integer :: m
        integer, dimension(2) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1), work_shape__(
     &2)) :: work
        integer :: ldwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrsna
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrsna(job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, 
     &s, sep, mm, m, work, ldwork, iwork, info)
        fw_iserr__ = 0
      end subroutine dtrsna_c
      subroutine dtrsyl_c(trana, tranb, isgn, m, n, a_shape__, a, lda, b
     &_shape__, b, ldb, c_shape__, c, ldc, scale, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trana
        character(len=1, kind=kind('a')) :: tranb
        integer :: isgn
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1), c_shape__(2)) ::
     & c
        integer :: ldc
        real(kind=kind(0.0D0)) :: scale
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrsyl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, sc
     &ale, info)
        fw_iserr__ = 0
      end subroutine dtrsyl_c
      subroutine dtrti2_c(uplo, diag, n, a_shape__, a, lda, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrti2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrti2(uplo, diag, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine dtrti2_c
      subroutine dtrtri_c(uplo, diag, n, a_shape__, a, lda, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrtri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrtri(uplo, diag, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine dtrtri_c
      subroutine dtrtrs_c(uplo, trans, diag, n, nrhs, a_shape__, a, lda,
     & b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrtrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrtrs(uplo, trans, diag, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine dtrtrs_c
      subroutine dtrttf_c(transr, uplo, n, a_shape__, a, lda, arf_shape_
     &_, arf, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: arf_shape__
        real(kind=kind(0.0D0)), dimension(arf_shape__(1)) :: arf
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrttf
        fw_iserr__ = -1
        if (((lda-1) - (0) + 1) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrttf(transr, uplo, n, a, lda, arf, info)
        fw_iserr__ = 0
      end subroutine dtrttf_c
      subroutine dtrttp_c(uplo, n, a_shape__, a, lda, ap_shape__, ap, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0D0)), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtrttp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtrttp(uplo, n, a, lda, ap, info)
        fw_iserr__ = 0
      end subroutine dtrttp_c
      subroutine dtzrqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtzrqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtzrqf(m, n, a, lda, tau, info)
        fw_iserr__ = 0
      end subroutine dtzrqf_c
      subroutine dtzrzf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0D0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external dtzrzf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call dtzrzf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine dtzrzf_c
      subroutine dzsum1_c(fw_ret_arg, n, cx_shape__, cx, incx, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        integer :: n
        integer, dimension(1) :: cx_shape__
        complex*16, dimension(cx_shape__(1)) :: cx
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: dzsum1
        external dzsum1
        fw_iserr__ = -1
        fw_ret_arg = dzsum1(n, cx, incx)
        fw_iserr__ = 0
      end subroutine dzsum1_c
      subroutine icmax1_c(fw_ret_arg, n, cx_shape__, cx, incx, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: n
        integer, dimension(1) :: cx_shape__
        complex(kind=kind((0.0,0.0))), dimension(cx_shape__(1)) :: cx
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: icmax1
        external icmax1
        fw_iserr__ = -1
        fw_ret_arg = icmax1(n, cx, incx)
        fw_iserr__ = 0
      end subroutine icmax1_c
      subroutine ieeeck_c(fw_ret_arg, ispec, zero, one, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: ispec
        real(kind=kind(0.0)) :: zero
        real(kind=kind(0.0)) :: one
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ieeeck
        external ieeeck
        fw_iserr__ = -1
        fw_ret_arg = ieeeck(ispec, zero, one)
        fw_iserr__ = 0
      end subroutine ieeeck_c
      subroutine ilaclc_c(fw_ret_arg, m, n, a_shape__, a, lda, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ilaclc
        external ilaclc
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = ilaclc(m, n, a, lda)
        fw_iserr__ = 0
      end subroutine ilaclc_c
      subroutine ilaclr_c(fw_ret_arg, m, n, a_shape__, a, lda, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0,0.0))), dimension(a_shape__(1), a_shape__
     &(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ilaclr
        external ilaclr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = ilaclr(m, n, a, lda)
        fw_iserr__ = 0
      end subroutine ilaclr_c
      subroutine iladiag_c(fw_ret_arg, diag, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        character(len=1, kind=kind('a')) :: diag
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: iladiag
        external iladiag
        fw_iserr__ = -1
        fw_ret_arg = iladiag(diag)
        fw_iserr__ = 0
      end subroutine iladiag_c
      subroutine iladlc_c(fw_ret_arg, m, n, a_shape__, a, lda, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: iladlc
        external iladlc
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = iladlc(m, n, a, lda)
        fw_iserr__ = 0
      end subroutine iladlc_c
      subroutine iladlr_c(fw_ret_arg, m, n, a_shape__, a, lda, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: iladlr
        external iladlr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = iladlr(m, n, a, lda)
        fw_iserr__ = 0
      end subroutine iladlr_c
      subroutine ilaenv_c(fw_ret_arg, ispec, fw_name_len, name, fw_opts_
     &len, opts, n1, n2, n3, n4, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: ispec
        character(len=*) :: name
        character(len=*) :: opts
        integer :: n1
        integer :: n2
        integer :: n3
        integer :: n4
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ilaenv
        external ilaenv
        fw_iserr__ = -1
        fw_ret_arg = ilaenv(ispec, name, opts, n1, n2, n3, n4)
        fw_iserr__ = 0
      end subroutine ilaenv_c
      subroutine ilaprec_c(fw_ret_arg, prec, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        character(len=1, kind=kind('a')) :: prec
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ilaprec
        external ilaprec
        fw_iserr__ = -1
        fw_ret_arg = ilaprec(prec)
        fw_iserr__ = 0
      end subroutine ilaprec_c
      subroutine ilaslc_c(fw_ret_arg, m, n, a_shape__, a, lda, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ilaslc
        external ilaslc
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = ilaslc(m, n, a, lda)
        fw_iserr__ = 0
      end subroutine ilaslc_c
      subroutine ilaslr_c(fw_ret_arg, m, n, a_shape__, a, lda, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ilaslr
        external ilaslr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = ilaslr(m, n, a, lda)
        fw_iserr__ = 0
      end subroutine ilaslr_c
      subroutine ilatrans_c(fw_ret_arg, trans, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ilatrans
        external ilatrans
        fw_iserr__ = -1
        fw_ret_arg = ilatrans(trans)
        fw_iserr__ = 0
      end subroutine ilatrans_c
      subroutine ilauplo_c(fw_ret_arg, uplo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ilauplo
        external ilauplo
        fw_iserr__ = -1
        fw_ret_arg = ilauplo(uplo)
        fw_iserr__ = 0
      end subroutine ilauplo_c
      subroutine ilaver_c(vers_major, vers_minor, vers_patch, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: vers_major
        integer :: vers_minor
        integer :: vers_patch
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ilaver
        fw_iserr__ = -1
        call ilaver(vers_major, vers_minor, vers_patch)
        fw_iserr__ = 0
      end subroutine ilaver_c
      subroutine ilazlc_c(fw_ret_arg, m, n, a_shape__, a, lda, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ilazlc
        external ilazlc
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = ilazlc(m, n, a, lda)
        fw_iserr__ = 0
      end subroutine ilazlc_c
      subroutine ilazlr_c(fw_ret_arg, m, n, a_shape__, a, lda, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: ilazlr
        external ilazlr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = ilazlr(m, n, a, lda)
        fw_iserr__ = 0
      end subroutine ilazlr_c
      subroutine iparmq_c(fw_ret_arg, ispec, name, opts, n, ilo, ihi, lw
     &ork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: ispec
        character(len=1, kind=kind('a')) :: name
        character(len=1, kind=kind('a')) :: opts
        integer :: n
        integer :: ilo
        integer :: ihi
        integer :: lwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: iparmq
        external iparmq
        fw_iserr__ = -1
        fw_ret_arg = iparmq(ispec, name, opts, n, ilo, ihi, lwork)
        fw_iserr__ = 0
      end subroutine iparmq_c
      subroutine izmax1_c(fw_ret_arg, n, cx_shape__, cx, incx, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: n
        integer, dimension(1) :: cx_shape__
        complex*16, dimension(cx_shape__(1)) :: cx
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: izmax1
        external izmax1
        fw_iserr__ = -1
        fw_ret_arg = izmax1(n, cx, incx)
        fw_iserr__ = 0
      end subroutine izmax1_c
      subroutine lsamen_c(fw_ret_arg, n, fw_ca_len, ca, fw_cb_len, cb, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: fw_ret_arg
        integer :: n
        character(len=*) :: ca
        character(len=*) :: cb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer(kind=kind(0)) :: lsamen
        external lsamen
        fw_iserr__ = -1
        fw_ret_arg = lsamen(n, ca, cb)
        fw_iserr__ = 0
      end subroutine lsamen_c
      subroutine sbbcsd_c(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, 
     &theta_shape__, theta, phi_shape__, phi, u1_shape__, u1, ldu1, u2_s
     &hape__, u2, ldu2, v1t_shape__, v1t, ldv1t, v2t_shape__, v2t, ldv2t
     &, b11d_shape__, b11d, b11e_shape__, b11e, b12d_shape__, b12d, b12e
     &_shape__, b12e, b21d_shape__, b21d, b21e_shape__, b21e, b22d_shape
     &__, b22d, b22e_shape__, b22e, work_shape__, work, lwork, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu1
        character(len=1, kind=kind('a')) :: jobu2
        character(len=1, kind=kind('a')) :: jobv1t
        character(len=1, kind=kind('a')) :: jobv2t
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(1) :: phi_shape__
        real(kind=kind(0.0)), dimension(phi_shape__(1)) :: phi
        integer, dimension(2) :: u1_shape__
        real(kind=kind(0.0)), dimension(u1_shape__(1), u1_shape__(2)) ::
     & u1
        integer :: ldu1
        integer, dimension(2) :: u2_shape__
        real(kind=kind(0.0)), dimension(u2_shape__(1), u2_shape__(2)) ::
     & u2
        integer :: ldu2
        integer, dimension(2) :: v1t_shape__
        real(kind=kind(0.0)), dimension(v1t_shape__(1), v1t_shape__(2)) 
     &:: v1t
        integer :: ldv1t
        integer, dimension(2) :: v2t_shape__
        real(kind=kind(0.0)), dimension(v2t_shape__(1), v2t_shape__(2)) 
     &:: v2t
        integer :: ldv2t
        integer, dimension(1) :: b11d_shape__
        real(kind=kind(0.0)), dimension(b11d_shape__(1)) :: b11d
        integer, dimension(1) :: b11e_shape__
        real(kind=kind(0.0)), dimension(b11e_shape__(1)) :: b11e
        integer, dimension(1) :: b12d_shape__
        real(kind=kind(0.0)), dimension(b12d_shape__(1)) :: b12d
        integer, dimension(1) :: b12e_shape__
        real(kind=kind(0.0)), dimension(b12e_shape__(1)) :: b12e
        integer, dimension(1) :: b21d_shape__
        real(kind=kind(0.0)), dimension(b21d_shape__(1)) :: b21d
        integer, dimension(1) :: b21e_shape__
        real(kind=kind(0.0)), dimension(b21e_shape__(1)) :: b21e
        integer, dimension(1) :: b22d_shape__
        real(kind=kind(0.0)), dimension(b22d_shape__(1)) :: b22d
        integer, dimension(1) :: b22e_shape__
        real(kind=kind(0.0)), dimension(b22e_shape__(1)) :: b22e
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sbbcsd
        fw_iserr__ = -1
        if ((ldu1) .ne. (u1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv1t) .ne. (v1t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v1t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv2t) .ne. (v2t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v2t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sbbcsd(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta,
     & phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d
     &, b12e, b21d, b21e, b22d, b22e, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sbbcsd_c
      subroutine sbdsdc_c(uplo, compq, n, d_shape__, d, e_shape__, e, u_
     &shape__, u, ldu, vt_shape__, vt, ldvt, q_shape__, q, iq_shape__, i
     &q, work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: compq
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer :: ldvt
        integer, dimension(1) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1)) :: q
        integer, dimension(1) :: iq_shape__
        integer, dimension(iq_shape__(1)) :: iq
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sbdsdc
        fw_iserr__ = -1
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sbdsdc(uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work,
     & iwork, info)
        fw_iserr__ = 0
      end subroutine sbdsdc_c
      subroutine sbdsqr_c(uplo, n, ncvt, nru, ncc, d_shape__, d, e_shape
     &__, e, vt_shape__, vt, ldvt, u_shape__, u, ldu, c_shape__, c, ldc,
     & work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ncvt
        integer :: nru
        integer :: ncc
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer :: ldvt
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sbdsqr
        fw_iserr__ = -1
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sbdsqr(uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, 
     &ldc, work, info)
        fw_iserr__ = 0
      end subroutine sbdsqr_c
      subroutine scsum1_c(fw_ret_arg, n, cx_shape__, cx, incx, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        integer :: n
        integer, dimension(1) :: cx_shape__
        complex(kind=kind((0.0,0.0))), dimension(cx_shape__(1)) :: cx
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: scsum1
        external scsum1
        fw_iserr__ = -1
        fw_ret_arg = scsum1(n, cx, incx)
        fw_iserr__ = 0
      end subroutine scsum1_c
      subroutine sdisna_c(job, m, n, d_shape__, d, sep_shape__, sep, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        integer :: m
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: sep_shape__
        real(kind=kind(0.0)), dimension(sep_shape__(1)) :: sep
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sdisna
        fw_iserr__ = -1
        call sdisna(job, m, n, d, sep, info)
        fw_iserr__ = 0
      end subroutine sdisna_c
      subroutine sgbbrd_c(vect, m, n, ncc, kl, ku, ab_shape__, ab, ldab,
     & d_shape__, d, e_shape__, e, q_shape__, q, ldq, pt_shape__, pt, ld
     &pt, c_shape__, c, ldc, work_shape__, work, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        integer :: m
        integer :: n
        integer :: ncc
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: pt_shape__
        real(kind=kind(0.0)), dimension(pt_shape__(1), pt_shape__(2)) ::
     & pt
        integer :: ldpt
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbbrd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldpt) .ne. (pt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("pt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbbrd(vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt,
     & ldpt, c, ldc, work, info)
        fw_iserr__ = 0
      end subroutine sgbbrd_c
      subroutine sgbcon_c(norm, n, kl, ku, ab_shape__, ab, ldab, ipiv_sh
     &ape__, ipiv, anorm, rcond, work_shape__, work, iwork_shape__, iwor
     &k, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbcon(norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work,
     & iwork, info)
        fw_iserr__ = 0
      end subroutine sgbcon_c
      subroutine sgbequ_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__,
     & r, c_shape__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbequ
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbequ(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, 
     &info)
        fw_iserr__ = 0
      end subroutine sgbequ_c
      subroutine sgbequb_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__
     &, r, c_shape__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbequb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbequb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax,
     & info)
        fw_iserr__ = 0
      end subroutine sgbequb_c
      subroutine sgbrfs_c(trans, n, kl, ku, nrhs, ab_shape__, ab, ldab, 
     &afb_shape__, afb, ldafb, ipiv_shape__, ipiv, b_shape__, b, ldb, x_
     &shape__, x, ldx, ferr_shape__, ferr, berr_shape__, berr, work_shap
     &e__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0)), dimension(afb_shape__(1), afb_shape__(2)) 
     &:: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbrfs(trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, 
     &b, ldb, x, ldx, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sgbrfs_c
      subroutine sgbrfsx_c(trans, equed, n, kl, ku, nrhs, ab_shape__, ab
     &, ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, r_shape__, r,
     & c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, berr_s
     &hape__, berr, n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, er
     &r_bnds_comp_shape__, err_bnds_comp, nparams, params_shape__, param
     &s, work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0)), dimension(afb_shape__(1), afb_shape__(2)) 
     &:: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbrfsx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbrfsx(trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb
     &, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_no
     &rm, err_bnds_comp, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sgbrfsx_c
      subroutine sgbsv_c(n, kl, ku, nrhs, ab_shape__, ab, ldab, ipiv_sha
     &pe__, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbsv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbsv(n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine sgbsv_c
      subroutine sgbsvx_c(fact, trans, n, kl, ku, nrhs, ab_shape__, ab, 
     &ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, equed, r_shape_
     &_, r, c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, f
     &err_shape__, ferr, berr_shape__, berr, work_shape__, work, iwork_s
     &hape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0)), dimension(afb_shape__(1), afb_shape__(2)) 
     &:: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbsvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbsvx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, 
     &ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork,
     & info)
        fw_iserr__ = 0
      end subroutine sgbsvx_c
      subroutine sgbsvxx_c(fact, trans, n, kl, ku, nrhs, ab_shape__, ab,
     & ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, equed, r_shape
     &__, r, c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, 
     &rpvgrw, berr_shape__, berr, n_err_bnds, err_bnds_norm_shape__, err
     &_bnds_norm, err_bnds_comp_shape__, err_bnds_comp, nparams, params_
     &shape__, params, work_shape__, work, iwork_shape__, iwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0)), dimension(afb_shape__(1), afb_shape__(2)) 
     &:: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        real(kind=kind(0.0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbsvxx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbsvxx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,
     & ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnd
     &s, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine sgbsvxx_c
      subroutine sgbtf2_c(m, n, kl, ku, ab_shape__, ab, ldab, ipiv_shape
     &__, ipiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbtf2
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbtf2(m, n, kl, ku, ab, ldab, ipiv, info)
        fw_iserr__ = 0
      end subroutine sgbtf2_c
      subroutine sgbtrf_c(m, n, kl, ku, ab_shape__, ab, ldab, ipiv_shape
     &__, ipiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbtrf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbtrf(m, n, kl, ku, ab, ldab, ipiv, info)
        fw_iserr__ = 0
      end subroutine sgbtrf_c
      subroutine sgbtrs_c(trans, n, kl, ku, nrhs, ab_shape__, ab, ldab, 
     &ipiv_shape__, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgbtrs(trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info
     &)
        fw_iserr__ = 0
      end subroutine sgbtrs_c
      subroutine sgebak_c(job, side, n, ilo, ihi, scale_shape__, scale, 
     &m, v_shape__, v, ldv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: side
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0)), dimension(scale_shape__(1)) :: scale
        integer :: m
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgebak
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgebak(job, side, n, ilo, ihi, scale, m, v, ldv, info)
        fw_iserr__ = 0
      end subroutine sgebak_c
      subroutine sgebal_c(job, n, a_shape__, a, lda, ilo, ihi, scale_sha
     &pe__, scale, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0)), dimension(scale_shape__(1)) :: scale
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgebal
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgebal(job, n, a, lda, ilo, ihi, scale, info)
        fw_iserr__ = 0
      end subroutine sgebal_c
      subroutine sgebd2_c(m, n, a_shape__, a, lda, d_shape__, d, e_shape
     &__, e, tauq_shape__, tauq, taup_shape__, taup, work_shape__, work,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        real(kind=kind(0.0)), dimension(tauq_shape__(1)) :: tauq
        integer, dimension(1) :: taup_shape__
        real(kind=kind(0.0)), dimension(taup_shape__(1)) :: taup
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgebd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgebd2(m, n, a, lda, d, e, tauq, taup, work, info)
        fw_iserr__ = 0
      end subroutine sgebd2_c
      subroutine sgebrd_c(m, n, a_shape__, a, lda, d_shape__, d, e_shape
     &__, e, tauq_shape__, tauq, taup_shape__, taup, work_shape__, work,
     & lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        real(kind=kind(0.0)), dimension(tauq_shape__(1)) :: tauq
        integer, dimension(1) :: taup_shape__
        real(kind=kind(0.0)), dimension(taup_shape__(1)) :: taup
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgebrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgebrd(m, n, a, lda, d, e, tauq, taup, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgebrd_c
      subroutine sgecon_c(norm, n, a_shape__, a, lda, anorm, rcond, work
     &_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgecon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgecon(norm, n, a, lda, anorm, rcond, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sgecon_c
      subroutine sgeequ_c(m, n, a_shape__, a, lda, r_shape__, r, c_shape
     &__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeequ
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeequ(m, n, a, lda, r, c, rowcnd, colcnd, amax, info)
        fw_iserr__ = 0
      end subroutine sgeequ_c
      subroutine sgeequb_c(m, n, a_shape__, a, lda, r_shape__, r, c_shap
     &e__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeequb(m, n, a, lda, r, c, rowcnd, colcnd, amax, info)
        fw_iserr__ = 0
      end subroutine sgeequb_c
      subroutine sgees_c(jobvs, sort, select, n, a_shape__, a, lda, sdim
     &, wr_shape__, wr, wi_shape__, wi, vs_shape__, vs, ldvs, work_shape
     &__, work, lwork, bwork_shape__, bwork, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvs
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: sdim
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: vs_shape__
        real(kind=kind(0.0)), dimension(vs_shape__(1), vs_shape__(2)) ::
     & vs
        integer :: ldvs
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgees
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvs) .ne. (vs_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vs                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgees(jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldv
     &s, work, lwork, bwork, info)
        fw_iserr__ = 0
      end subroutine sgees_c
      subroutine sgeesx_c(jobvs, sort, select, sense, n, a_shape__, a, l
     &da, sdim, wr_shape__, wr, wi_shape__, wi, vs_shape__, vs, ldvs, rc
     &onde, rcondv, work_shape__, work, lwork, iwork_shape__, iwork, liw
     &ork, bwork_shape__, bwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvs
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: select
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: sdim
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: vs_shape__
        real(kind=kind(0.0)), dimension(vs_shape__(1), vs_shape__(2)) ::
     & vs
        integer :: ldvs
        real(kind=kind(0.0)) :: rconde
        real(kind=kind(0.0)) :: rcondv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeesx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvs) .ne. (vs_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vs                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeesx(jobvs, sort, select, sense, n, a, lda, sdim, wr, wi,
     & vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork, info
     &)
        fw_iserr__ = 0
      end subroutine sgeesx_c
      subroutine sgeev_c(jobvl, jobvr, n, a_shape__, a, lda, wr_shape__,
     & wr, wi_shape__, wi, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, w
     &ork_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1), vl_shape__(2)) ::
     & vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1), vr_shape__(2)) ::
     & vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeev(jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, 
     &work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgeev_c
      subroutine sgeevx_c(balanc, jobvl, jobvr, sense, n, a_shape__, a, 
     &lda, wr_shape__, wr, wi_shape__, wi, vl_shape__, vl, ldvl, vr_shap
     &e__, vr, ldvr, ilo, ihi, scale_shape__, scale, abnrm, rconde_shape
     &__, rconde, rcondv_shape__, rcondv, work_shape__, work, lwork, iwo
     &rk_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: balanc
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1), vl_shape__(2)) ::
     & vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1), vr_shape__(2)) ::
     & vr
        integer :: ldvr
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0)), dimension(scale_shape__(1)) :: scale
        real(kind=kind(0.0)) :: abnrm
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeevx(balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, 
     &ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwor
     &k, iwork, info)
        fw_iserr__ = 0
      end subroutine sgeevx_c
      subroutine sgegs_c(jobvsl, jobvsr, n, a_shape__, a, lda, b_shape__
     &, b, ldb, alphar_shape__, alphar, alphai_shape__, alphai, beta_sha
     &pe__, beta, vsl_shape__, vsl, ldvsl, vsr_shape__, vsr, ldvsr, work
     &_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vsl_shape__
        real(kind=kind(0.0)), dimension(vsl_shape__(1), vsl_shape__(2)) 
     &:: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        real(kind=kind(0.0)), dimension(vsr_shape__(1), vsr_shape__(2)) 
     &:: vsr
        integer :: ldvsr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgegs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgegs(jobvsl, jobvsr, n, a, lda, b, ldb, alphar, alphai, be
     &ta, vsl, ldvsl, vsr, ldvsr, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgegs_c
      subroutine sgegv_c(jobvl, jobvr, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, alphar_shape__, alphar, alphai_shape__, alphai, beta_shape
     &__, beta, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, work_shape__
     &, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1), vl_shape__(2)) ::
     & vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1), vr_shape__(2)) ::
     & vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgegv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgegv(jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta
     &, vl, ldvl, vr, ldvr, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgegv_c
      subroutine sgehd2_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgehd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgehd2(n, ilo, ihi, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine sgehd2_c
      subroutine sgehrd_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgehrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgehrd(n, ilo, ihi, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgehrd_c
      subroutine sgejsv_c(joba, jobu, jobv, jobr, jobt, jobp, m, n, a_sh
     &ape__, a, lda, sva_shape__, sva, u_shape__, u, ldu, v_shape__, v, 
     &ldv, work_shape__, work, lwork, iwork_shape__, iwork, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1) :: joba
        character(len=1) :: jobu
        character(len=1) :: jobv
        character(len=1) :: jobr
        character(len=1) :: jobt
        character(len=1) :: jobp
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: sva_shape__
        real(kind=kind(0.0)), dimension(sva_shape__(1)) :: sva
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgejsv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (sva_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sva                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lwork) .lt. 0 .or. (lwork) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgejsv(joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sv
     &a, u, ldu, v, ldv, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine sgejsv_c
      subroutine sgelq2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgelq2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgelq2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine sgelq2_c
      subroutine sgelqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgelqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgelqf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgelqf_c
      subroutine sgels_c(trans, m, n, nrhs, a_shape__, a, lda, b_shape__
     &, b, ldb, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgels
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgels(trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgels_c
      subroutine sgelsd_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, s_shape__, s, rcond, rank, work_shape__, work, lwork, iwork_sh
     &ape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgelsd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgelsd(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lw
     &ork, iwork, info)
        fw_iserr__ = 0
      end subroutine sgelsd_c
      subroutine sgelss_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, s_shape__, s, rcond, rank, work_shape__, work, lwork, info, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgelss
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgelss(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lw
     &ork, info)
        fw_iserr__ = 0
      end subroutine sgelss_c
      subroutine sgelsx_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, jpvt_shape__, jpvt, rcond, rank, work_shape__, work, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        real(kind=kind(0.0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgelsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgelsx(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work,
     & info)
        fw_iserr__ = 0
      end subroutine sgelsx_c
      subroutine sgelsy_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, jpvt_shape__, jpvt, rcond, rank, work_shape__, work, lwork, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        real(kind=kind(0.0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgelsy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgelsy(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work,
     & lwork, info)
        fw_iserr__ = 0
      end subroutine sgelsy_c
      subroutine sgeql2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeql2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeql2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine sgeql2_c
      subroutine sgeqlf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeqlf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeqlf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgeqlf_c
      subroutine sgeqp3_c(m, n, a_shape__, a, lda, jpvt_shape__, jpvt, t
     &au_shape__, tau, work_shape__, work, lwork, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeqp3
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeqp3(m, n, a, lda, jpvt, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgeqp3_c
      subroutine sgeqpf_c(m, n, a_shape__, a, lda, jpvt_shape__, jpvt, t
     &au_shape__, tau, work_shape__, work, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeqpf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeqpf(m, n, a, lda, jpvt, tau, work, info)
        fw_iserr__ = 0
      end subroutine sgeqpf_c
      subroutine sgeqr2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeqr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeqr2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine sgeqr2_c
      subroutine sgeqr2p_c(m, n, a_shape__, a, lda, tau_shape__, tau, wo
     &rk_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeqr2p
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeqr2p(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine sgeqr2p_c
      subroutine sgeqrf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeqrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeqrf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgeqrf_c
      subroutine sgeqrfp_c(m, n, a_shape__, a, lda, tau_shape__, tau, wo
     &rk_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgeqrfp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgeqrfp(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgeqrfp_c
      subroutine sgerfs_c(trans, n, nrhs, a_shape__, a, lda, af_shape__,
     & af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ld
     &x, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, iwo
     &rk_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgerfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgerfs(trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, l
     &dx, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sgerfs_c
      subroutine sgerfsx_c(trans, equed, n, nrhs, a_shape__, a, lda, af_
     &shape__, af, ldaf, ipiv_shape__, ipiv, r_shape__, r, c_shape__, c,
     & b_shape__, b, ldb, x_shape__, x, ldx, rcond, berr_shape__, berr, 
     &n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_sh
     &ape__, err_bnds_comp, nparams, params_shape__, params, work_shape_
     &_, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgerfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgerfsx(trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c
     &, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds
     &_comp, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sgerfsx_c
      subroutine sgerq2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgerq2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgerq2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine sgerq2_c
      subroutine sgerqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgerqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgerqf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgerqf_c
      subroutine sgesc2_c(n, a_shape__, a, lda, rhs_shape__, rhs, ipiv_s
     &hape__, ipiv, jpiv_shape__, jpiv, scale, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: rhs_shape__
        real(kind=kind(0.0)), dimension(rhs_shape__(1)) :: rhs
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        real(kind=kind(0.0)) :: scale
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgesc2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgesc2(n, a, lda, rhs, ipiv, jpiv, scale)
        fw_iserr__ = 0
      end subroutine sgesc2_c
      subroutine sgesdd_c(jobz, m, n, a_shape__, a, lda, s_shape__, s, u
     &_shape__, u, ldu, vt_shape__, vt, ldvt, work_shape__, work, lwork,
     & iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer :: ldvt
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgesdd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgesdd(jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork
     &, iwork, info)
        fw_iserr__ = 0
      end subroutine sgesdd_c
      subroutine sgesv_c(n, nrhs, a_shape__, a, lda, ipiv_shape__, ipiv,
     & b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgesv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgesv(n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine sgesv_c
      subroutine sgesvd_c(jobu, jobvt, m, n, a_shape__, a, lda, s_shape_
     &_, s, u_shape__, u, ldu, vt_shape__, vt, ldvt, work_shape__, work,
     & lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobvt
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer :: ldvt
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgesvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work
     &, lwork, info)
        fw_iserr__ = 0
      end subroutine sgesvd_c
      subroutine sgesvj_c(joba, jobu, jobv, m, n, a_shape__, a, lda, sva
     &_shape__, sva, mv, v_shape__, v, ldv, work_shape__, work, lwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1) :: joba
        character(len=1) :: jobu
        character(len=1) :: jobv
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: sva_shape__
        real(kind=kind(0.0)), dimension(sva_shape__(1)) :: sva
        integer :: mv
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgesvj
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (sva_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sva                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lwork) .lt. 0 .or. (lwork) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgesvj(joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, wor
     &k, lwork, info)
        fw_iserr__ = 0
      end subroutine sgesvj_c
      subroutine sgesvx_c(fact, trans, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, ipiv_shape__, ipiv, equed, r_shape__, r, c_shape_
     &_, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, ferr_shape__, f
     &err, berr_shape__, berr, work_shape__, work, iwork_shape__, iwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgesvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgesvx(fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed,
     & r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sgesvx_c
      subroutine sgesvxx_c(fact, trans, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, ipiv_shape__, ipiv, equed, r_shape__, r, c_shape
     &__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, rpvgrw, berr_s
     &hape__, berr, n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, er
     &r_bnds_comp_shape__, err_bnds_comp, nparams, params_shape__, param
     &s, work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        real(kind=kind(0.0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgesvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgesvxx(fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed
     &, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_
     &norm, err_bnds_comp, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sgesvxx_c
      subroutine sgetc2_c(n, a_shape__, a, lda, ipiv_shape__, ipiv, jpiv
     &_shape__, jpiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgetc2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgetc2(n, a, lda, ipiv, jpiv, info)
        fw_iserr__ = 0
      end subroutine sgetc2_c
      subroutine sgetf2_c(m, n, a_shape__, a, lda, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgetf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgetf2(m, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine sgetf2_c
      subroutine sgetrf_c(m, n, a_shape__, a, lda, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgetrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgetrf(m, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine sgetrf_c
      subroutine sgetri_c(n, a_shape__, a, lda, ipiv_shape__, ipiv, work
     &_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgetri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgetri(n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgetri_c
      subroutine sgetrs_c(trans, n, nrhs, a_shape__, a, lda, ipiv_shape_
     &_, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgetrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine sgetrs_c
      subroutine sggbak_c(job, side, n, ilo, ihi, lscale_shape__, lscale
     &, rscale_shape__, rscale, m, v_shape__, v, ldv, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: side
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0)), dimension(rscale_shape__(1)) :: rscale
        integer :: m
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sggbak
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sggbak(job, side, n, ilo, ihi, lscale, rscale, m, v, ldv, i
     &nfo)
        fw_iserr__ = 0
      end subroutine sggbak_c
      subroutine sggbal_c(job, n, a_shape__, a, lda, b_shape__, b, ldb, 
     &ilo, ihi, lscale_shape__, lscale, rscale_shape__, rscale, work_sha
     &pe__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0)), dimension(rscale_shape__(1)) :: rscale
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sggbal
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sggbal(job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, wo
     &rk, info)
        fw_iserr__ = 0
      end subroutine sggbal_c
      subroutine sgges_c(jobvsl, jobvsr, sort, selctg, n, a_shape__, a, 
     &lda, b_shape__, b, ldb, sdim, alphar_shape__, alphar, alphai_shape
     &__, alphai, beta_shape__, beta, vsl_shape__, vsl, ldvsl, vsr_shape
     &__, vsr, ldvsr, work_shape__, work, lwork, bwork_shape__, bwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: selctg
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: sdim
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vsl_shape__
        real(kind=kind(0.0)), dimension(vsl_shape__(1), vsl_shape__(2)) 
     &:: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        real(kind=kind(0.0)), dimension(vsr_shape__(1), vsr_shape__(2)) 
     &:: vsr
        integer :: ldvsr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgges
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgges(jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim
     &, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork
     &, info)
        fw_iserr__ = 0
      end subroutine sgges_c
      subroutine sggesx_c(jobvsl, jobvsr, sort, selctg, sense, n, a_shap
     &e__, a, lda, b_shape__, b, ldb, sdim, alphar_shape__, alphar, alph
     &ai_shape__, alphai, beta_shape__, beta, vsl_shape__, vsl, ldvsl, v
     &sr_shape__, vsr, ldvsr, rconde_shape__, rconde, rcondv_shape__, rc
     &ondv, work_shape__, work, lwork, iwork_shape__, iwork, liwork, bwo
     &rk_shape__, bwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: selctg
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: sdim
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vsl_shape__
        real(kind=kind(0.0)), dimension(vsl_shape__(1), vsl_shape__(2)) 
     &:: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        real(kind=kind(0.0)), dimension(vsr_shape__(1), vsr_shape__(2)) 
     &:: vsr
        integer :: ldvsr
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sggesx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (rconde_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("rconde                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (rcondv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("rcondv                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sggesx(jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, l
     &db, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rc
     &ondv, work, lwork, iwork, liwork, bwork, info)
        fw_iserr__ = 0
      end subroutine sggesx_c
      subroutine sggev_c(jobvl, jobvr, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, alphar_shape__, alphar, alphai_shape__, alphai, beta_shape
     &__, beta, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, work_shape__
     &, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1), vl_shape__(2)) ::
     & vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1), vr_shape__(2)) ::
     & vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sggev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sggev(jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta
     &, vl, ldvl, vr, ldvr, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sggev_c
      subroutine sggevx_c(balanc, jobvl, jobvr, sense, n, a_shape__, a, 
     &lda, b_shape__, b, ldb, alphar_shape__, alphar, alphai_shape__, al
     &phai, beta_shape__, beta, vl_shape__, vl, ldvl, vr_shape__, vr, ld
     &vr, ilo, ihi, lscale_shape__, lscale, rscale_shape__, rscale, abnr
     &m, bbnrm, rconde_shape__, rconde, rcondv_shape__, rcondv, work_sha
     &pe__, work, lwork, iwork_shape__, iwork, bwork_shape__, bwork, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: balanc
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1), vl_shape__(2)) ::
     & vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1), vr_shape__(2)) ::
     & vr
        integer :: ldvr
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0)), dimension(rscale_shape__(1)) :: rscale
        real(kind=kind(0.0)) :: abnrm
        real(kind=kind(0.0)) :: bbnrm
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sggevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sggevx(balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alph
     &ar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, ab
     &nrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork, info)
        fw_iserr__ = 0
      end subroutine sggevx_c
      subroutine sggglm_c(n, m, p, a_shape__, a, lda, b_shape__, b, ldb,
     & d_shape__, d, x_shape__, x, y_shape__, y, work_shape__, work, lwo
     &rk, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: m
        integer :: p
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sggglm
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sggglm(n, m, p, a, lda, b, ldb, d, x, y, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sggglm_c
      subroutine sgghrd_c(compq, compz, n, ilo, ihi, a_shape__, a, lda, 
     &b_shape__, b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compq
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgghrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgghrd(compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z
     &, ldz, info)
        fw_iserr__ = 0
      end subroutine sgghrd_c
      subroutine sgglse_c(m, n, p, a_shape__, a, lda, b_shape__, b, ldb,
     & c_shape__, c, d_shape__, d, x_shape__, x, work_shape__, work, lwo
     &rk, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: p
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgglse
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgglse(m, n, p, a, lda, b, ldb, c, d, x, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgglse_c
      subroutine sggqrf_c(n, m, p, a_shape__, a, lda, taua_shape__, taua
     &, b_shape__, b, ldb, taub_shape__, taub, work_shape__, work, lwork
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: m
        integer :: p
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: taua_shape__
        real(kind=kind(0.0)), dimension(taua_shape__(1)) :: taua
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: taub_shape__
        real(kind=kind(0.0)), dimension(taub_shape__(1)) :: taub
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sggqrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sggqrf(n, m, p, a, lda, taua, b, ldb, taub, work, lwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine sggqrf_c
      subroutine sggrqf_c(m, p, n, a_shape__, a, lda, taua_shape__, taua
     &, b_shape__, b, ldb, taub_shape__, taub, work_shape__, work, lwork
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: p
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: taua_shape__
        real(kind=kind(0.0)), dimension(taua_shape__(1)) :: taua
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: taub_shape__
        real(kind=kind(0.0)), dimension(taub_shape__(1)) :: taub
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sggrqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sggrqf(m, p, n, a, lda, taua, b, ldb, taub, work, lwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine sggrqf_c
      subroutine sggsvd_c(jobu, jobv, jobq, m, n, p, k, l, a_shape__, a,
     & lda, b_shape__, b, ldb, alpha_shape__, alpha, beta_shape__, beta,
     & u_shape__, u, ldu, v_shape__, v, ldv, q_shape__, q, ldq, work_sha
     &pe__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: n
        integer :: p
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        real(kind=kind(0.0)), dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sggsvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sggsvd(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alp
     &ha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sggsvd_c
      subroutine sggsvp_c(jobu, jobv, jobq, m, p, n, a_shape__, a, lda, 
     &b_shape__, b, ldb, tola, tolb, k, l, u_shape__, u, ldu, v_shape__,
     & v, ldv, q_shape__, q, ldq, iwork_shape__, iwork, tau_shape__, tau
     &, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: p
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: tola
        real(kind=kind(0.0)) :: tolb
        integer :: k
        integer :: l
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sggsvp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sggsvp(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tol
     &b, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info)
        fw_iserr__ = 0
      end subroutine sggsvp_c
      subroutine sgsvj0_c(jobv, m, n, a_shape__, a, lda, d_shape__, d, s
     &va_shape__, sva, mv, v_shape__, v, ldv, eps, sfmin, tol, nsweep, w
     &ork_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1) :: jobv
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: sva_shape__
        real(kind=kind(0.0)), dimension(sva_shape__(1)) :: sva
        integer :: mv
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        real(kind=kind(0.0)) :: eps
        real(kind=kind(0.0)) :: sfmin
        real(kind=kind(0.0)) :: tol
        integer :: nsweep
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgsvj0
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (sva_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sva                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lwork) .lt. 0 .or. (lwork) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgsvj0(jobv, m, n, a, lda, d, sva, mv, v, ldv, eps, sfmin, 
     &tol, nsweep, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgsvj0_c
      subroutine sgsvj1_c(jobv, m, n, n1, a_shape__, a, lda, d_shape__, 
     &d, sva_shape__, sva, mv, v_shape__, v, ldv, eps, sfmin, tol, nswee
     &p, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1) :: jobv
        integer :: m
        integer :: n
        integer :: n1
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: sva_shape__
        real(kind=kind(0.0)), dimension(sva_shape__(1)) :: sva
        integer :: mv
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        real(kind=kind(0.0)) :: eps
        real(kind=kind(0.0)) :: sfmin
        real(kind=kind(0.0)) :: tol
        integer :: nsweep
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgsvj1
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (sva_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sva                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lwork) .lt. 0 .or. (lwork) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgsvj1(jobv, m, n, n1, a, lda, d, sva, mv, v, ldv, eps, sfm
     &in, tol, nsweep, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sgsvj1_c
      subroutine sgtcon_c(norm, n, dl_shape__, dl, d_shape__, d, du_shap
     &e__, du, du2_shape__, du2, ipiv_shape__, ipiv, anorm, rcond, work_
     &shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgtcon
        fw_iserr__ = -1
        call sgtcon(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, i
     &work, info)
        fw_iserr__ = 0
      end subroutine sgtcon_c
      subroutine sgtrfs_c(trans, n, nrhs, dl_shape__, dl, d_shape__, d, 
     &du_shape__, du, dlf_shape__, dlf, df_shape__, df, duf_shape__, duf
     &, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape
     &__, x, ldx, ferr_shape__, ferr, berr_shape__, berr, work_shape__, 
     &work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: dlf_shape__
        real(kind=kind(0.0)), dimension(dlf_shape__(1)) :: dlf
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: duf_shape__
        real(kind=kind(0.0)), dimension(duf_shape__(1)) :: duf
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgtrfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgtrfs(trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, 
     &b, ldb, x, ldx, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sgtrfs_c
      subroutine sgtsv_c(n, nrhs, dl_shape__, dl, d_shape__, d, du_shape
     &__, du, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0)), dimension(du_shape__(1)) :: du
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgtsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgtsv(n, nrhs, dl, d, du, b, ldb, info)
        fw_iserr__ = 0
      end subroutine sgtsv_c
      subroutine sgtsvx_c(fact, trans, n, nrhs, dl_shape__, dl, d_shape_
     &_, d, du_shape__, du, dlf_shape__, dlf, df_shape__, df, duf_shape_
     &_, duf, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b, ldb, x
     &_shape__, x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, w
     &ork_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: dlf_shape__
        real(kind=kind(0.0)), dimension(dlf_shape__(1)) :: dlf
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: duf_shape__
        real(kind=kind(0.0)), dimension(duf_shape__(1)) :: duf
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgtsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgtsvx(fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, 
     &ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sgtsvx_c
      subroutine sgttrf_c(n, dl_shape__, dl, d_shape__, d, du_shape__, d
     &u, du2_shape__, du2, ipiv_shape__, ipiv, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgttrf
        fw_iserr__ = -1
        call sgttrf(n, dl, d, du, du2, ipiv, info)
        fw_iserr__ = 0
      end subroutine sgttrf_c
      subroutine sgttrs_c(trans, n, nrhs, dl_shape__, dl, d_shape__, d, 
     &du_shape__, du, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b
     &, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgttrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine sgttrs_c
      subroutine sgtts2_c(itrans, n, nrhs, dl_shape__, dl, d_shape__, d,
     & du_shape__, du, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, 
     &b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itrans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0)), dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        real(kind=kind(0.0)), dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sgtts2
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sgtts2(itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb)
        fw_iserr__ = 0
      end subroutine sgtts2_c
      subroutine shgeqz_c(job, compq, compz, n, ilo, ihi, h_shape__, h, 
     &ldh, t_shape__, t, ldt, alphar_shape__, alphar, alphai_shape__, al
     &phai, beta_shape__, beta, q_shape__, q, ldq, z_shape__, z, ldz, wo
     &rk_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compq
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external shgeqz
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call shgeqz(job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alph
     &ar, alphai, beta, q, ldq, z, ldz, work, lwork, info)
        fw_iserr__ = 0
      end subroutine shgeqz_c
      subroutine shsein_c(side, eigsrc, initv, select_shape__, select, n
     &, h_shape__, h, ldh, wr_shape__, wr, wi_shape__, wi, vl_shape__, v
     &l, ldvl, vr_shape__, vr, ldvr, mm, m, work_shape__, work, ifaill_s
     &hape__, ifaill, ifailr_shape__, ifailr, info, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: eigsrc
        character(len=1, kind=kind('a')) :: initv
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1), vl_shape__(2)) ::
     & vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1), vr_shape__(2)) ::
     & vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: ifaill_shape__
        integer, dimension(ifaill_shape__(1)) :: ifaill
        integer, dimension(1) :: ifailr_shape__
        integer, dimension(ifailr_shape__(1)) :: ifailr
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external shsein
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call shsein(side, eigsrc, initv, select, n, h, ldh, wr, wi, vl, 
     &ldvl, vr, ldvr, mm, m, work, ifaill, ifailr, info)
        fw_iserr__ = 0
      end subroutine shsein_c
      subroutine shseqr_c(job, compz, n, ilo, ihi, h_shape__, h, ldh, wr
     &_shape__, wr, wi_shape__, wi, z_shape__, z, ldz, work_shape__, wor
     &k, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0)), dimension(wi_shape__(1)) :: wi
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external shseqr
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call shseqr(job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, wor
     &k, lwork, info)
        fw_iserr__ = 0
      end subroutine shseqr_c
      subroutine sisnan_c(fw_ret_arg, sin, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: fw_ret_arg
        real(kind=kind(0.0)) :: sin
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer(kind=kind(0)) :: sisnan
        external sisnan
        fw_iserr__ = -1
        fw_ret_arg = sisnan(sin)
        fw_iserr__ = 0
      end subroutine sisnan_c
      subroutine sla_gbamv_c(trans, m, n, kl, ku, alpha, ab_shape__, ab,
     & ldab, x_shape__, x, incx, beta, y_shape__, y, incy, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: trans
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        real(kind=kind(0.0)) :: alpha
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sla_gbamv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sla_gbamv(trans, m, n, kl, ku, alpha, ab, ldab, x, incx, be
     &ta, y, incy)
        fw_iserr__ = 0
      end subroutine sla_gbamv_c
      subroutine sla_gbrcond_c(fw_ret_arg, trans, n, kl, ku, ab_shape__,
     & ab, ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, cmode, c_s
     &hape__, c, info, work_shape__, work, iwork_shape__, iwork, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0)), dimension(afb_shape__(1), afb_shape__(2)) 
     &:: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: cmode
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer :: info
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: sla_gbrcond
        external sla_gbrcond
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = sla_gbrcond(trans, n, kl, ku, ab, ldab, afb, ldafb,
     & ipiv, cmode, c, info, work, iwork)
        fw_iserr__ = 0
      end subroutine sla_gbrcond_c
      subroutine sla_gbrfsx_extended_c(prec_type, trans_type, n, kl, ku,
     & nrhs, ab_shape__, ab, ldab, afb_shape__, afb, ldafb, ipiv_shape__
     &, ipiv, colequ, c_shape__, c, b_shape__, b, ldb, y_shape__, y, ldy
     &, berr_out_shape__, berr_out, n_norms, err_bnds_norm_shape__, err_
     &bnds_norm, err_bnds_comp_shape__, err_bnds_comp, res_shape__, res,
     & ayb_shape__, ayb, dy_shape__, dy, y_tail_shape__, y_tail, rcond, 
     &ithresh, rthresh, dz_ub, ignore_cwise, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        integer :: trans_type
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0)), dimension(afb_shape__(1), afb_shape__(2)) 
     &:: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0)), dimension(berr_out_shape__(1)) :: berr_out
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        real(kind=kind(0.0)), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        real(kind=kind(0.0)), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        real(kind=kind(0.0)), dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0)) :: rthresh
        real(kind=kind(0.0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sla_gbrfsx_extended
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sla_gbrfsx_extended(prec_type, trans_type, n, kl, ku, nrhs,
     & ab, ldab, afb, ldafb, ipiv, colequ, c, b, ldb, y, ldy, berr_out, 
     &n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond
     &, ithresh, rthresh, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine sla_gbrfsx_extended_c
      subroutine sla_gbrpvgrw_c(fw_ret_arg, n, kl, ku, ncols, ab_shape__
     &, ab, ldab, afb_shape__, afb, ldafb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        integer :: n
        integer :: kl
        integer :: ku
        integer :: ncols
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0)), dimension(afb_shape__(1), afb_shape__(2)) 
     &:: afb
        integer :: ldafb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: sla_gbrpvgrw
        external sla_gbrpvgrw
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = sla_gbrpvgrw(n, kl, ku, ncols, ab, ldab, afb, ldafb
     &)
        fw_iserr__ = 0
      end subroutine sla_gbrpvgrw_c
      subroutine sla_geamv_c(trans, m, n, alpha, a_shape__, a, lda, x_sh
     &ape__, x, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: trans
        integer :: m
        integer :: n
        real(kind=kind(0.0)) :: alpha
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sla_geamv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sla_geamv(trans, m, n, alpha, a, lda, x, incx, beta, y, inc
     &y)
        fw_iserr__ = 0
      end subroutine sla_geamv_c
      subroutine sla_gercond_c(fw_ret_arg, trans, n, a_shape__, a, lda, 
     &af_shape__, af, ldaf, ipiv_shape__, ipiv, cmode, c_shape__, c, inf
     &o, work_shape__, work, iwork_shape__, iwork, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: cmode
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer :: info
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: sla_gercond
        external sla_gercond
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = sla_gercond(trans, n, a, lda, af, ldaf, ipiv, cmode
     &, c, info, work, iwork)
        fw_iserr__ = 0
      end subroutine sla_gercond_c
      subroutine sla_gerfsx_extended_c(prec_type, trans_type, n, nrhs, a
     &_shape__, a, lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, colequ
     &, c_shape__, c, b_shape__, b, ldb, y_shape__, y, ldy, berr_out_sha
     &pe__, berr_out, n_norms, err_bnds_norm_shape__, err_bnds_norm, err
     &_bnds_comp_shape__, err_bnds_comp, res_shape__, res, ayb_shape__, 
     &ayb, dy_shape__, dy, y_tail_shape__, y_tail, rcond, ithresh, rthre
     &sh, dz_ub, ignore_cwise, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        integer :: trans_type
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0)), dimension(berr_out_shape__(1)) :: berr_out
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        real(kind=kind(0.0)), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        real(kind=kind(0.0)), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        real(kind=kind(0.0)), dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0)) :: rthresh
        real(kind=kind(0.0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sla_gerfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sla_gerfsx_extended(prec_type, trans_type, n, nrhs, a, lda,
     & af, ldaf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err
     &_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, r
     &thresh, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine sla_gerfsx_extended_c
      subroutine sla_lin_berr_c(n, nz, nrhs, res_shape__, res, ayb_shape
     &__, ayb, berr_shape__, berr, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nz
        integer :: nrhs
        integer, dimension(2) :: res_shape__
        real(kind=kind(0.0)), dimension(res_shape__(1), res_shape__(2)) 
     &:: res
        integer, dimension(2) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1), ayb_shape__(2)) 
     &:: ayb
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sla_lin_berr
        fw_iserr__ = -1
        if ((n) .ne. (res_shape__(1)) .or. (nrhs) .lt. 0 .or. (nrhs) .gt
     &. (res_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("res                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .ne. (ayb_shape__(1)) .or. (nrhs) .lt. 0 .or. (nrhs) .gt
     &. (ayb_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ayb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .lt. 0 .or. (nrhs) .gt. (berr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("berr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sla_lin_berr(n, nz, nrhs, res, ayb, berr)
        fw_iserr__ = 0
      end subroutine sla_lin_berr_c
      subroutine sla_porcond_c(fw_ret_arg, uplo, n, a_shape__, a, lda, a
     &f_shape__, af, ldaf, cmode, c_shape__, c, info, work_shape__, work
     &, iwork_shape__, iwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer :: cmode
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer :: info
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: sla_porcond
        external sla_porcond
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = sla_porcond(uplo, n, a, lda, af, ldaf, cmode, c, in
     &fo, work, iwork)
        fw_iserr__ = 0
      end subroutine sla_porcond_c
      subroutine sla_porfsx_extended_c(prec_type, uplo, n, nrhs, a_shape
     &__, a, lda, af_shape__, af, ldaf, colequ, c_shape__, c, b_shape__,
     & b, ldb, y_shape__, y, ldy, berr_out_shape__, berr_out, n_norms, e
     &rr_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bn
     &ds_comp, res_shape__, res, ayb_shape__, ayb, dy_shape__, dy, y_tai
     &l_shape__, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0)), dimension(berr_out_shape__(1)) :: berr_out
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        real(kind=kind(0.0)), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        real(kind=kind(0.0)), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        real(kind=kind(0.0)), dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0)) :: rthresh
        real(kind=kind(0.0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sla_porfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sla_porfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, l
     &daf, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, 
     &err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_u
     &b, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine sla_porfsx_extended_c
      subroutine sla_porpvgrw_c(fw_ret_arg, uplo, ncols, a_shape__, a, l
     &da, af_shape__, af, ldaf, work_shape__, work, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1) :: uplo
        integer :: ncols
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: sla_porpvgrw
        external sla_porpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = sla_porpvgrw(uplo, ncols, a, lda, af, ldaf, work)
        fw_iserr__ = 0
      end subroutine sla_porpvgrw_c
      subroutine sla_rpvgrw_c(fw_ret_arg, n, ncols, a_shape__, a, lda, a
     &f_shape__, af, ldaf, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        integer :: n
        integer :: ncols
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: sla_rpvgrw
        external sla_rpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = sla_rpvgrw(n, ncols, a, lda, af, ldaf)
        fw_iserr__ = 0
      end subroutine sla_rpvgrw_c
      subroutine sla_syamv_c(uplo, n, alpha, a_shape__, a, lda, x_shape_
     &_, x, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: uplo
        integer :: n
        real(kind=kind(0.0)) :: alpha
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sla_syamv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sla_syamv(uplo, n, alpha, a, lda, x, incx, beta, y, incy)
        fw_iserr__ = 0
      end subroutine sla_syamv_c
      subroutine sla_syrcond_c(fw_ret_arg, uplo, n, a_shape__, a, lda, a
     &f_shape__, af, ldaf, ipiv_shape__, ipiv, cmode, c_shape__, c, info
     &, work_shape__, work, iwork_shape__, iwork, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: cmode
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer :: info
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: sla_syrcond
        external sla_syrcond
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = sla_syrcond(uplo, n, a, lda, af, ldaf, ipiv, cmode,
     & c, info, work, iwork)
        fw_iserr__ = 0
      end subroutine sla_syrcond_c
      subroutine sla_syrfsx_extended_c(prec_type, uplo, n, nrhs, a_shape
     &__, a, lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, colequ, c_sh
     &ape__, c, b_shape__, b, ldb, y_shape__, y, ldy, berr_out_shape__, 
     &berr_out, n_norms, err_bnds_norm_shape__, err_bnds_norm, err_bnds_
     &comp_shape__, err_bnds_comp, res_shape__, res, ayb_shape__, ayb, d
     &y_shape__, dy, y_tail_shape__, y_tail, rcond, ithresh, rthresh, dz
     &_ub, ignore_cwise, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0)), dimension(berr_out_shape__(1)) :: berr_out
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        real(kind=kind(0.0)), dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        real(kind=kind(0.0)), dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        real(kind=kind(0.0)), dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0)) :: rthresh
        real(kind=kind(0.0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sla_syrfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sla_syrfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, l
     &daf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_
     &norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh
     &, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine sla_syrfsx_extended_c
      subroutine sla_syrpvgrw_c(fw_ret_arg, uplo, n, info, a_shape__, a,
     & lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, work_shape__, work
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1) :: uplo
        integer :: n
        integer :: info
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: sla_syrpvgrw
        external sla_syrpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = sla_syrpvgrw(uplo, n, info, a, lda, af, ldaf, ipiv,
     & work)
        fw_iserr__ = 0
      end subroutine sla_syrpvgrw_c
      subroutine sla_wwaddw_c(n, x_shape__, x, y_shape__, y, w_shape__, 
     &w, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sla_wwaddw
        fw_iserr__ = -1
        call sla_wwaddw(n, x, y, w)
        fw_iserr__ = 0
      end subroutine sla_wwaddw_c
      subroutine slabad_c(small, large, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: small
        real(kind=kind(0.0)) :: large
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slabad
        fw_iserr__ = -1
        call slabad(small, large)
        fw_iserr__ = 0
      end subroutine slabad_c
      subroutine slabrd_c(m, n, nb, a_shape__, a, lda, d_shape__, d, e_s
     &hape__, e, tauq_shape__, tauq, taup_shape__, taup, x_shape__, x, l
     &dx, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        real(kind=kind(0.0)), dimension(tauq_shape__(1)) :: tauq
        integer, dimension(1) :: taup_shape__
        real(kind=kind(0.0)), dimension(taup_shape__(1)) :: taup
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slabrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slabrd(m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y, ldy)
        fw_iserr__ = 0
      end subroutine slabrd_c
      subroutine slacn2_c(n, v_shape__, v, x_shape__, x, isgn_shape__, i
     &sgn, est, kase, isave_shape__, isave, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1)) :: v
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: isgn_shape__
        integer, dimension(isgn_shape__(1)) :: isgn
        real(kind=kind(0.0)) :: est
        integer :: kase
        integer, dimension(1) :: isave_shape__
        integer, dimension(isave_shape__(1)) :: isave
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slacn2
        fw_iserr__ = -1
        if ((3) .lt. 0 .or. (3) .gt. (isave_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("isave                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slacn2(n, v, x, isgn, est, kase, isave)
        fw_iserr__ = 0
      end subroutine slacn2_c
      subroutine slacon_c(n, v_shape__, v, x_shape__, x, isgn_shape__, i
     &sgn, est, kase, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1)) :: v
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: isgn_shape__
        integer, dimension(isgn_shape__(1)) :: isgn
        real(kind=kind(0.0)) :: est
        integer :: kase
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slacon
        fw_iserr__ = -1
        call slacon(n, v, x, isgn, est, kase)
        fw_iserr__ = 0
      end subroutine slacon_c
      subroutine slacpy_c(uplo, m, n, a_shape__, a, lda, b_shape__, b, l
     &db, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slacpy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slacpy(uplo, m, n, a, lda, b, ldb)
        fw_iserr__ = 0
      end subroutine slacpy_c
      subroutine sladiv_c(a, b, c, d, p, q, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: a
        real(kind=kind(0.0)) :: b
        real(kind=kind(0.0)) :: c
        real(kind=kind(0.0)) :: d
        real(kind=kind(0.0)) :: p
        real(kind=kind(0.0)) :: q
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sladiv
        fw_iserr__ = -1
        call sladiv(a, b, c, d, p, q)
        fw_iserr__ = 0
      end subroutine sladiv_c
      subroutine slae2_c(a, b, c, rt1, rt2, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: a
        real(kind=kind(0.0)) :: b
        real(kind=kind(0.0)) :: c
        real(kind=kind(0.0)) :: rt1
        real(kind=kind(0.0)) :: rt2
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slae2
        fw_iserr__ = -1
        call slae2(a, b, c, rt1, rt2)
        fw_iserr__ = 0
      end subroutine slae2_c
      subroutine slaebz_c(ijob, nitmax, n, mmax, minp, nbmin, abstol, re
     &ltol, pivmin, d_shape__, d, e_shape__, e, e2_shape__, e2, nval_sha
     &pe__, nval, ab_shape__, ab, c_shape__, c, mout, nab_shape__, nab, 
     &work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: ijob
        integer :: nitmax
        integer :: n
        integer :: mmax
        integer :: minp
        integer :: nbmin
        real(kind=kind(0.0)) :: abstol
        real(kind=kind(0.0)) :: reltol
        real(kind=kind(0.0)) :: pivmin
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0)), dimension(e2_shape__(1)) :: e2
        integer, dimension(1) :: nval_shape__
        integer, dimension(nval_shape__(1)) :: nval
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer :: mout
        integer, dimension(2) :: nab_shape__
        integer, dimension(nab_shape__(1), nab_shape__(2)) :: nab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaebz
        fw_iserr__ = -1
        if ((mmax) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((mmax) .ne. (nab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("nab                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaebz(ijob, nitmax, n, mmax, minp, nbmin, abstol, reltol, 
     &pivmin, d, e, e2, nval, ab, c, mout, nab, work, iwork, info)
        fw_iserr__ = 0
      end subroutine slaebz_c
      subroutine slaed0_c(icompq, qsiz, n, d_shape__, d, e_shape__, e, q
     &_shape__, q, ldq, qstore_shape__, qstore, ldqs, work_shape__, work
     &, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: qsiz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: qstore_shape__
        real(kind=kind(0.0)), dimension(qstore_shape__(1), qstore_shape_
     &_(2)) :: qstore
        integer :: ldqs
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaed0
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldqs) .ne. (qstore_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("qstore                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaed0(icompq, qsiz, n, d, e, q, ldq, qstore, ldqs, work, i
     &work, info)
        fw_iserr__ = 0
      end subroutine slaed0_c
      subroutine slaed1_c(n, d_shape__, d, q_shape__, q, ldq, indxq_shap
     &e__, indxq, rho, cutpnt, work_shape__, work, iwork_shape__, iwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        real(kind=kind(0.0)) :: rho
        integer :: cutpnt
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaed1
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaed1(n, d, q, ldq, indxq, rho, cutpnt, work, iwork, info)
        fw_iserr__ = 0
      end subroutine slaed1_c
      subroutine slaed2_c(k, n, n1, d_shape__, d, q_shape__, q, ldq, ind
     &xq_shape__, indxq, rho, z_shape__, z, dlamda_shape__, dlamda, w_sh
     &ape__, w, q2_shape__, q2, indx_shape__, indx, indxc_shape__, indxc
     &, indxp_shape__, indxp, coltyp_shape__, coltyp, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: k
        integer :: n
        integer :: n1
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        real(kind=kind(0.0)) :: rho
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: dlamda_shape__
        real(kind=kind(0.0)), dimension(dlamda_shape__(1)) :: dlamda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: q2_shape__
        real(kind=kind(0.0)), dimension(q2_shape__(1)) :: q2
        integer, dimension(1) :: indx_shape__
        integer, dimension(indx_shape__(1)) :: indx
        integer, dimension(1) :: indxc_shape__
        integer, dimension(indxc_shape__(1)) :: indxc
        integer, dimension(1) :: indxp_shape__
        integer, dimension(indxp_shape__(1)) :: indxp
        integer, dimension(1) :: coltyp_shape__
        integer, dimension(coltyp_shape__(1)) :: coltyp
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaed2
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaed2(k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w, q2, i
     &ndx, indxc, indxp, coltyp, info)
        fw_iserr__ = 0
      end subroutine slaed2_c
      subroutine slaed3_c(k, n, n1, d_shape__, d, q_shape__, q, ldq, rho
     &, dlamda_shape__, dlamda, q2_shape__, q2, indx_shape__, indx, ctot
     &_shape__, ctot, w_shape__, w, s_shape__, s, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: k
        integer :: n
        integer :: n1
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        real(kind=kind(0.0)) :: rho
        integer, dimension(1) :: dlamda_shape__
        real(kind=kind(0.0)), dimension(dlamda_shape__(1)) :: dlamda
        integer, dimension(1) :: q2_shape__
        real(kind=kind(0.0)), dimension(q2_shape__(1)) :: q2
        integer, dimension(1) :: indx_shape__
        integer, dimension(indx_shape__(1)) :: indx
        integer, dimension(1) :: ctot_shape__
        integer, dimension(ctot_shape__(1)) :: ctot
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaed3
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaed3(k, n, n1, d, q, ldq, rho, dlamda, q2, indx, ctot, w,
     & s, info)
        fw_iserr__ = 0
      end subroutine slaed3_c
      subroutine slaed4_c(n, i, d_shape__, d, z_shape__, z, delta_shape_
     &_, delta, rho, dlam, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: i
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: delta_shape__
        real(kind=kind(0.0)), dimension(delta_shape__(1)) :: delta
        real(kind=kind(0.0)) :: rho
        real(kind=kind(0.0)) :: dlam
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaed4
        fw_iserr__ = -1
        call slaed4(n, i, d, z, delta, rho, dlam, info)
        fw_iserr__ = 0
      end subroutine slaed4_c
      subroutine slaed5_c(i, d_shape__, d, z_shape__, z, delta_shape__, 
     &delta, rho, dlam, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: delta_shape__
        real(kind=kind(0.0)), dimension(delta_shape__(1)) :: delta
        real(kind=kind(0.0)) :: rho
        real(kind=kind(0.0)) :: dlam
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaed5
        fw_iserr__ = -1
        if ((2) .lt. 0 .or. (2) .gt. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (delta_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("delta                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaed5(i, d, z, delta, rho, dlam)
        fw_iserr__ = 0
      end subroutine slaed5_c
      subroutine slaed6_c(kniter, orgati, rho, d_shape__, d, z_shape__, 
     &z, finit, tau, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: kniter
        integer(kind=kind(0)) :: orgati
        real(kind=kind(0.0)) :: rho
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        real(kind=kind(0.0)) :: finit
        real(kind=kind(0.0)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaed6
        fw_iserr__ = -1
        if ((3) .lt. 0 .or. (3) .gt. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((3) .lt. 0 .or. (3) .gt. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaed6(kniter, orgati, rho, d, z, finit, tau, info)
        fw_iserr__ = 0
      end subroutine slaed6_c
      subroutine slaed7_c(icompq, n, qsiz, tlvls, curlvl, curpbm, d_shap
     &e__, d, q_shape__, q, ldq, indxq_shape__, indxq, rho, cutpnt, qsto
     &re_shape__, qstore, qptr_shape__, qptr, prmptr_shape__, prmptr, pe
     &rm_shape__, perm, givptr_shape__, givptr, givcol_shape__, givcol, 
     &givnum_shape__, givnum, work_shape__, work, iwork_shape__, iwork, 
     &info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: n
        integer :: qsiz
        integer :: tlvls
        integer :: curlvl
        integer :: curpbm
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        real(kind=kind(0.0)) :: rho
        integer :: cutpnt
        integer, dimension(1) :: qstore_shape__
        real(kind=kind(0.0)), dimension(qstore_shape__(1)) :: qstore
        integer, dimension(1) :: qptr_shape__
        integer, dimension(qptr_shape__(1)) :: qptr
        integer, dimension(1) :: prmptr_shape__
        integer, dimension(prmptr_shape__(1)) :: prmptr
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaed7
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaed7(icompq, n, qsiz, tlvls, curlvl, curpbm, d, q, ldq, i
     &ndxq, rho, cutpnt, qstore, qptr, prmptr, perm, givptr, givcol, giv
     &num, work, iwork, info)
        fw_iserr__ = 0
      end subroutine slaed7_c
      subroutine slaed8_c(icompq, k, n, qsiz, d_shape__, d, q_shape__, q
     &, ldq, indxq_shape__, indxq, rho, cutpnt, z_shape__, z, dlamda_sha
     &pe__, dlamda, q2_shape__, q2, ldq2, w_shape__, w, perm_shape__, pe
     &rm, givptr, givcol_shape__, givcol, givnum_shape__, givnum, indxp_
     &shape__, indxp, indx_shape__, indx, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: k
        integer :: n
        integer :: qsiz
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        real(kind=kind(0.0)) :: rho
        integer :: cutpnt
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: dlamda_shape__
        real(kind=kind(0.0)), dimension(dlamda_shape__(1)) :: dlamda
        integer, dimension(2) :: q2_shape__
        real(kind=kind(0.0)), dimension(q2_shape__(1), q2_shape__(2)) ::
     & q2
        integer :: ldq2
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer, dimension(1) :: indxp_shape__
        integer, dimension(indxp_shape__(1)) :: indxp
        integer, dimension(1) :: indx_shape__
        integer, dimension(indx_shape__(1)) :: indx
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaed8
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq2) .ne. (q2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaed8(icompq, k, n, qsiz, d, q, ldq, indxq, rho, cutpnt, z
     &, dlamda, q2, ldq2, w, perm, givptr, givcol, givnum, indxp, indx, 
     &info)
        fw_iserr__ = 0
      end subroutine slaed8_c
      subroutine slaed9_c(k, kstart, kstop, n, d_shape__, d, q_shape__, 
     &q, ldq, rho, dlamda_shape__, dlamda, w_shape__, w, s_shape__, s, l
     &ds, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: k
        integer :: kstart
        integer :: kstop
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        real(kind=kind(0.0)) :: rho
        integer, dimension(1) :: dlamda_shape__
        real(kind=kind(0.0)), dimension(dlamda_shape__(1)) :: dlamda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1), s_shape__(2)) :: s
        integer :: lds
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaed9
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lds) .ne. (s_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("s                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaed9(k, kstart, kstop, n, d, q, ldq, rho, dlamda, w, s, l
     &ds, info)
        fw_iserr__ = 0
      end subroutine slaed9_c
      subroutine slaeda_c(n, tlvls, curlvl, curpbm, prmptr_shape__, prmp
     &tr, perm_shape__, perm, givptr_shape__, givptr, givcol_shape__, gi
     &vcol, givnum_shape__, givnum, q_shape__, q, qptr_shape__, qptr, z_
     &shape__, z, ztemp_shape__, ztemp, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: tlvls
        integer :: curlvl
        integer :: curpbm
        integer, dimension(1) :: prmptr_shape__
        integer, dimension(prmptr_shape__(1)) :: prmptr
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer, dimension(1) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1)) :: q
        integer, dimension(1) :: qptr_shape__
        integer, dimension(qptr_shape__(1)) :: qptr
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: ztemp_shape__
        real(kind=kind(0.0)), dimension(ztemp_shape__(1)) :: ztemp
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaeda
        fw_iserr__ = -1
        if ((2) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaeda(n, tlvls, curlvl, curpbm, prmptr, perm, givptr, givc
     &ol, givnum, q, qptr, z, ztemp, info)
        fw_iserr__ = 0
      end subroutine slaeda_c
      subroutine slaein_c(rightv, noinit, n, h_shape__, h, ldh, wr, wi, 
     &vr_shape__, vr, vi_shape__, vi, b_shape__, b, ldb, work_shape__, w
     &ork, eps3, smlnum, bignum, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: rightv
        integer(kind=kind(0)) :: noinit
        integer :: n
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        real(kind=kind(0.0)) :: wr
        real(kind=kind(0.0)) :: wi
        integer, dimension(1) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1)) :: vr
        integer, dimension(1) :: vi_shape__
        real(kind=kind(0.0)), dimension(vi_shape__(1)) :: vi
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        real(kind=kind(0.0)) :: eps3
        real(kind=kind(0.0)) :: smlnum
        real(kind=kind(0.0)) :: bignum
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaein
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaein(rightv, noinit, n, h, ldh, wr, wi, vr, vi, b, ldb, w
     &ork, eps3, smlnum, bignum, info)
        fw_iserr__ = 0
      end subroutine slaein_c
      subroutine slaev2_c(a, b, c, rt1, rt2, cs1, sn1, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: a
        real(kind=kind(0.0)) :: b
        real(kind=kind(0.0)) :: c
        real(kind=kind(0.0)) :: rt1
        real(kind=kind(0.0)) :: rt2
        real(kind=kind(0.0)) :: cs1
        real(kind=kind(0.0)) :: sn1
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaev2
        fw_iserr__ = -1
        call slaev2(a, b, c, rt1, rt2, cs1, sn1)
        fw_iserr__ = 0
      end subroutine slaev2_c
      subroutine slaexc_c(wantq, n, t_shape__, t, ldt, q_shape__, q, ldq
     &, j1, n1, n2, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantq
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer :: j1
        integer :: n1
        integer :: n2
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaexc
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaexc(wantq, n, t, ldt, q, ldq, j1, n1, n2, work, info)
        fw_iserr__ = 0
      end subroutine slaexc_c
      subroutine slag2_c(a_shape__, a, lda, b_shape__, b, ldb, safmin, s
     &cale1, scale2, wr1, wr2, wi, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: safmin
        real(kind=kind(0.0)) :: scale1
        real(kind=kind(0.0)) :: scale2
        real(kind=kind(0.0)) :: wr1
        real(kind=kind(0.0)) :: wr2
        real(kind=kind(0.0)) :: wi
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slag2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slag2(a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2, wi)
        fw_iserr__ = 0
      end subroutine slag2_c
      subroutine slag2d_c(m, n, sa_shape__, sa, ldsa, a_shape__, a, lda,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: sa_shape__
        real(kind=kind(0.0)), dimension(sa_shape__(1), sa_shape__(2)) ::
     & sa
        integer :: ldsa
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slag2d
        fw_iserr__ = -1
        if ((ldsa) .ne. (sa_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sa                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slag2d(m, n, sa, ldsa, a, lda, info)
        fw_iserr__ = 0
      end subroutine slag2d_c
      subroutine slags2_c(upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, 
     &snv, csq, snq, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: upper
        real(kind=kind(0.0)) :: a1
        real(kind=kind(0.0)) :: a2
        real(kind=kind(0.0)) :: a3
        real(kind=kind(0.0)) :: b1
        real(kind=kind(0.0)) :: b2
        real(kind=kind(0.0)) :: b3
        real(kind=kind(0.0)) :: csu
        real(kind=kind(0.0)) :: snu
        real(kind=kind(0.0)) :: csv
        real(kind=kind(0.0)) :: snv
        real(kind=kind(0.0)) :: csq
        real(kind=kind(0.0)) :: snq
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slags2
        fw_iserr__ = -1
        call slags2(upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, snv, c
     &sq, snq)
        fw_iserr__ = 0
      end subroutine slags2_c
      subroutine slagtf_c(n, a_shape__, a, lambda, b_shape__, b, c_shape
     &__, c, tol, d_shape__, d, in_shape__, in, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1)) :: a
        real(kind=kind(0.0)) :: lambda
        integer, dimension(1) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1)) :: b
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: tol
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: in_shape__
        integer, dimension(in_shape__(1)) :: in
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slagtf
        fw_iserr__ = -1
        call slagtf(n, a, lambda, b, c, tol, d, in, info)
        fw_iserr__ = 0
      end subroutine slagtf_c
      subroutine slagtm_c(trans, n, nrhs, alpha, dl_shape__, dl, d_shape
     &__, d, du_shape__, du, x_shape__, x, ldx, beta, b_shape__, b, ldb,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        real(kind=kind(0.0)) :: alpha
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0)), dimension(du_shape__(1)) :: du
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: beta
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slagtm
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slagtm(trans, n, nrhs, alpha, dl, d, du, x, ldx, beta, b, l
     &db)
        fw_iserr__ = 0
      end subroutine slagtm_c
      subroutine slagts_c(job, n, a_shape__, a, b_shape__, b, c_shape__,
     & c, d_shape__, d, in_shape__, in, y_shape__, y, tol, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: job
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1)) :: a
        integer, dimension(1) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1)) :: b
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: in_shape__
        integer, dimension(in_shape__(1)) :: in
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        real(kind=kind(0.0)) :: tol
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slagts
        fw_iserr__ = -1
        call slagts(job, n, a, b, c, d, in, y, tol, info)
        fw_iserr__ = 0
      end subroutine slagts_c
      subroutine slagv2_c(a_shape__, a, lda, b_shape__, b, ldb, alphar_s
     &hape__, alphar, alphai_shape__, alphai, beta_shape__, beta, csl, s
     &nl, csr, snr, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        real(kind=kind(0.0)) :: csl
        real(kind=kind(0.0)) :: snl
        real(kind=kind(0.0)) :: csr
        real(kind=kind(0.0)) :: snr
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slagv2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (alphar_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("alphar                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (alphai_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("alphai                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (beta_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("beta                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slagv2(a, lda, b, ldb, alphar, alphai, beta, csl, snl, csr,
     & snr)
        fw_iserr__ = 0
      end subroutine slagv2_c
      subroutine slahqr_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &wr_shape__, wr, wi_shape__, wi, iloz, ihiz, z_shape__, z, ldz, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0)), dimension(wi_shape__(1)) :: wi
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slahqr
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slahqr(wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihi
     &z, z, ldz, info)
        fw_iserr__ = 0
      end subroutine slahqr_c
      subroutine slahr2_c(n, k, nb, a_shape__, a, lda, tau_shape__, tau,
     & t_shape__, t, ldt, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: k
        integer :: nb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slahr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nb) .lt. 0 .or. (nb) .gt. (tau_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tau                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (t
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (y
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slahr2(n, k, nb, a, lda, tau, t, ldt, y, ldy)
        fw_iserr__ = 0
      end subroutine slahr2_c
      subroutine slahrd_c(n, k, nb, a_shape__, a, lda, tau_shape__, tau,
     & t_shape__, t, ldt, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: k
        integer :: nb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slahrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nb) .lt. 0 .or. (nb) .gt. (tau_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tau                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (t
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (y
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slahrd(n, k, nb, a, lda, tau, t, ldt, y, ldy)
        fw_iserr__ = 0
      end subroutine slahrd_c
      subroutine slaic1_c(job, j, x_shape__, x, sest, w_shape__, w, gamm
     &a, sestpr, s, c, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: job
        integer :: j
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0)) :: sest
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        real(kind=kind(0.0)) :: gamma
        real(kind=kind(0.0)) :: sestpr
        real(kind=kind(0.0)) :: s
        real(kind=kind(0.0)) :: c
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaic1
        fw_iserr__ = -1
        if ((j) .lt. 0 .or. (j) .gt. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((j) .lt. 0 .or. (j) .gt. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaic1(job, j, x, sest, w, gamma, sestpr, s, c)
        fw_iserr__ = 0
      end subroutine slaic1_c
      subroutine slaisnan_c(fw_ret_arg, sin1, sin2, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: fw_ret_arg
        real(kind=kind(0.0)) :: sin1
        real(kind=kind(0.0)) :: sin2
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer(kind=kind(0)) :: slaisnan
        external slaisnan
        fw_iserr__ = -1
        fw_ret_arg = slaisnan(sin1, sin2)
        fw_iserr__ = 0
      end subroutine slaisnan_c
      subroutine slaln2_c(ltrans, na, nw, smin, ca, a_shape__, a, lda, d
     &1, d2, b_shape__, b, ldb, wr, wi, x_shape__, x, ldx, scale, xnorm,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: ltrans
        integer :: na
        integer :: nw
        real(kind=kind(0.0)) :: smin
        real(kind=kind(0.0)) :: ca
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: d1
        real(kind=kind(0.0)) :: d2
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: wr
        real(kind=kind(0.0)) :: wi
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: scale
        real(kind=kind(0.0)) :: xnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaln2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaln2(ltrans, na, nw, smin, ca, a, lda, d1, d2, b, ldb, wr
     &, wi, x, ldx, scale, xnorm, info)
        fw_iserr__ = 0
      end subroutine slaln2_c
      subroutine slals0_c(icompq, nl, nr, sqre, nrhs, b_shape__, b, ldb,
     & bx_shape__, bx, ldbx, perm_shape__, perm, givptr, givcol_shape__,
     & givcol, ldgcol, givnum_shape__, givnum, ldgnum, poles_shape__, po
     &les, difl_shape__, difl, difr_shape__, difr, z_shape__, z, k, c, s
     &, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: nl
        integer :: nr
        integer :: sqre
        integer :: nrhs
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: bx_shape__
        real(kind=kind(0.0)), dimension(bx_shape__(1), bx_shape__(2)) ::
     & bx
        integer :: ldbx
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer :: ldgnum
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0)), dimension(poles_shape__(1), poles_shape__(
     &2)) :: poles
        integer, dimension(1) :: difl_shape__
        real(kind=kind(0.0)), dimension(difl_shape__(1)) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0)), dimension(difr_shape__(1), difr_shape__(2)
     &) :: difr
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer :: k
        real(kind=kind(0.0)) :: c
        real(kind=kind(0.0)) :: s
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slals0
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbx) .ne. (bx_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bx                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slals0(icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx, perm, 
     &givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z, k, c
     &, s, work, info)
        fw_iserr__ = 0
      end subroutine slals0_c
      subroutine slalsa_c(icompq, smlsiz, n, nrhs, b_shape__, b, ldb, bx
     &_shape__, bx, ldbx, u_shape__, u, ldu, vt_shape__, vt, k_shape__, 
     &k, difl_shape__, difl, difr_shape__, difr, z_shape__, z, poles_sha
     &pe__, poles, givptr_shape__, givptr, givcol_shape__, givcol, ldgco
     &l, perm_shape__, perm, givnum_shape__, givnum, c_shape__, c, s_sha
     &pe__, s, work_shape__, work, iwork_shape__, iwork, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: smlsiz
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: bx_shape__
        real(kind=kind(0.0)), dimension(bx_shape__(1), bx_shape__(2)) ::
     & bx
        integer :: ldbx
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer, dimension(2) :: difl_shape__
        real(kind=kind(0.0)), dimension(difl_shape__(1), difl_shape__(2)
     &) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0)), dimension(difr_shape__(1), difr_shape__(2)
     &) :: difr
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0)), dimension(poles_shape__(1), poles_shape__(
     &2)) :: poles
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: perm_shape__
        integer, dimension(perm_shape__(1), perm_shape__(2)) :: perm
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slalsa
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbx) .ne. (bx_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bx                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difl                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (perm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("perm                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slalsa(icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, v
     &t, k, difl, difr, z, poles, givptr, givcol, ldgcol, perm, givnum, 
     &c, s, work, iwork, info)
        fw_iserr__ = 0
      end subroutine slalsa_c
      subroutine slalsd_c(uplo, smlsiz, n, nrhs, d_shape__, d, e_shape__
     &, e, b_shape__, b, ldb, rcond, rank, work_shape__, work, iwork_sha
     &pe__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: smlsiz
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slalsd
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slalsd(uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond, rank, wo
     &rk, iwork, info)
        fw_iserr__ = 0
      end subroutine slalsd_c
      subroutine slamrg_c(n1, n2, a_shape__, a, strd1, strd2, index_shap
     &e__, index, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n1
        integer :: n2
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1)) :: a
        integer :: strd1
        integer :: strd2
        integer, dimension(1) :: index_shape__
        integer, dimension(index_shape__(1)) :: index
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slamrg
        fw_iserr__ = -1
        call slamrg(n1, n2, a, strd1, strd2, index)
        fw_iserr__ = 0
      end subroutine slamrg_c
      subroutine slaneg_c(fw_ret_arg, n, d_shape__, d, lld_shape__, lld,
     & sigma, pivmin, r, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: fw_ret_arg
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: lld_shape__
        real(kind=kind(0.0)), dimension(lld_shape__(1)) :: lld
        real(kind=kind(0.0)) :: sigma
        real(kind=kind(0.0)) :: pivmin
        integer :: r
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        integer :: slaneg
        external slaneg
        fw_iserr__ = -1
        fw_ret_arg = slaneg(n, d, lld, sigma, pivmin, r)
        fw_iserr__ = 0
      end subroutine slaneg_c
      subroutine slangb_c(fw_ret_arg, norm, n, kl, ku, ab_shape__, ab, l
     &dab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slangb
        external slangb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = slangb(norm, n, kl, ku, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine slangb_c
      subroutine slange_c(fw_ret_arg, norm, m, n, a_shape__, a, lda, wor
     &k_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slange
        external slange
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = slange(norm, m, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine slange_c
      subroutine slangt_c(fw_ret_arg, norm, n, dl_shape__, dl, d_shape__
     &, d, du_shape__, du, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: dl_shape__
        real(kind=kind(0.0)), dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        real(kind=kind(0.0)), dimension(du_shape__(1)) :: du
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slangt
        external slangt
        fw_iserr__ = -1
        fw_ret_arg = slangt(norm, n, dl, d, du)
        fw_iserr__ = 0
      end subroutine slangt_c
      subroutine slanhs_c(fw_ret_arg, norm, n, a_shape__, a, lda, work_s
     &hape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slanhs
        external slanhs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = slanhs(norm, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine slanhs_c
      subroutine slansb_c(fw_ret_arg, norm, uplo, n, k, ab_shape__, ab, 
     &ldab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: k
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slansb
        external slansb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = slansb(norm, uplo, n, k, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine slansb_c
      subroutine slansf_c(fw_ret_arg, norm, transr, uplo, n, a_shape__, 
     &a, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1)) :: a
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slansf
        external slansf
        fw_iserr__ = -1
        fw_ret_arg = slansf(norm, transr, uplo, n, a, work)
        fw_iserr__ = 0
      end subroutine slansf_c
      subroutine slansp_c(fw_ret_arg, norm, uplo, n, ap_shape__, ap, wor
     &k_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slansp
        external slansp
        fw_iserr__ = -1
        fw_ret_arg = slansp(norm, uplo, n, ap, work)
        fw_iserr__ = 0
      end subroutine slansp_c
      subroutine slanst_c(fw_ret_arg, norm, n, d_shape__, d, e_shape__, 
     &e, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slanst
        external slanst
        fw_iserr__ = -1
        fw_ret_arg = slanst(norm, n, d, e)
        fw_iserr__ = 0
      end subroutine slanst_c
      subroutine slansy_c(fw_ret_arg, norm, uplo, n, a_shape__, a, lda, 
     &work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slansy
        external slansy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = slansy(norm, uplo, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine slansy_c
      subroutine slantb_c(fw_ret_arg, norm, uplo, diag, n, k, ab_shape__
     &, ab, ldab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: k
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slantb
        external slantb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = slantb(norm, uplo, diag, n, k, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine slantb_c
      subroutine slantp_c(fw_ret_arg, norm, uplo, diag, n, ap_shape__, a
     &p, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slantp
        external slantp
        fw_iserr__ = -1
        fw_ret_arg = slantp(norm, uplo, diag, n, ap, work)
        fw_iserr__ = 0
      end subroutine slantp_c
      subroutine slantr_c(fw_ret_arg, norm, uplo, diag, m, n, a_shape__,
     & a, lda, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slantr
        external slantr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = slantr(norm, uplo, diag, m, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine slantr_c
      subroutine slanv2_c(a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: a
        real(kind=kind(0.0)) :: b
        real(kind=kind(0.0)) :: c
        real(kind=kind(0.0)) :: d
        real(kind=kind(0.0)) :: rt1r
        real(kind=kind(0.0)) :: rt1i
        real(kind=kind(0.0)) :: rt2r
        real(kind=kind(0.0)) :: rt2i
        real(kind=kind(0.0)) :: cs
        real(kind=kind(0.0)) :: sn
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slanv2
        fw_iserr__ = -1
        call slanv2(a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn)
        fw_iserr__ = 0
      end subroutine slanv2_c
      subroutine slapll_c(n, x_shape__, x, incx, y_shape__, y, incy, ssm
     &in, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer :: incy
        real(kind=kind(0.0)) :: ssmin
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slapll
        fw_iserr__ = -1
        call slapll(n, x, incx, y, incy, ssmin)
        fw_iserr__ = 0
      end subroutine slapll_c
      subroutine slapmr_c(forwrd, m, n, x_shape__, x, ldx, k_shape__, k,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: forwrd
        integer :: m
        integer :: n
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slapmr
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slapmr(forwrd, m, n, x, ldx, k)
        fw_iserr__ = 0
      end subroutine slapmr_c
      subroutine slapmt_c(forwrd, m, n, x_shape__, x, ldx, k_shape__, k,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: forwrd
        integer :: m
        integer :: n
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slapmt
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slapmt(forwrd, m, n, x, ldx, k)
        fw_iserr__ = 0
      end subroutine slapmt_c
      subroutine slapy2_c(fw_ret_arg, x, y, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        real(kind=kind(0.0)) :: x
        real(kind=kind(0.0)) :: y
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slapy2
        external slapy2
        fw_iserr__ = -1
        fw_ret_arg = slapy2(x, y)
        fw_iserr__ = 0
      end subroutine slapy2_c
      subroutine slapy3_c(fw_ret_arg, x, y, z, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: fw_ret_arg
        real(kind=kind(0.0)) :: x
        real(kind=kind(0.0)) :: y
        real(kind=kind(0.0)) :: z
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0)) :: slapy3
        external slapy3
        fw_iserr__ = -1
        fw_ret_arg = slapy3(x, y, z)
        fw_iserr__ = 0
      end subroutine slapy3_c
      subroutine slaqgb_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__,
     & r, c_shape__, c, rowcnd, colcnd, amax, equed, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqgb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqgb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, 
     &equed)
        fw_iserr__ = 0
      end subroutine slaqgb_c
      subroutine slaqge_c(m, n, a_shape__, a, lda, r_shape__, r, c_shape
     &__, c, rowcnd, colcnd, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0)) :: rowcnd
        real(kind=kind(0.0)) :: colcnd
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqge
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqge(m, n, a, lda, r, c, rowcnd, colcnd, amax, equed)
        fw_iserr__ = 0
      end subroutine slaqge_c
      subroutine slaqp2_c(m, n, offset, a_shape__, a, lda, jpvt_shape__,
     & jpvt, tau_shape__, tau, vn1_shape__, vn1, vn2_shape__, vn2, work_
     &shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: offset
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: vn1_shape__
        real(kind=kind(0.0)), dimension(vn1_shape__(1)) :: vn1
        integer, dimension(1) :: vn2_shape__
        real(kind=kind(0.0)), dimension(vn2_shape__(1)) :: vn2
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqp2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqp2(m, n, offset, a, lda, jpvt, tau, vn1, vn2, work)
        fw_iserr__ = 0
      end subroutine slaqp2_c
      subroutine slaqps_c(m, n, offset, nb, kb, a_shape__, a, lda, jpvt_
     &shape__, jpvt, tau_shape__, tau, vn1_shape__, vn1, vn2_shape__, vn
     &2, auxv_shape__, auxv, f_shape__, f, ldf, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: offset
        integer :: nb
        integer :: kb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: vn1_shape__
        real(kind=kind(0.0)), dimension(vn1_shape__(1)) :: vn1
        integer, dimension(1) :: vn2_shape__
        real(kind=kind(0.0)), dimension(vn2_shape__(1)) :: vn2
        integer, dimension(1) :: auxv_shape__
        real(kind=kind(0.0)), dimension(auxv_shape__(1)) :: auxv
        integer, dimension(2) :: f_shape__
        real(kind=kind(0.0)), dimension(f_shape__(1), f_shape__(2)) :: f
        integer :: ldf
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqps
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqps(m, n, offset, nb, kb, a, lda, jpvt, tau, vn1, vn2, a
     &uxv, f, ldf)
        fw_iserr__ = 0
      end subroutine slaqps_c
      subroutine slaqr0_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &wr_shape__, wr, wi_shape__, wi, iloz, ihiz, z_shape__, z, ldz, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0)), dimension(wi_shape__(1)) :: wi
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqr0
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqr0(wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihi
     &z, z, ldz, work, lwork, info)
        fw_iserr__ = 0
      end subroutine slaqr0_c
      subroutine slaqr1_c(n, h_shape__, h, ldh, sr1, si1, sr2, si2, v_sh
     &ape__, v, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        real(kind=kind(0.0)) :: sr1
        real(kind=kind(0.0)) :: si1
        real(kind=kind(0.0)) :: sr2
        real(kind=kind(0.0)) :: si2
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1)) :: v
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqr1
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqr1(n, h, ldh, sr1, si1, sr2, si2, v)
        fw_iserr__ = 0
      end subroutine slaqr1_c
      subroutine slaqr2_c(wantt, wantz, n, ktop, kbot, nw, h_shape__, h,
     & ldh, iloz, ihiz, z_shape__, z, ldz, ns, nd, sr_shape__, sr, si_sh
     &ape__, si, v_shape__, v, ldv, nh, t_shape__, t, ldt, nv, wv_shape_
     &_, wv, ldwv, work_shape__, work, lwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nw
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: ns
        integer :: nd
        integer, dimension(1) :: sr_shape__
        real(kind=kind(0.0)), dimension(sr_shape__(1)) :: sr
        integer, dimension(1) :: si_shape__
        real(kind=kind(0.0)), dimension(si_shape__(1)) :: si
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer :: nh
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer :: nv
        integer, dimension(2) :: wv_shape__
        real(kind=kind(0.0)), dimension(wv_shape__(1), wv_shape__(2)) ::
     & wv
        integer :: ldwv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqr2
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqr2(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz,
     & z, ldz, ns, nd, sr, si, v, ldv, nh, t, ldt, nv, wv, ldwv, work, l
     &work)
        fw_iserr__ = 0
      end subroutine slaqr2_c
      subroutine slaqr3_c(wantt, wantz, n, ktop, kbot, nw, h_shape__, h,
     & ldh, iloz, ihiz, z_shape__, z, ldz, ns, nd, sr_shape__, sr, si_sh
     &ape__, si, v_shape__, v, ldv, nh, t_shape__, t, ldt, nv, wv_shape_
     &_, wv, ldwv, work_shape__, work, lwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nw
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: ns
        integer :: nd
        integer, dimension(1) :: sr_shape__
        real(kind=kind(0.0)), dimension(sr_shape__(1)) :: sr
        integer, dimension(1) :: si_shape__
        real(kind=kind(0.0)), dimension(si_shape__(1)) :: si
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer :: nh
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer :: nv
        integer, dimension(2) :: wv_shape__
        real(kind=kind(0.0)), dimension(wv_shape__(1), wv_shape__(2)) ::
     & wv
        integer :: ldwv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqr3
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqr3(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz,
     & z, ldz, ns, nd, sr, si, v, ldv, nh, t, ldt, nv, wv, ldwv, work, l
     &work)
        fw_iserr__ = 0
      end subroutine slaqr3_c
      subroutine slaqr4_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &wr_shape__, wr, wi_shape__, wi, iloz, ihiz, z_shape__, z, ldz, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0)), dimension(wi_shape__(1)) :: wi
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqr4
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqr4(wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, iloz, ihi
     &z, z, ldz, work, lwork, info)
        fw_iserr__ = 0
      end subroutine slaqr4_c
      subroutine slaqr5_c(wantt, wantz, kacc22, n, ktop, kbot, nshfts, s
     &r_shape__, sr, si_shape__, si, h_shape__, h, ldh, iloz, ihiz, z_sh
     &ape__, z, ldz, v_shape__, v, ldv, u_shape__, u, ldu, nv, wv_shape_
     &_, wv, ldwv, nh, wh_shape__, wh, ldwh, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: kacc22
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nshfts
        integer, dimension(1) :: sr_shape__
        real(kind=kind(0.0)), dimension(sr_shape__(1)) :: sr
        integer, dimension(1) :: si_shape__
        real(kind=kind(0.0)), dimension(si_shape__(1)) :: si
        integer, dimension(2) :: h_shape__
        real(kind=kind(0.0)), dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer :: nv
        integer, dimension(2) :: wv_shape__
        real(kind=kind(0.0)), dimension(wv_shape__(1), wv_shape__(2)) ::
     & wv
        integer :: ldwv
        integer :: nh
        integer, dimension(2) :: wh_shape__
        real(kind=kind(0.0)), dimension(wh_shape__(1), wh_shape__(2)) ::
     & wh
        integer :: ldwh
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqr5
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwh) .ne. (wh_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wh                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqr5(wantt, wantz, kacc22, n, ktop, kbot, nshfts, sr, si,
     & h, ldh, iloz, ihiz, z, ldz, v, ldv, u, ldu, nv, wv, ldwv, nh, wh,
     & ldwh)
        fw_iserr__ = 0
      end subroutine slaqr5_c
      subroutine slaqsb_c(uplo, n, kd, ab_shape__, ab, ldab, s_shape__, 
     &s, scond, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqsb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqsb(uplo, n, kd, ab, ldab, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine slaqsb_c
      subroutine slaqsp_c(uplo, n, ap_shape__, ap, s_shape__, s, scond, 
     &amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqsp
        fw_iserr__ = -1
        call slaqsp(uplo, n, ap, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine slaqsp_c
      subroutine slaqsy_c(uplo, n, a_shape__, a, lda, s_shape__, s, scon
     &d, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqsy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqsy(uplo, n, a, lda, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine slaqsy_c
      subroutine slaqtr_c(ltran, lreal, n, t_shape__, t, ldt, b_shape__,
     & b, w, scale, x_shape__, x, work_shape__, work, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: ltran
        integer(kind=kind(0)) :: lreal
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(1) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1)) :: b
        real(kind=kind(0.0)) :: w
        real(kind=kind(0.0)) :: scale
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaqtr
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaqtr(ltran, lreal, n, t, ldt, b, w, scale, x, work, info)
        fw_iserr__ = 0
      end subroutine slaqtr_c
      subroutine slar1v_c(n, b1, bn, lambda, d_shape__, d, l_shape__, l,
     & ld_shape__, ld, lld_shape__, lld, pivmin, gaptol, z_shape__, z, w
     &antnc, negcnt, ztz, mingma, r, isuppz_shape__, isuppz, nrminv, res
     &id, rqcorr, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: b1
        integer :: bn
        real(kind=kind(0.0)) :: lambda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: l_shape__
        real(kind=kind(0.0)), dimension(l_shape__(1)) :: l
        integer, dimension(1) :: ld_shape__
        real(kind=kind(0.0)), dimension(ld_shape__(1)) :: ld
        integer, dimension(1) :: lld_shape__
        real(kind=kind(0.0)), dimension(lld_shape__(1)) :: lld
        real(kind=kind(0.0)) :: pivmin
        real(kind=kind(0.0)) :: gaptol
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer(kind=kind(0)) :: wantnc
        integer :: negcnt
        real(kind=kind(0.0)) :: ztz
        real(kind=kind(0.0)) :: mingma
        integer :: r
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        real(kind=kind(0.0)) :: nrminv
        real(kind=kind(0.0)) :: resid
        real(kind=kind(0.0)) :: rqcorr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slar1v
        fw_iserr__ = -1
        call slar1v(n, b1, bn, lambda, d, l, ld, lld, pivmin, gaptol, z,
     & wantnc, negcnt, ztz, mingma, r, isuppz, nrminv, resid, rqcorr, wo
     &rk)
        fw_iserr__ = 0
      end subroutine slar1v_c
      subroutine slar2v_c(n, x_shape__, x, y_shape__, y, z_shape__, z, i
     &ncx, c_shape__, c, s_shape__, s, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer :: incx
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slar2v
        fw_iserr__ = -1
        call slar2v(n, x, y, z, incx, c, s, incc)
        fw_iserr__ = 0
      end subroutine slar2v_c
      subroutine slarf_c(side, m, n, v_shape__, v, incv, tau, c_shape__,
     & c, ldc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1)) :: v
        integer :: incv
        real(kind=kind(0.0)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarf
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slarf(side, m, n, v, incv, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine slarf_c
      subroutine slarfb_c(side, trans, direct, storev, m, n, k, v_shape_
     &_, v, ldv, t_shape__, t, ldt, c_shape__, c, ldc, work_shape__, wor
     &k, ldwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(2) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1), work_shape__(2)
     &) :: work
        integer :: ldwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarfb
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slarfb(side, trans, direct, storev, m, n, k, v, ldv, t, ldt
     &, c, ldc, work, ldwork)
        fw_iserr__ = 0
      end subroutine slarfb_c
      subroutine slarfg_c(n, alpha, x_shape__, x, incx, tau, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0)) :: alpha
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: tau
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarfg
        fw_iserr__ = -1
        call slarfg(n, alpha, x, incx, tau)
        fw_iserr__ = 0
      end subroutine slarfg_c
      subroutine slarfgp_c(n, alpha, x_shape__, x, incx, tau, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0)) :: alpha
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: tau
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarfgp
        fw_iserr__ = -1
        call slarfgp(n, alpha, x, incx, tau)
        fw_iserr__ = 0
      end subroutine slarfgp_c
      subroutine slarft_c(direct, storev, n, k, v_shape__, v, ldv, tau_s
     &hape__, tau, t_shape__, t, ldt, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarft
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slarft(direct, storev, n, k, v, ldv, tau, t, ldt)
        fw_iserr__ = 0
      end subroutine slarft_c
      subroutine slarfx_c(side, m, n, v_shape__, v, tau, c_shape__, c, l
     &dc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1)) :: v
        real(kind=kind(0.0)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarfx
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slarfx(side, m, n, v, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine slarfx_c
      subroutine slargv_c(n, x_shape__, x, incx, y_shape__, y, incy, c_s
     &hape__, c, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slargv
        fw_iserr__ = -1
        call slargv(n, x, incx, y, incy, c, incc)
        fw_iserr__ = 0
      end subroutine slargv_c
      subroutine slarnv_c(idist, iseed_shape__, iseed, n, x_shape__, x, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: idist
        integer, dimension(1) :: iseed_shape__
        integer, dimension(iseed_shape__(1)) :: iseed
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarnv
        fw_iserr__ = -1
        if ((4) .lt. 0 .or. (4) .gt. (iseed_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("iseed                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slarnv(idist, iseed, n, x)
        fw_iserr__ = 0
      end subroutine slarnv_c
      subroutine slarra_c(n, d_shape__, d, e_shape__, e, e2_shape__, e2,
     & spltol, tnrm, nsplit, isplit_shape__, isplit, info, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0)), dimension(e2_shape__(1)) :: e2
        real(kind=kind(0.0)) :: spltol
        real(kind=kind(0.0)) :: tnrm
        integer :: nsplit
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarra
        fw_iserr__ = -1
        call slarra(n, d, e, e2, spltol, tnrm, nsplit, isplit, info)
        fw_iserr__ = 0
      end subroutine slarra_c
      subroutine slarrb_c(n, d_shape__, d, lld_shape__, lld, ifirst, ila
     &st, rtol1, rtol2, offset, w_shape__, w, wgap_shape__, wgap, werr_s
     &hape__, werr, work_shape__, work, iwork_shape__, iwork, pivmin, sp
     &diam, twist, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: lld_shape__
        real(kind=kind(0.0)), dimension(lld_shape__(1)) :: lld
        integer :: ifirst
        integer :: ilast
        real(kind=kind(0.0)) :: rtol1
        real(kind=kind(0.0)) :: rtol2
        integer :: offset
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: wgap_shape__
        real(kind=kind(0.0)), dimension(wgap_shape__(1)) :: wgap
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0)), dimension(werr_shape__(1)) :: werr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        real(kind=kind(0.0)) :: pivmin
        real(kind=kind(0.0)) :: spdiam
        integer :: twist
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarrb
        fw_iserr__ = -1
        call slarrb(n, d, lld, ifirst, ilast, rtol1, rtol2, offset, w, w
     &gap, werr, work, iwork, pivmin, spdiam, twist, info)
        fw_iserr__ = 0
      end subroutine slarrb_c
      subroutine slarrc_c(jobt, n, vl, vu, d_shape__, d, e_shape__, e, p
     &ivmin, eigcnt, lcnt, rcnt, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobt
        integer :: n
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0)) :: pivmin
        integer :: eigcnt
        integer :: lcnt
        integer :: rcnt
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarrc
        fw_iserr__ = -1
        call slarrc(jobt, n, vl, vu, d, e, pivmin, eigcnt, lcnt, rcnt, i
     &nfo)
        fw_iserr__ = 0
      end subroutine slarrc_c
      subroutine slarrd_c(range, order, n, vl, vu, il, iu, gers_shape__,
     & gers, reltol, d_shape__, d, e_shape__, e, e2_shape__, e2, pivmin,
     & nsplit, isplit_shape__, isplit, m, w_shape__, w, werr_shape__, we
     &rr, wl, wu, iblock_shape__, iblock, indexw_shape__, indexw, work_s
     &hape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: order
        integer :: n
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        integer, dimension(1) :: gers_shape__
        real(kind=kind(0.0)), dimension(gers_shape__(1)) :: gers
        real(kind=kind(0.0)) :: reltol
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0)), dimension(e2_shape__(1)) :: e2
        real(kind=kind(0.0)) :: pivmin
        integer :: nsplit
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0)), dimension(werr_shape__(1)) :: werr
        real(kind=kind(0.0)) :: wl
        real(kind=kind(0.0)) :: wu
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: indexw_shape__
        integer, dimension(indexw_shape__(1)) :: indexw
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarrd
        fw_iserr__ = -1
        call slarrd(range, order, n, vl, vu, il, iu, gers, reltol, d, e,
     & e2, pivmin, nsplit, isplit, m, w, werr, wl, wu, iblock, indexw, w
     &ork, iwork, info)
        fw_iserr__ = 0
      end subroutine slarrd_c
      subroutine slarre_c(range, n, vl, vu, il, iu, d_shape__, d, e_shap
     &e__, e, e2_shape__, e2, rtol1, rtol2, spltol, nsplit, isplit_shape
     &__, isplit, m, w_shape__, w, werr_shape__, werr, wgap_shape__, wga
     &p, iblock_shape__, iblock, indexw_shape__, indexw, gers_shape__, g
     &ers, pivmin, work_shape__, work, iwork_shape__, iwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: range
        integer :: n
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0)), dimension(e2_shape__(1)) :: e2
        real(kind=kind(0.0)) :: rtol1
        real(kind=kind(0.0)) :: rtol2
        real(kind=kind(0.0)) :: spltol
        integer :: nsplit
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0)), dimension(werr_shape__(1)) :: werr
        integer, dimension(1) :: wgap_shape__
        real(kind=kind(0.0)), dimension(wgap_shape__(1)) :: wgap
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: indexw_shape__
        integer, dimension(indexw_shape__(1)) :: indexw
        integer, dimension(1) :: gers_shape__
        real(kind=kind(0.0)), dimension(gers_shape__(1)) :: gers
        real(kind=kind(0.0)) :: pivmin
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarre
        fw_iserr__ = -1
        call slarre(range, n, vl, vu, il, iu, d, e, e2, rtol1, rtol2, sp
     &ltol, nsplit, isplit, m, w, werr, wgap, iblock, indexw, gers, pivm
     &in, work, iwork, info)
        fw_iserr__ = 0
      end subroutine slarre_c
      subroutine slarrf_c(n, d_shape__, d, l_shape__, l, ld_shape__, ld,
     & clstrt, clend, w_shape__, w, wgap_shape__, wgap, werr_shape__, we
     &rr, spdiam, clgapl, clgapr, pivmin, sigma, dplus_shape__, dplus, l
     &plus_shape__, lplus, work_shape__, work, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: l_shape__
        real(kind=kind(0.0)), dimension(l_shape__(1)) :: l
        integer, dimension(1) :: ld_shape__
        real(kind=kind(0.0)), dimension(ld_shape__(1)) :: ld
        integer :: clstrt
        integer :: clend
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: wgap_shape__
        real(kind=kind(0.0)), dimension(wgap_shape__(1)) :: wgap
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0)), dimension(werr_shape__(1)) :: werr
        real(kind=kind(0.0)) :: spdiam
        real(kind=kind(0.0)) :: clgapl
        real(kind=kind(0.0)) :: clgapr
        real(kind=kind(0.0)) :: pivmin
        real(kind=kind(0.0)) :: sigma
        integer, dimension(1) :: dplus_shape__
        real(kind=kind(0.0)), dimension(dplus_shape__(1)) :: dplus
        integer, dimension(1) :: lplus_shape__
        real(kind=kind(0.0)), dimension(lplus_shape__(1)) :: lplus
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarrf
        fw_iserr__ = -1
        call slarrf(n, d, l, ld, clstrt, clend, w, wgap, werr, spdiam, c
     &lgapl, clgapr, pivmin, sigma, dplus, lplus, work, info)
        fw_iserr__ = 0
      end subroutine slarrf_c
      subroutine slarrj_c(n, d_shape__, d, e2_shape__, e2, ifirst, ilast
     &, rtol, offset, w_shape__, w, werr_shape__, werr, work_shape__, wo
     &rk, iwork_shape__, iwork, pivmin, spdiam, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0)), dimension(e2_shape__(1)) :: e2
        integer :: ifirst
        integer :: ilast
        real(kind=kind(0.0)) :: rtol
        integer :: offset
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0)), dimension(werr_shape__(1)) :: werr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        real(kind=kind(0.0)) :: pivmin
        real(kind=kind(0.0)) :: spdiam
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarrj
        fw_iserr__ = -1
        call slarrj(n, d, e2, ifirst, ilast, rtol, offset, w, werr, work
     &, iwork, pivmin, spdiam, info)
        fw_iserr__ = 0
      end subroutine slarrj_c
      subroutine slarrk_c(n, iw, gl, gu, d_shape__, d, e2_shape__, e2, p
     &ivmin, reltol, w, werr, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: iw
        real(kind=kind(0.0)) :: gl
        real(kind=kind(0.0)) :: gu
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e2_shape__
        real(kind=kind(0.0)), dimension(e2_shape__(1)) :: e2
        real(kind=kind(0.0)) :: pivmin
        real(kind=kind(0.0)) :: reltol
        real(kind=kind(0.0)) :: w
        real(kind=kind(0.0)) :: werr
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarrk
        fw_iserr__ = -1
        call slarrk(n, iw, gl, gu, d, e2, pivmin, reltol, w, werr, info)
        fw_iserr__ = 0
      end subroutine slarrk_c
      subroutine slarrr_c(n, d_shape__, d, e_shape__, e, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarrr
        fw_iserr__ = -1
        call slarrr(n, d, e, info)
        fw_iserr__ = 0
      end subroutine slarrr_c
      subroutine slarrv_c(n, vl, vu, d_shape__, d, l_shape__, l, pivmin,
     & isplit_shape__, isplit, m, dol, dou, minrgp, rtol1, rtol2, w_shap
     &e__, w, werr_shape__, werr, wgap_shape__, wgap, iblock_shape__, ib
     &lock, indexw_shape__, indexw, gers_shape__, gers, z_shape__, z, ld
     &z, isuppz_shape__, isuppz, work_shape__, work, iwork_shape__, iwor
     &k, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: l_shape__
        real(kind=kind(0.0)), dimension(l_shape__(1)) :: l
        real(kind=kind(0.0)) :: pivmin
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer :: m
        integer :: dol
        integer :: dou
        real(kind=kind(0.0)) :: minrgp
        real(kind=kind(0.0)) :: rtol1
        real(kind=kind(0.0)) :: rtol2
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0)), dimension(werr_shape__(1)) :: werr
        integer, dimension(1) :: wgap_shape__
        real(kind=kind(0.0)), dimension(wgap_shape__(1)) :: wgap
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: indexw_shape__
        integer, dimension(indexw_shape__(1)) :: indexw
        integer, dimension(1) :: gers_shape__
        real(kind=kind(0.0)), dimension(gers_shape__(1)) :: gers
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarrv
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slarrv(n, vl, vu, d, l, pivmin, isplit, m, dol, dou, minrgp
     &, rtol1, rtol2, w, werr, wgap, iblock, indexw, gers, z, ldz, isupp
     &z, work, iwork, info)
        fw_iserr__ = 0
      end subroutine slarrv_c
      subroutine slarscl2_c(m, n, d_shape__, d, x_shape__, x, ldx, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarscl2
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slarscl2(m, n, d, x, ldx)
        fw_iserr__ = 0
      end subroutine slarscl2_c
      subroutine slartg_c(f, g, cs, sn, r, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: f
        real(kind=kind(0.0)) :: g
        real(kind=kind(0.0)) :: cs
        real(kind=kind(0.0)) :: sn
        real(kind=kind(0.0)) :: r
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slartg
        fw_iserr__ = -1
        call slartg(f, g, cs, sn, r)
        fw_iserr__ = 0
      end subroutine slartg_c
      subroutine slartgp_c(f, g, cs, sn, r, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: f
        real(kind=kind(0.0)) :: g
        real(kind=kind(0.0)) :: cs
        real(kind=kind(0.0)) :: sn
        real(kind=kind(0.0)) :: r
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slartgp
        fw_iserr__ = -1
        call slartgp(f, g, cs, sn, r)
        fw_iserr__ = 0
      end subroutine slartgp_c
      subroutine slartgs_c(x, y, sigma, cs, sn, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: x
        real(kind=kind(0.0)) :: y
        real(kind=kind(0.0)) :: sigma
        real(kind=kind(0.0)) :: cs
        real(kind=kind(0.0)) :: sn
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slartgs
        fw_iserr__ = -1
        call slartgs(x, y, sigma, cs, sn)
        fw_iserr__ = 0
      end subroutine slartgs_c
      subroutine slartv_c(n, x_shape__, x, incx, y_shape__, y, incy, c_s
     &hape__, c, s_shape__, s, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slartv
        fw_iserr__ = -1
        call slartv(n, x, incx, y, incy, c, s, incc)
        fw_iserr__ = 0
      end subroutine slartv_c
      subroutine slaruv_c(iseed_shape__, iseed, n, x_shape__, x, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer, dimension(1) :: iseed_shape__
        integer, dimension(iseed_shape__(1)) :: iseed
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaruv
        fw_iserr__ = -1
        if ((4) .lt. 0 .or. (4) .gt. (iseed_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("iseed                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaruv(iseed, n, x)
        fw_iserr__ = 0
      end subroutine slaruv_c
      subroutine slarz_c(side, m, n, l, v_shape__, v, incv, tau, c_shape
     &__, c, ldc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer :: l
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1)) :: v
        integer :: incv
        real(kind=kind(0.0)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarz
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slarz(side, m, n, l, v, incv, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine slarz_c
      subroutine slarzb_c(side, trans, direct, storev, m, n, k, l, v_sha
     &pe__, v, ldv, t_shape__, t, ldt, c_shape__, c, ldc, work_shape__, 
     &work, ldwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(2) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1), work_shape__(2)
     &) :: work
        integer :: ldwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarzb
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slarzb(side, trans, direct, storev, m, n, k, l, v, ldv, t, 
     &ldt, c, ldc, work, ldwork)
        fw_iserr__ = 0
      end subroutine slarzb_c
      subroutine slarzt_c(direct, storev, n, k, v_shape__, v, ldv, tau_s
     &hape__, tau, t_shape__, t, ldt, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slarzt
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slarzt(direct, storev, n, k, v, ldv, tau, t, ldt)
        fw_iserr__ = 0
      end subroutine slarzt_c
      subroutine slas2_c(f, g, h, ssmin, ssmax, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: f
        real(kind=kind(0.0)) :: g
        real(kind=kind(0.0)) :: h
        real(kind=kind(0.0)) :: ssmin
        real(kind=kind(0.0)) :: ssmax
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slas2
        fw_iserr__ = -1
        call slas2(f, g, h, ssmin, ssmax)
        fw_iserr__ = 0
      end subroutine slas2_c
      subroutine slascl_c(type, kl, ku, cfrom, cto, m, n, a_shape__, a, 
     &lda, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: type
        integer :: kl
        integer :: ku
        real(kind=kind(0.0)) :: cfrom
        real(kind=kind(0.0)) :: cto
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slascl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slascl(type, kl, ku, cfrom, cto, m, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine slascl_c
      subroutine slascl2_c(m, n, d_shape__, d, x_shape__, x, ldx, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slascl2
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slascl2(m, n, d, x, ldx)
        fw_iserr__ = 0
      end subroutine slascl2_c
      subroutine slasd0_c(n, sqre, d_shape__, d, e_shape__, e, u_shape__
     &, u, ldu, vt_shape__, vt, ldvt, smlsiz, iwork_shape__, iwork, work
     &_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: sqre
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer :: ldvt
        integer :: smlsiz
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasd0
        fw_iserr__ = -1
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasd0(n, sqre, d, e, u, ldu, vt, ldvt, smlsiz, iwork, work
     &, info)
        fw_iserr__ = 0
      end subroutine slasd0_c
      subroutine slasd1_c(nl, nr, sqre, d_shape__, d, alpha, beta, u_sha
     &pe__, u, ldu, vt_shape__, vt, ldvt, idxq_shape__, idxq, iwork_shap
     &e__, iwork, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: nl
        integer :: nr
        integer :: sqre
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        real(kind=kind(0.0)) :: alpha
        real(kind=kind(0.0)) :: beta
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer :: ldvt
        integer, dimension(1) :: idxq_shape__
        integer, dimension(idxq_shape__(1)) :: idxq
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasd1
        fw_iserr__ = -1
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasd1(nl, nr, sqre, d, alpha, beta, u, ldu, vt, ldvt, idxq
     &, iwork, work, info)
        fw_iserr__ = 0
      end subroutine slasd1_c
      subroutine slasd2_c(nl, nr, sqre, k, d_shape__, d, z_shape__, z, a
     &lpha, beta, u_shape__, u, ldu, vt_shape__, vt, ldvt, dsigma_shape_
     &_, dsigma, u2_shape__, u2, ldu2, vt2_shape__, vt2, ldvt2, idxp_sha
     &pe__, idxp, idx_shape__, idx, idxc_shape__, idxc, idxq_shape__, id
     &xq, coltyp_shape__, coltyp, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: nl
        integer :: nr
        integer :: sqre
        integer :: k
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        real(kind=kind(0.0)) :: alpha
        real(kind=kind(0.0)) :: beta
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer :: ldvt
        integer, dimension(1) :: dsigma_shape__
        real(kind=kind(0.0)), dimension(dsigma_shape__(1)) :: dsigma
        integer, dimension(2) :: u2_shape__
        real(kind=kind(0.0)), dimension(u2_shape__(1), u2_shape__(2)) ::
     & u2
        integer :: ldu2
        integer, dimension(2) :: vt2_shape__
        real(kind=kind(0.0)), dimension(vt2_shape__(1), vt2_shape__(2)) 
     &:: vt2
        integer :: ldvt2
        integer, dimension(1) :: idxp_shape__
        integer, dimension(idxp_shape__(1)) :: idxp
        integer, dimension(1) :: idx_shape__
        integer, dimension(idx_shape__(1)) :: idx
        integer, dimension(1) :: idxc_shape__
        integer, dimension(idxc_shape__(1)) :: idxc
        integer, dimension(1) :: idxq_shape__
        integer, dimension(idxq_shape__(1)) :: idxq
        integer, dimension(1) :: coltyp_shape__
        integer, dimension(coltyp_shape__(1)) :: coltyp
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasd2
        fw_iserr__ = -1
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt2) .ne. (vt2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt2                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasd2(nl, nr, sqre, k, d, z, alpha, beta, u, ldu, vt, ldvt
     &, dsigma, u2, ldu2, vt2, ldvt2, idxp, idx, idxc, idxq, coltyp, inf
     &o)
        fw_iserr__ = 0
      end subroutine slasd2_c
      subroutine slasd3_c(nl, nr, sqre, k, d_shape__, d, q_shape__, q, l
     &dq, dsigma_shape__, dsigma, u_shape__, u, ldu, u2_shape__, u2, ldu
     &2, vt_shape__, vt, ldvt, vt2_shape__, vt2, ldvt2, idxc_shape__, id
     &xc, ctot_shape__, ctot, z_shape__, z, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: nl
        integer :: nr
        integer :: sqre
        integer :: k
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: dsigma_shape__
        real(kind=kind(0.0)), dimension(dsigma_shape__(1)) :: dsigma
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: u2_shape__
        real(kind=kind(0.0)), dimension(u2_shape__(1), u2_shape__(2)) ::
     & u2
        integer :: ldu2
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer :: ldvt
        integer, dimension(2) :: vt2_shape__
        real(kind=kind(0.0)), dimension(vt2_shape__(1), vt2_shape__(2)) 
     &:: vt2
        integer :: ldvt2
        integer, dimension(1) :: idxc_shape__
        integer, dimension(idxc_shape__(1)) :: idxc
        integer, dimension(1) :: ctot_shape__
        integer, dimension(ctot_shape__(1)) :: ctot
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasd3
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt2) .ne. (vt2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt2                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasd3(nl, nr, sqre, k, d, q, ldq, dsigma, u, ldu, u2, ldu2
     &, vt, ldvt, vt2, ldvt2, idxc, ctot, z, info)
        fw_iserr__ = 0
      end subroutine slasd3_c
      subroutine slasd4_c(n, i, d_shape__, d, z_shape__, z, delta_shape_
     &_, delta, rho, sigma, work_shape__, work, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: i
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: delta_shape__
        real(kind=kind(0.0)), dimension(delta_shape__(1)) :: delta
        real(kind=kind(0.0)) :: rho
        real(kind=kind(0.0)) :: sigma
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasd4
        fw_iserr__ = -1
        call slasd4(n, i, d, z, delta, rho, sigma, work, info)
        fw_iserr__ = 0
      end subroutine slasd4_c
      subroutine slasd5_c(i, d_shape__, d, z_shape__, z, delta_shape__, 
     &delta, rho, dsigma, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: delta_shape__
        real(kind=kind(0.0)), dimension(delta_shape__(1)) :: delta
        real(kind=kind(0.0)) :: rho
        real(kind=kind(0.0)) :: dsigma
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasd5
        fw_iserr__ = -1
        if ((2) .lt. 0 .or. (2) .gt. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (delta_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("delta                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasd5(i, d, z, delta, rho, dsigma, work)
        fw_iserr__ = 0
      end subroutine slasd5_c
      subroutine slasd6_c(icompq, nl, nr, sqre, d_shape__, d, vf_shape__
     &, vf, vl_shape__, vl, alpha, beta, idxq_shape__, idxq, perm_shape_
     &_, perm, givptr, givcol_shape__, givcol, ldgcol, givnum_shape__, g
     &ivnum, ldgnum, poles_shape__, poles, difl_shape__, difl, difr_shap
     &e__, difr, z_shape__, z, k, c, s, work_shape__, work, iwork_shape_
     &_, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: nl
        integer :: nr
        integer :: sqre
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: vf_shape__
        real(kind=kind(0.0)), dimension(vf_shape__(1)) :: vf
        integer, dimension(1) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1)) :: vl
        real(kind=kind(0.0)) :: alpha
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: idxq_shape__
        integer, dimension(idxq_shape__(1)) :: idxq
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer :: ldgnum
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0)), dimension(poles_shape__(1), poles_shape__(
     &2)) :: poles
        integer, dimension(1) :: difl_shape__
        real(kind=kind(0.0)), dimension(difl_shape__(1)) :: difl
        integer, dimension(1) :: difr_shape__
        real(kind=kind(0.0)), dimension(difr_shape__(1)) :: difr
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer :: k
        real(kind=kind(0.0)) :: c
        real(kind=kind(0.0)) :: s
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasd6
        fw_iserr__ = -1
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasd6(icompq, nl, nr, sqre, d, vf, vl, alpha, beta, idxq, 
     &perm, givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z
     &, k, c, s, work, iwork, info)
        fw_iserr__ = 0
      end subroutine slasd6_c
      subroutine slasd7_c(icompq, nl, nr, sqre, k, d_shape__, d, z_shape
     &__, z, zw_shape__, zw, vf_shape__, vf, vfw_shape__, vfw, vl_shape_
     &_, vl, vlw_shape__, vlw, alpha, beta, dsigma_shape__, dsigma, idx_
     &shape__, idx, idxp_shape__, idxp, idxq_shape__, idxq, perm_shape__
     &, perm, givptr, givcol_shape__, givcol, ldgcol, givnum_shape__, gi
     &vnum, ldgnum, c, s, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: nl
        integer :: nr
        integer :: sqre
        integer :: k
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: zw_shape__
        real(kind=kind(0.0)), dimension(zw_shape__(1)) :: zw
        integer, dimension(1) :: vf_shape__
        real(kind=kind(0.0)), dimension(vf_shape__(1)) :: vf
        integer, dimension(1) :: vfw_shape__
        real(kind=kind(0.0)), dimension(vfw_shape__(1)) :: vfw
        integer, dimension(1) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1)) :: vl
        integer, dimension(1) :: vlw_shape__
        real(kind=kind(0.0)), dimension(vlw_shape__(1)) :: vlw
        real(kind=kind(0.0)) :: alpha
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: dsigma_shape__
        real(kind=kind(0.0)), dimension(dsigma_shape__(1)) :: dsigma
        integer, dimension(1) :: idx_shape__
        integer, dimension(idx_shape__(1)) :: idx
        integer, dimension(1) :: idxp_shape__
        integer, dimension(idxp_shape__(1)) :: idxp
        integer, dimension(1) :: idxq_shape__
        integer, dimension(idxq_shape__(1)) :: idxq
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer :: ldgnum
        real(kind=kind(0.0)) :: c
        real(kind=kind(0.0)) :: s
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasd7
        fw_iserr__ = -1
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasd7(icompq, nl, nr, sqre, k, d, z, zw, vf, vfw, vl, vlw,
     & alpha, beta, dsigma, idx, idxp, idxq, perm, givptr, givcol, ldgco
     &l, givnum, ldgnum, c, s, info)
        fw_iserr__ = 0
      end subroutine slasd7_c
      subroutine slasd8_c(icompq, k, d_shape__, d, z_shape__, z, vf_shap
     &e__, vf, vl_shape__, vl, difl_shape__, difl, difr_shape__, difr, l
     &ddifr, dsigma_shape__, dsigma, work_shape__, work, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: k
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: vf_shape__
        real(kind=kind(0.0)), dimension(vf_shape__(1)) :: vf
        integer, dimension(1) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1)) :: vl
        integer, dimension(1) :: difl_shape__
        real(kind=kind(0.0)), dimension(difl_shape__(1)) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0)), dimension(difr_shape__(1), difr_shape__(2)
     &) :: difr
        integer :: lddifr
        integer, dimension(1) :: dsigma_shape__
        real(kind=kind(0.0)), dimension(dsigma_shape__(1)) :: dsigma
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasd8
        fw_iserr__ = -1
        if ((lddifr) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasd8(icompq, k, d, z, vf, vl, difl, difr, lddifr, dsigma,
     & work, info)
        fw_iserr__ = 0
      end subroutine slasd8_c
      subroutine slasda_c(icompq, smlsiz, n, sqre, d_shape__, d, e_shape
     &__, e, u_shape__, u, ldu, vt_shape__, vt, k_shape__, k, difl_shape
     &__, difl, difr_shape__, difr, z_shape__, z, poles_shape__, poles, 
     &givptr_shape__, givptr, givcol_shape__, givcol, ldgcol, perm_shape
     &__, perm, givnum_shape__, givnum, c_shape__, c, s_shape__, s, work
     &_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: smlsiz
        integer :: n
        integer :: sqre
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer, dimension(2) :: difl_shape__
        real(kind=kind(0.0)), dimension(difl_shape__(1), difl_shape__(2)
     &) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0)), dimension(difr_shape__(1), difr_shape__(2)
     &) :: difr
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0)), dimension(poles_shape__(1), poles_shape__(
     &2)) :: poles
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: perm_shape__
        integer, dimension(perm_shape__(1), perm_shape__(2)) :: perm
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0)), dimension(givnum_shape__(1), givnum_shape_
     &_(2)) :: givnum
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasda
        fw_iserr__ = -1
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difl                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (perm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("perm                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasda(icompq, smlsiz, n, sqre, d, e, u, ldu, vt, k, difl, 
     &difr, z, poles, givptr, givcol, ldgcol, perm, givnum, c, s, work, 
     &iwork, info)
        fw_iserr__ = 0
      end subroutine slasda_c
      subroutine slasdq_c(uplo, sqre, n, ncvt, nru, ncc, d_shape__, d, e
     &_shape__, e, vt_shape__, vt, ldvt, u_shape__, u, ldu, c_shape__, c
     &, ldc, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: sqre
        integer :: n
        integer :: ncvt
        integer :: nru
        integer :: ncc
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0)), dimension(vt_shape__(1), vt_shape__(2)) ::
     & vt
        integer :: ldvt
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasdq
        fw_iserr__ = -1
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasdq(uplo, sqre, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ld
     &u, c, ldc, work, info)
        fw_iserr__ = 0
      end subroutine slasdq_c
      subroutine slasdt_c(n, lvl, nd, inode_shape__, inode, ndiml_shape_
     &_, ndiml, ndimr_shape__, ndimr, msub, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: lvl
        integer :: nd
        integer, dimension(1) :: inode_shape__
        integer, dimension(inode_shape__(1)) :: inode
        integer, dimension(1) :: ndiml_shape__
        integer, dimension(ndiml_shape__(1)) :: ndiml
        integer, dimension(1) :: ndimr_shape__
        integer, dimension(ndimr_shape__(1)) :: ndimr
        integer :: msub
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasdt
        fw_iserr__ = -1
        call slasdt(n, lvl, nd, inode, ndiml, ndimr, msub)
        fw_iserr__ = 0
      end subroutine slasdt_c
      subroutine slaset_c(uplo, m, n, alpha, beta, a_shape__, a, lda, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: m
        integer :: n
        real(kind=kind(0.0)) :: alpha
        real(kind=kind(0.0)) :: beta
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaset
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaset(uplo, m, n, alpha, beta, a, lda)
        fw_iserr__ = 0
      end subroutine slaset_c
      subroutine slasq1_c(n, d_shape__, d, e_shape__, e, work_shape__, w
     &ork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasq1
        fw_iserr__ = -1
        call slasq1(n, d, e, work, info)
        fw_iserr__ = 0
      end subroutine slasq1_c
      subroutine slasq2_c(n, z_shape__, z, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasq2
        fw_iserr__ = -1
        call slasq2(n, z, info)
        fw_iserr__ = 0
      end subroutine slasq2_c
      subroutine slasq3_c(i0, n0, z_shape__, z, pp, dmin, sigma, desig, 
     &qmax, nfail, iter, ndiv, ieee, ttype, dmin1, dmin2, dn, dn1, dn2, 
     &g, tau, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i0
        integer :: n0
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer :: pp
        real(kind=kind(0.0)) :: dmin
        real(kind=kind(0.0)) :: sigma
        real(kind=kind(0.0)) :: desig
        real(kind=kind(0.0)) :: qmax
        integer :: nfail
        integer :: iter
        integer :: ndiv
        integer(kind=kind(0)) :: ieee
        integer :: ttype
        real(kind=kind(0.0)) :: dmin1
        real(kind=kind(0.0)) :: dmin2
        real(kind=kind(0.0)) :: dn
        real(kind=kind(0.0)) :: dn1
        real(kind=kind(0.0)) :: dn2
        real(kind=kind(0.0)) :: g
        real(kind=kind(0.0)) :: tau
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasq3
        fw_iserr__ = -1
        call slasq3(i0, n0, z, pp, dmin, sigma, desig, qmax, nfail, iter
     &, ndiv, ieee, ttype, dmin1, dmin2, dn, dn1, dn2, g, tau)
        fw_iserr__ = 0
      end subroutine slasq3_c
      subroutine slasq4_c(i0, n0, z_shape__, z, pp, n0in, dmin, dmin1, d
     &min2, dn, dn1, dn2, tau, ttype, g, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i0
        integer :: n0
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer :: pp
        integer :: n0in
        real(kind=kind(0.0)) :: dmin
        real(kind=kind(0.0)) :: dmin1
        real(kind=kind(0.0)) :: dmin2
        real(kind=kind(0.0)) :: dn
        real(kind=kind(0.0)) :: dn1
        real(kind=kind(0.0)) :: dn2
        real(kind=kind(0.0)) :: tau
        integer :: ttype
        real(kind=kind(0.0)) :: g
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasq4
        fw_iserr__ = -1
        call slasq4(i0, n0, z, pp, n0in, dmin, dmin1, dmin2, dn, dn1, dn
     &2, tau, ttype, g)
        fw_iserr__ = 0
      end subroutine slasq4_c
      subroutine slasq5_c(i0, n0, z_shape__, z, pp, tau, dmin, dmin1, dm
     &in2, dn, dnm1, dnm2, ieee, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i0
        integer :: n0
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer :: pp
        real(kind=kind(0.0)) :: tau
        real(kind=kind(0.0)) :: dmin
        real(kind=kind(0.0)) :: dmin1
        real(kind=kind(0.0)) :: dmin2
        real(kind=kind(0.0)) :: dn
        real(kind=kind(0.0)) :: dnm1
        real(kind=kind(0.0)) :: dnm2
        integer(kind=kind(0)) :: ieee
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasq5
        fw_iserr__ = -1
        call slasq5(i0, n0, z, pp, tau, dmin, dmin1, dmin2, dn, dnm1, dn
     &m2, ieee)
        fw_iserr__ = 0
      end subroutine slasq5_c
      subroutine slasq6_c(i0, n0, z_shape__, z, pp, dmin, dmin1, dmin2, 
     &dn, dnm1, dnm2, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: i0
        integer :: n0
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1)) :: z
        integer :: pp
        real(kind=kind(0.0)) :: dmin
        real(kind=kind(0.0)) :: dmin1
        real(kind=kind(0.0)) :: dmin2
        real(kind=kind(0.0)) :: dn
        real(kind=kind(0.0)) :: dnm1
        real(kind=kind(0.0)) :: dnm2
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasq6
        fw_iserr__ = -1
        call slasq6(i0, n0, z, pp, dmin, dmin1, dmin2, dn, dnm1, dnm2)
        fw_iserr__ = 0
      end subroutine slasq6_c
      subroutine slasr_c(side, pivot, direct, m, n, c_shape__, c, s_shap
     &e__, s, a_shape__, a, lda, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: pivot
        character(len=1, kind=kind('a')) :: direct
        integer :: m
        integer :: n
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasr(side, pivot, direct, m, n, c, s, a, lda)
        fw_iserr__ = 0
      end subroutine slasr_c
      subroutine slasrt_c(id, n, d_shape__, d, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: id
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasrt
        fw_iserr__ = -1
        call slasrt(id, n, d, info)
        fw_iserr__ = 0
      end subroutine slasrt_c
      subroutine slassq_c(n, x_shape__, x, incx, scale, sumsq, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0)) :: scale
        real(kind=kind(0.0)) :: sumsq
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slassq
        fw_iserr__ = -1
        call slassq(n, x, incx, scale, sumsq)
        fw_iserr__ = 0
      end subroutine slassq_c
      subroutine slasv2_c(f, g, h, ssmin, ssmax, snr, csr, snl, csl, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0)) :: f
        real(kind=kind(0.0)) :: g
        real(kind=kind(0.0)) :: h
        real(kind=kind(0.0)) :: ssmin
        real(kind=kind(0.0)) :: ssmax
        real(kind=kind(0.0)) :: snr
        real(kind=kind(0.0)) :: csr
        real(kind=kind(0.0)) :: snl
        real(kind=kind(0.0)) :: csl
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasv2
        fw_iserr__ = -1
        call slasv2(f, g, h, ssmin, ssmax, snr, csr, snl, csl)
        fw_iserr__ = 0
      end subroutine slasv2_c
      subroutine slaswp_c(n, a_shape__, a, lda, k1, k2, ipiv_shape__, ip
     &iv, incx, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: k1
        integer :: k2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slaswp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slaswp(n, a, lda, k1, k2, ipiv, incx)
        fw_iserr__ = 0
      end subroutine slaswp_c
      subroutine slasy2_c(ltranl, ltranr, isgn, n1, n2, tl_shape__, tl, 
     &ldtl, tr_shape__, tr, ldtr, b_shape__, b, ldb, scale, x_shape__, x
     &, ldx, xnorm, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: ltranl
        integer(kind=kind(0)) :: ltranr
        integer :: isgn
        integer :: n1
        integer :: n2
        integer, dimension(2) :: tl_shape__
        real(kind=kind(0.0)), dimension(tl_shape__(1), tl_shape__(2)) ::
     & tl
        integer :: ldtl
        integer, dimension(2) :: tr_shape__
        real(kind=kind(0.0)), dimension(tr_shape__(1), tr_shape__(2)) ::
     & tr
        integer :: ldtr
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: scale
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: xnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasy2
        fw_iserr__ = -1
        if ((ldtl) .ne. (tl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldtr) .ne. (tr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasy2(ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr, ldtr, b,
     & ldb, scale, x, ldx, xnorm, info)
        fw_iserr__ = 0
      end subroutine slasy2_c
      subroutine slasyf_c(uplo, n, nb, kb, a_shape__, a, lda, ipiv_shape
     &__, ipiv, w_shape__, w, ldw, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nb
        integer :: kb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1), w_shape__(2)) :: w
        integer :: ldw
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slasyf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldw) .ne. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slasyf(uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)
        fw_iserr__ = 0
      end subroutine slasyf_c
      subroutine slatbs_c(uplo, trans, diag, normin, n, kd, ab_shape__, 
     &ab, ldab, x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slatbs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slatbs(uplo, trans, diag, normin, n, kd, ab, ldab, x, scale
     &, cnorm, info)
        fw_iserr__ = 0
      end subroutine slatbs_c
      subroutine slatdf_c(ijob, n, z_shape__, z, ldz, rhs_shape__, rhs, 
     &rdsum, rdscal, ipiv_shape__, ipiv, jpiv_shape__, jpiv, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: ijob
        integer :: n
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: rhs_shape__
        real(kind=kind(0.0)), dimension(rhs_shape__(1)) :: rhs
        real(kind=kind(0.0)) :: rdsum
        real(kind=kind(0.0)) :: rdscal
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slatdf
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slatdf(ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv, jpiv)
        fw_iserr__ = 0
      end subroutine slatdf_c
      subroutine slatps_c(uplo, trans, diag, normin, n, ap_shape__, ap, 
     &x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slatps
        fw_iserr__ = -1
        call slatps(uplo, trans, diag, normin, n, ap, x, scale, cnorm, i
     &nfo)
        fw_iserr__ = 0
      end subroutine slatps_c
      subroutine slatrd_c(uplo, n, nb, a_shape__, a, lda, e_shape__, e, 
     &tau_shape__, tau, w_shape__, w, ldw, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nb
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1), w_shape__(2)) :: w
        integer :: ldw
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slatrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldw) .ne. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slatrd(uplo, n, nb, a, lda, e, tau, w, ldw)
        fw_iserr__ = 0
      end subroutine slatrd_c
      subroutine slatrs_c(uplo, trans, diag, normin, n, a_shape__, a, ld
     &a, x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iserr__, fw
     &_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1)) :: x
        real(kind=kind(0.0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slatrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slatrs(uplo, trans, diag, normin, n, a, lda, x, scale, cnor
     &m, info)
        fw_iserr__ = 0
      end subroutine slatrs_c
      subroutine slatrz_c(m, n, l, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: l
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slatrz
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slatrz(m, n, l, a, lda, tau, work)
        fw_iserr__ = 0
      end subroutine slatrz_c
      subroutine slatzm_c(side, m, n, v_shape__, v, incv, tau, c1_shape_
     &_, c1, c2_shape__, c2, ldc, work_shape__, work, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1)) :: v
        integer :: incv
        real(kind=kind(0.0)) :: tau
        integer, dimension(2) :: c1_shape__
        real(kind=kind(0.0)), dimension(c1_shape__(1), c1_shape__(2)) ::
     & c1
        integer, dimension(2) :: c2_shape__
        real(kind=kind(0.0)), dimension(c2_shape__(1), c2_shape__(2)) ::
     & c2
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slatzm
        fw_iserr__ = -1
        if ((ldc) .ne. (c1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slatzm(side, m, n, v, incv, tau, c1, c2, ldc, work)
        fw_iserr__ = 0
      end subroutine slatzm_c
      subroutine slauu2_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slauu2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slauu2(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine slauu2_c
      subroutine slauum_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external slauum
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call slauum(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine slauum_c
      subroutine sopgtr_c(uplo, n, ap_shape__, ap, tau_shape__, tau, q_s
     &hape__, q, ldq, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sopgtr
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sopgtr(uplo, n, ap, tau, q, ldq, work, info)
        fw_iserr__ = 0
      end subroutine sopgtr_c
      subroutine sopmtr_c(side, uplo, trans, m, n, ap_shape__, ap, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sopmtr
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sopmtr(side, uplo, trans, m, n, ap, tau, c, ldc, work, info
     &)
        fw_iserr__ = 0
      end subroutine sopmtr_c
      subroutine sorbdb_c(trans, signs, m, p, q, x11_shape__, x11, ldx11
     &, x12_shape__, x12, ldx12, x21_shape__, x21, ldx21, x22_shape__, x
     &22, ldx22, theta_shape__, theta, phi_shape__, phi, taup1_shape__, 
     &taup1, taup2_shape__, taup2, tauq1_shape__, tauq1, tauq2_shape__, 
     &tauq2, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: signs
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(2) :: x11_shape__
        real(kind=kind(0.0)), dimension(x11_shape__(1), x11_shape__(2)) 
     &:: x11
        integer :: ldx11
        integer, dimension(2) :: x12_shape__
        real(kind=kind(0.0)), dimension(x12_shape__(1), x12_shape__(2)) 
     &:: x12
        integer :: ldx12
        integer, dimension(2) :: x21_shape__
        real(kind=kind(0.0)), dimension(x21_shape__(1), x21_shape__(2)) 
     &:: x21
        integer :: ldx21
        integer, dimension(2) :: x22_shape__
        real(kind=kind(0.0)), dimension(x22_shape__(1), x22_shape__(2)) 
     &:: x22
        integer :: ldx22
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(1) :: phi_shape__
        real(kind=kind(0.0)), dimension(phi_shape__(1)) :: phi
        integer, dimension(1) :: taup1_shape__
        real(kind=kind(0.0)), dimension(taup1_shape__(1)) :: taup1
        integer, dimension(1) :: taup2_shape__
        real(kind=kind(0.0)), dimension(taup2_shape__(1)) :: taup2
        integer, dimension(1) :: tauq1_shape__
        real(kind=kind(0.0)), dimension(tauq1_shape__(1)) :: tauq1
        integer, dimension(1) :: tauq2_shape__
        real(kind=kind(0.0)), dimension(tauq2_shape__(1)) :: tauq2
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorbdb
        fw_iserr__ = -1
        if ((ldx11) .ne. (x11_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x11                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx12) .ne. (x12_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x12                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx21) .ne. (x21_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x21                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx22) .ne. (x22_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x22                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorbdb(trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, 
     &ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, l
     &work, info)
        fw_iserr__ = 0
      end subroutine sorbdb_c
      subroutine sorcsd_c(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m,
     & p, q, x11_shape__, x11, ldx11, x12_shape__, x12, ldx12, x21_shape
     &__, x21, ldx21, x22_shape__, x22, ldx22, theta_shape__, theta, u1_
     &shape__, u1, ldu1, u2_shape__, u2, ldu2, v1t_shape__, v1t, ldv1t, 
     &v2t_shape__, v2t, ldv2t, work_shape__, work, lwork, iwork_shape__,
     & iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu1
        character(len=1, kind=kind('a')) :: jobu2
        character(len=1, kind=kind('a')) :: jobv1t
        character(len=1, kind=kind('a')) :: jobv2t
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: signs
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(2) :: x11_shape__
        real(kind=kind(0.0)), dimension(x11_shape__(1), x11_shape__(2)) 
     &:: x11
        integer :: ldx11
        integer, dimension(2) :: x12_shape__
        real(kind=kind(0.0)), dimension(x12_shape__(1), x12_shape__(2)) 
     &:: x12
        integer :: ldx12
        integer, dimension(2) :: x21_shape__
        real(kind=kind(0.0)), dimension(x21_shape__(1), x21_shape__(2)) 
     &:: x21
        integer :: ldx21
        integer, dimension(2) :: x22_shape__
        real(kind=kind(0.0)), dimension(x22_shape__(1), x22_shape__(2)) 
     &:: x22
        integer :: ldx22
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(2) :: u1_shape__
        real(kind=kind(0.0)), dimension(u1_shape__(1), u1_shape__(2)) ::
     & u1
        integer :: ldu1
        integer, dimension(2) :: u2_shape__
        real(kind=kind(0.0)), dimension(u2_shape__(1), u2_shape__(2)) ::
     & u2
        integer :: ldu2
        integer, dimension(2) :: v1t_shape__
        real(kind=kind(0.0)), dimension(v1t_shape__(1), v1t_shape__(2)) 
     &:: v1t
        integer :: ldv1t
        integer, dimension(2) :: v2t_shape__
        real(kind=kind(0.0)), dimension(v2t_shape__(1), v2t_shape__(2)) 
     &:: v2t
        integer :: ldv2t
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorcsd
        fw_iserr__ = -1
        if ((ldx11) .ne. (x11_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x11                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx12) .ne. (x12_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x12                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx21) .ne. (x21_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x21                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx22) .ne. (x22_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x22                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu1) .ne. (u1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv1t) .ne. (v1t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v1t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv2t) .ne. (v2t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v2t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorcsd(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q,
     & x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, 
     &u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine sorcsd_c
      subroutine sorg2l_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorg2l
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorg2l(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine sorg2l_c
      subroutine sorg2r_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorg2r
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorg2r(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine sorg2r_c
      subroutine sorgbr_c(vect, m, n, k, a_shape__, a, lda, tau_shape__,
     & tau, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorgbr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorgbr(vect, m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sorgbr_c
      subroutine sorghr_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorghr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorghr(n, ilo, ihi, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sorghr_c
      subroutine sorgl2_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorgl2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorgl2(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine sorgl2_c
      subroutine sorglq_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorglq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorglq(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sorglq_c
      subroutine sorgql_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorgql
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorgql(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sorgql_c
      subroutine sorgqr_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorgqr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorgqr(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sorgqr_c
      subroutine sorgr2_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorgr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorgr2(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine sorgr2_c
      subroutine sorgrq_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorgrq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorgrq(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sorgrq_c
      subroutine sorgtr_c(uplo, n, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorgtr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorgtr(uplo, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine sorgtr_c
      subroutine sorm2l_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorm2l
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorm2l(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine sorm2l_c
      subroutine sorm2r_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorm2r
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorm2r(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine sorm2r_c
      subroutine sormbr_c(vect, side, trans, m, n, k, a_shape__, a, lda,
     & tau_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sormbr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sormbr(vect, side, trans, m, n, k, a, lda, tau, c, ldc, wor
     &k, lwork, info)
        fw_iserr__ = 0
      end subroutine sormbr_c
      subroutine sormhr_c(side, trans, m, n, ilo, ihi, a_shape__, a, lda
     &, tau_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, 
     &info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sormhr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sormhr(side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, wo
     &rk, lwork, info)
        fw_iserr__ = 0
      end subroutine sormhr_c
      subroutine sorml2_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sorml2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sorml2(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine sorml2_c
      subroutine sormlq_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sormlq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sormlq(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine sormlq_c
      subroutine sormql_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sormql
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sormql(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine sormql_c
      subroutine sormqr_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sormqr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sormqr(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine sormqr_c
      subroutine sormr2_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sormr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sormr2(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine sormr2_c
      subroutine sormr3_c(side, trans, m, n, k, l, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sormr3
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sormr3(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, 
     &info)
        fw_iserr__ = 0
      end subroutine sormr3_c
      subroutine sormrq_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sormrq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sormrq(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine sormrq_c
      subroutine sormrz_c(side, trans, m, n, k, l, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sormrz
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sormrz(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, 
     &lwork, info)
        fw_iserr__ = 0
      end subroutine sormrz_c
      subroutine sormtr_c(side, uplo, trans, m, n, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sormtr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sormtr(side, uplo, trans, m, n, a, lda, tau, c, ldc, work, 
     &lwork, info)
        fw_iserr__ = 0
      end subroutine sormtr_c
      subroutine spbcon_c(uplo, n, kd, ab_shape__, ab, ldab, anorm, rcon
     &d, work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spbcon(uplo, n, kd, ab, ldab, anorm, rcond, work, iwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine spbcon_c
      subroutine spbequ_c(uplo, n, kd, ab_shape__, ab, ldab, s_shape__, 
     &s, scond, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spbequ
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spbequ(uplo, n, kd, ab, ldab, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine spbequ_c
      subroutine spbrfs_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, afb_s
     &hape__, afb, ldafb, b_shape__, b, ldb, x_shape__, x, ldx, ferr_sha
     &pe__, ferr, berr_shape__, berr, work_shape__, work, iwork_shape__,
     & iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0)), dimension(afb_shape__(1), afb_shape__(2)) 
     &:: afb
        integer :: ldafb
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spbrfs(uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, 
     &ldx, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine spbrfs_c
      subroutine spbstf_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spbstf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spbstf(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine spbstf_c
      subroutine spbsv_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, b_shap
     &e__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spbsv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spbsv(uplo, n, kd, nrhs, ab, ldab, b, ldb, info)
        fw_iserr__ = 0
      end subroutine spbsv_c
      subroutine spbsvx_c(fact, uplo, n, kd, nrhs, ab_shape__, ab, ldab,
     & afb_shape__, afb, ldafb, equed, s_shape__, s, b_shape__, b, ldb, 
     &x_shape__, x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, 
     &work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        real(kind=kind(0.0)), dimension(afb_shape__(1), afb_shape__(2)) 
     &:: afb
        integer :: ldafb
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spbsvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spbsvx(fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed
     &, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine spbsvx_c
      subroutine spbtf2_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spbtf2
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spbtf2(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine spbtf2_c
      subroutine spbtrf_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spbtrf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spbtrf(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine spbtrf_c
      subroutine spbtrs_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, b_sha
     &pe__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spbtrs(uplo, n, kd, nrhs, ab, ldab, b, ldb, info)
        fw_iserr__ = 0
      end subroutine spbtrs_c
      subroutine spftrf_c(transr, uplo, n, a_shape__, a, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spftrf
        fw_iserr__ = -1
        call spftrf(transr, uplo, n, a, info)
        fw_iserr__ = 0
      end subroutine spftrf_c
      subroutine spftri_c(transr, uplo, n, a_shape__, a, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spftri
        fw_iserr__ = -1
        call spftri(transr, uplo, n, a, info)
        fw_iserr__ = 0
      end subroutine spftri_c
      subroutine spftrs_c(transr, uplo, n, nrhs, a_shape__, a, b_shape__
     &, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1)) :: a
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spftrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spftrs(transr, uplo, n, nrhs, a, b, ldb, info)
        fw_iserr__ = 0
      end subroutine spftrs_c
      subroutine spocon_c(uplo, n, a_shape__, a, lda, anorm, rcond, work
     &_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spocon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spocon(uplo, n, a, lda, anorm, rcond, work, iwork, info)
        fw_iserr__ = 0
      end subroutine spocon_c
      subroutine spoequ_c(n, a_shape__, a, lda, s_shape__, s, scond, ama
     &x, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spoequ
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spoequ(n, a, lda, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine spoequ_c
      subroutine spoequb_c(n, a_shape__, a, lda, s_shape__, s, scond, am
     &ax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spoequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spoequb(n, a, lda, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine spoequb_c
      subroutine sporfs_c(uplo, n, nrhs, a_shape__, a, lda, af_shape__, 
     &af, ldaf, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr
     &, berr_shape__, berr, work_shape__, work, iwork_shape__, iwork, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sporfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sporfs(uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, fer
     &r, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sporfs_c
      subroutine sporfsx_c(uplo, equed, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, s_shape__, s, b_shape__, b, ldb, x_shape__, x, l
     &dx, rcond, berr_shape__, berr, n_err_bnds, err_bnds_norm_shape__, 
     &err_bnds_norm, err_bnds_comp_shape__, err_bnds_comp, nparams, para
     &ms_shape__, params, work_shape__, work, iwork_shape__, iwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sporfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sporfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, 
     &x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, npa
     &rams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sporfsx_c
      subroutine sposv_c(uplo, n, nrhs, a_shape__, a, lda, b_shape__, b,
     & ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sposv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sposv(uplo, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine sposv_c
      subroutine sposvx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sha
     &pe__, af, ldaf, equed, s_shape__, s, b_shape__, b, ldb, x_shape__,
     & x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape
     &__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sposvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sposvx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, 
     &ldb, x, ldx, rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sposvx_c
      subroutine sposvxx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, equed, s_shape__, s, b_shape__, b, ldb, x_shape__
     &, x, ldx, rcond, rpvgrw, berr_shape__, berr, n_err_bnds, err_bnds_
     &norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bnds_comp,
     & nparams, params_shape__, params, work_shape__, work, iwork_shape_
     &_, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        real(kind=kind(0.0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sposvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sposvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b,
     & ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_
     &bnds_comp, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sposvxx_c
      subroutine spotf2_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spotf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spotf2(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine spotf2_c
      subroutine spotrf_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spotrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spotrf(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine spotrf_c
      subroutine spotri_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spotri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spotri(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine spotri_c
      subroutine spotrs_c(uplo, n, nrhs, a_shape__, a, lda, b_shape__, b
     &, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spotrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spotrs(uplo, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine spotrs_c
      subroutine sppcon_c(uplo, n, ap_shape__, ap, anorm, rcond, work_sh
     &ape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sppcon
        fw_iserr__ = -1
        call sppcon(uplo, n, ap, anorm, rcond, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sppcon_c
      subroutine sppequ_c(uplo, n, ap_shape__, ap, s_shape__, s, scond, 
     &amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sppequ
        fw_iserr__ = -1
        call sppequ(uplo, n, ap, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine sppequ_c
      subroutine spprfs_c(uplo, n, nrhs, ap_shape__, ap, afp_shape__, af
     &p, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_
     &shape__, berr, work_shape__, work, iwork_shape__, iwork, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        real(kind=kind(0.0)), dimension(afp_shape__(1)) :: afp
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spprfs(uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, 
     &work, iwork, info)
        fw_iserr__ = 0
      end subroutine spprfs_c
      subroutine sppsv_c(uplo, n, nrhs, ap_shape__, ap, b_shape__, b, ld
     &b, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sppsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sppsv(uplo, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine sppsv_c
      subroutine sppsvx_c(fact, uplo, n, nrhs, ap_shape__, ap, afp_shape
     &__, afp, equed, s_shape__, s, b_shape__, b, ldb, x_shape__, x, ldx
     &, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, wor
     &k, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        real(kind=kind(0.0)), dimension(afp_shape__(1)) :: afp
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sppsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sppsvx(fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, l
     &dx, rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sppsvx_c
      subroutine spptrf_c(uplo, n, ap_shape__, ap, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spptrf
        fw_iserr__ = -1
        call spptrf(uplo, n, ap, info)
        fw_iserr__ = 0
      end subroutine spptrf_c
      subroutine spptri_c(uplo, n, ap_shape__, ap, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spptri
        fw_iserr__ = -1
        call spptri(uplo, n, ap, info)
        fw_iserr__ = 0
      end subroutine spptri_c
      subroutine spptrs_c(uplo, n, nrhs, ap_shape__, ap, b_shape__, b, l
     &db, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spptrs(uplo, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine spptrs_c
      subroutine spstf2_c(uplo, n, a_shape__, a, lda, piv_shape__, piv, 
     &rank, tol, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: piv_shape__
        integer, dimension(piv_shape__(1)) :: piv
        integer :: rank
        real(kind=kind(0.0)) :: tol
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spstf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (piv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("piv                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2*n) .lt. 0 .or. (2*n) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spstf2(uplo, n, a, lda, piv, rank, tol, work, info)
        fw_iserr__ = 0
      end subroutine spstf2_c
      subroutine spstrf_c(uplo, n, a_shape__, a, lda, piv_shape__, piv, 
     &rank, tol, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: piv_shape__
        integer, dimension(piv_shape__(1)) :: piv
        integer :: rank
        real(kind=kind(0.0)) :: tol
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spstrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (piv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("piv                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2*n) .lt. 0 .or. (2*n) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spstrf(uplo, n, a, lda, piv, rank, tol, work, info)
        fw_iserr__ = 0
      end subroutine spstrf_c
      subroutine sptcon_c(n, d_shape__, d, e_shape__, e, anorm, rcond, w
     &ork_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sptcon
        fw_iserr__ = -1
        call sptcon(n, d, e, anorm, rcond, work, info)
        fw_iserr__ = 0
      end subroutine sptcon_c
      subroutine spteqr_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spteqr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spteqr(compz, n, d, e, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine spteqr_c
      subroutine sptrfs_c(n, nrhs, d_shape__, d, e_shape__, e, df_shape_
     &_, df, ef_shape__, ef, b_shape__, b, ldb, x_shape__, x, ldx, ferr_
     &shape__, ferr, berr_shape__, berr, work_shape__, work, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: ef_shape__
        real(kind=kind(0.0)), dimension(ef_shape__(1)) :: ef
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sptrfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sptrfs(n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, w
     &ork, info)
        fw_iserr__ = 0
      end subroutine sptrfs_c
      subroutine sptsv_c(n, nrhs, d_shape__, d, e_shape__, e, b_shape__,
     & b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sptsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sptsv(n, nrhs, d, e, b, ldb, info)
        fw_iserr__ = 0
      end subroutine sptsv_c
      subroutine sptsvx_c(fact, n, nrhs, d_shape__, d, e_shape__, e, df_
     &shape__, df, ef_shape__, ef, b_shape__, b, ldb, x_shape__, x, ldx,
     & rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: ef_shape__
        real(kind=kind(0.0)), dimension(ef_shape__(1)) :: ef
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sptsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, 
     &ferr, berr, work, info)
        fw_iserr__ = 0
      end subroutine sptsvx_c
      subroutine spttrf_c(n, d_shape__, d, e_shape__, e, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spttrf
        fw_iserr__ = -1
        call spttrf(n, d, e, info)
        fw_iserr__ = 0
      end subroutine spttrf_c
      subroutine spttrs_c(n, nrhs, d_shape__, d, e_shape__, e, b_shape__
     &, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external spttrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call spttrs(n, nrhs, d, e, b, ldb, info)
        fw_iserr__ = 0
      end subroutine spttrs_c
      subroutine sptts2_c(n, nrhs, d_shape__, d, e_shape__, e, b_shape__
     &, b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sptts2
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sptts2(n, nrhs, d, e, b, ldb)
        fw_iserr__ = 0
      end subroutine sptts2_c
      subroutine srscl_c(n, sa, sx_shape__, sx, incx, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0)) :: sa
        integer, dimension(1) :: sx_shape__
        real(kind=kind(0.0)), dimension(sx_shape__(1)) :: sx
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external srscl
        fw_iserr__ = -1
        call srscl(n, sa, sx, incx)
        fw_iserr__ = 0
      end subroutine srscl_c
      subroutine ssbev_c(jobz, uplo, n, kd, ab_shape__, ab, ldab, w_shap
     &e__, w, z_shape__, z, ldz, work_shape__, work, info, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssbev
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssbev(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine ssbev_c
      subroutine ssbevd_c(jobz, uplo, n, kd, ab_shape__, ab, ldab, w_sha
     &pe__, w, z_shape__, z, ldz, work_shape__, work, lwork, iwork_shape
     &__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssbevd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssbevd(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork,
     & iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine ssbevd_c
      subroutine ssbevx_c(jobz, range, uplo, n, kd, ab_shape__, ab, ldab
     &, q_shape__, q, ldq, vl, vu, il, iu, abstol, m, w_shape__, w, z_sh
     &ape__, z, ldz, work_shape__, work, iwork_shape__, iwork, ifail_sha
     &pe__, ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssbevx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssbevx(jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, 
     &il, iu, abstol, m, w, z, ldz, work, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine ssbevx_c
      subroutine ssbgst_c(vect, uplo, n, ka, kb, ab_shape__, ab, ldab, b
     &b_shape__, bb, ldbb, x_shape__, x, ldx, work_shape__, work, info, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        real(kind=kind(0.0)), dimension(bb_shape__(1), bb_shape__(2)) ::
     & bb
        integer :: ldbb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssbgst
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssbgst(vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, w
     &ork, info)
        fw_iserr__ = 0
      end subroutine ssbgst_c
      subroutine ssbgv_c(jobz, uplo, n, ka, kb, ab_shape__, ab, ldab, bb
     &_shape__, bb, ldbb, w_shape__, w, z_shape__, z, ldz, work_shape__,
     & work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        real(kind=kind(0.0)), dimension(bb_shape__(1), bb_shape__(2)) ::
     & bb
        integer :: ldbb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssbgv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssbgv(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz,
     & work, info)
        fw_iserr__ = 0
      end subroutine ssbgv_c
      subroutine ssbgvd_c(jobz, uplo, n, ka, kb, ab_shape__, ab, ldab, b
     &b_shape__, bb, ldbb, w_shape__, w, z_shape__, z, ldz, work_shape__
     &, work, lwork, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        real(kind=kind(0.0)), dimension(bb_shape__(1), bb_shape__(2)) ::
     & bb
        integer :: ldbb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssbgvd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssbgvd(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz
     &, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine ssbgvd_c
      subroutine ssbgvx_c(jobz, range, uplo, n, ka, kb, ab_shape__, ab, 
     &ldab, bb_shape__, bb, ldbb, q_shape__, q, ldq, vl, vu, il, iu, abs
     &tol, m, w_shape__, w, z_shape__, z, ldz, work_shape__, work, iwork
     &_shape__, iwork, ifail_shape__, ifail, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        real(kind=kind(0.0)), dimension(bb_shape__(1), bb_shape__(2)) ::
     & bb
        integer :: ldbb
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssbgvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssbgvx(jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q,
     & ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail, in
     &fo)
        fw_iserr__ = 0
      end subroutine ssbgvx_c
      subroutine ssbtrd_c(vect, uplo, n, kd, ab_shape__, ab, ldab, d_sha
     &pe__, d, e_shape__, e, q_shape__, q, ldq, work_shape__, work, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssbtrd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssbtrd(vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine ssbtrd_c
      subroutine ssfrk_c(transr, uplo, trans, n, k, alpha, a_shape__, a,
     & lda, beta, c_shape__, c, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: k
        real(kind=kind(0.0)) :: alpha
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: beta
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1)) :: c
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssfrk
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssfrk(transr, uplo, trans, n, k, alpha, a, lda, beta, c)
        fw_iserr__ = 0
      end subroutine ssfrk_c
      subroutine sspcon_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, a
     &norm, rcond, work_shape__, work, iwork_shape__, iwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sspcon
        fw_iserr__ = -1
        call sspcon(uplo, n, ap, ipiv, anorm, rcond, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sspcon_c
      subroutine sspev_c(jobz, uplo, n, ap_shape__, ap, w_shape__, w, z_
     &shape__, z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sspev
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sspev(jobz, uplo, n, ap, w, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine sspev_c
      subroutine sspevd_c(jobz, uplo, n, ap_shape__, ap, w_shape__, w, z
     &_shape__, z, ldz, work_shape__, work, lwork, iwork_shape__, iwork,
     & liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sspevd
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sspevd(jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, li
     &work, info)
        fw_iserr__ = 0
      end subroutine sspevd_c
      subroutine sspevx_c(jobz, range, uplo, n, ap_shape__, ap, vl, vu, 
     &il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, work_shape__, 
     &work, iwork_shape__, iwork, ifail_shape__, ifail, info, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sspevx
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sspevx(jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m,
     & w, z, ldz, work, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine sspevx_c
      subroutine sspgst_c(itype, uplo, n, ap_shape__, ap, bp_shape__, bp
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        real(kind=kind(0.0)), dimension(bp_shape__(1)) :: bp
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sspgst
        fw_iserr__ = -1
        call sspgst(itype, uplo, n, ap, bp, info)
        fw_iserr__ = 0
      end subroutine sspgst_c
      subroutine sspgv_c(itype, jobz, uplo, n, ap_shape__, ap, bp_shape_
     &_, bp, w_shape__, w, z_shape__, z, ldz, work_shape__, work, info, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        real(kind=kind(0.0)), dimension(bp_shape__(1)) :: bp
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sspgv
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sspgv(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine sspgv_c
      subroutine sspgvd_c(itype, jobz, uplo, n, ap_shape__, ap, bp_shape
     &__, bp, w_shape__, w, z_shape__, z, ldz, work_shape__, work, lwork
     &, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        real(kind=kind(0.0)), dimension(bp_shape__(1)) :: bp
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sspgvd
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sspgvd(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork
     &, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine sspgvd_c
      subroutine sspgvx_c(itype, jobz, range, uplo, n, ap_shape__, ap, b
     &p_shape__, bp, vl, vu, il, iu, abstol, m, w_shape__, w, z_shape__,
     & z, ldz, work_shape__, work, iwork_shape__, iwork, ifail_shape__, 
     &ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        real(kind=kind(0.0)), dimension(bp_shape__(1)) :: bp
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sspgvx
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sspgvx(itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu,
     & abstol, m, w, z, ldz, work, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine sspgvx_c
      subroutine ssprfs_c(uplo, n, nrhs, ap_shape__, ap, afp_shape__, af
     &p, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx, ferr_
     &shape__, ferr, berr_shape__, berr, work_shape__, work, iwork_shape
     &__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        real(kind=kind(0.0)), dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssprfs(uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, 
     &berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine ssprfs_c
      subroutine sspsv_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, ip
     &iv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sspsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sspsv(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine sspsv_c
      subroutine sspsvx_c(fact, uplo, n, nrhs, ap_shape__, ap, afp_shape
     &__, afp, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx,
     & rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work
     &, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        real(kind=kind(0.0)), dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sspsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sspsvx(fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, 
     &rcond, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sspsvx_c
      subroutine ssptrd_c(uplo, n, ap_shape__, ap, d_shape__, d, e_shape
     &__, e, tau_shape__, tau, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssptrd
        fw_iserr__ = -1
        call ssptrd(uplo, n, ap, d, e, tau, info)
        fw_iserr__ = 0
      end subroutine ssptrd_c
      subroutine ssptrf_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssptrf
        fw_iserr__ = -1
        call ssptrf(uplo, n, ap, ipiv, info)
        fw_iserr__ = 0
      end subroutine ssptrf_c
      subroutine ssptri_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, w
     &ork_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssptri
        fw_iserr__ = -1
        call ssptri(uplo, n, ap, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine ssptri_c
      subroutine ssptrs_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, i
     &piv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssptrs(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine ssptrs_c
      subroutine sstebz_c(range, order, n, vl, vu, il, iu, abstol, d_sha
     &pe__, d, e_shape__, e, m, nsplit, w_shape__, w, iblock_shape__, ib
     &lock, isplit_shape__, isplit, work_shape__, work, iwork_shape__, i
     &work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: order
        integer :: n
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer :: m
        integer :: nsplit
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sstebz
        fw_iserr__ = -1
        call sstebz(range, order, n, vl, vu, il, iu, abstol, d, e, m, ns
     &plit, w, iblock, isplit, work, iwork, info)
        fw_iserr__ = 0
      end subroutine sstebz_c
      subroutine sstedc_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, lwork, iwork_shape__, iwork, liwork
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sstedc
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sstedc(compz, n, d, e, z, ldz, work, lwork, iwork, liwork, 
     &info)
        fw_iserr__ = 0
      end subroutine sstedc_c
      subroutine sstegr_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, isuppz_s
     &hape__, isuppz, work_shape__, work, lwork, iwork_shape__, iwork, l
     &iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sstegr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sstegr(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, 
     &z, ldz, isuppz, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine sstegr_c
      subroutine sstein_c(n, d_shape__, d, e_shape__, e, m, w_shape__, w
     &, iblock_shape__, iblock, isplit_shape__, isplit, z_shape__, z, ld
     &z, work_shape__, work, iwork_shape__, iwork, ifail_shape__, ifail,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sstein
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sstein(n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, 
     &ifail, info)
        fw_iserr__ = 0
      end subroutine sstein_c
      subroutine sstemr_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, m, w_shape__, w, z_shape__, z, ldz, nzc, isuppz_shap
     &e__, isuppz, tryrac, work_shape__, work, lwork, iwork_shape__, iwo
     &rk, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: nzc
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer(kind=kind(0)) :: tryrac
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sstemr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sstemr(jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, 
     &nzc, isuppz, tryrac, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine sstemr_c
      subroutine ssteqr_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssteqr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssteqr(compz, n, d, e, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine ssteqr_c
      subroutine ssterf_c(n, d_shape__, d, e_shape__, e, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssterf
        fw_iserr__ = -1
        call ssterf(n, d, e, info)
        fw_iserr__ = 0
      end subroutine ssterf_c
      subroutine sstev_c(jobz, n, d_shape__, d, e_shape__, e, z_shape__,
     & z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sstev
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sstev(jobz, n, d, e, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine sstev_c
      subroutine sstevd_c(jobz, n, d_shape__, d, e_shape__, e, z_shape__
     &, z, ldz, work_shape__, work, lwork, iwork_shape__, iwork, liwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sstevd
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sstevd(jobz, n, d, e, z, ldz, work, lwork, iwork, liwork, i
     &nfo)
        fw_iserr__ = 0
      end subroutine sstevd_c
      subroutine sstevr_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, isuppz_s
     &hape__, isuppz, work_shape__, work, lwork, iwork_shape__, iwork, l
     &iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sstevr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sstevr(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, 
     &z, ldz, isuppz, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine sstevr_c
      subroutine sstevx_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, work_sha
     &pe__, work, iwork_shape__, iwork, ifail_shape__, ifail, info, fw_i
     &serr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external sstevx
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call sstevx(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, 
     &z, ldz, work, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine sstevx_c
      subroutine ssycon_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, anorm, rcond, work_shape__, work, iwork_shape__, iwork, info, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0)) :: anorm
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssycon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssycon(uplo, n, a, lda, ipiv, anorm, rcond, work, iwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine ssycon_c
      subroutine ssyconv_c(uplo, way, n, a_shape__, a, lda, ipiv_shape__
     &, ipiv, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: way
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssyconv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssyconv(uplo, way, n, a, lda, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine ssyconv_c
      subroutine ssyequb_c(uplo, n, a_shape__, a, lda, s_shape__, s, sco
     &nd, amax, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0)) :: scond
        real(kind=kind(0.0)) :: amax
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssyequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssyequb(uplo, n, a, lda, s, scond, amax, work, info)
        fw_iserr__ = 0
      end subroutine ssyequb_c
      subroutine ssyev_c(jobz, uplo, n, a_shape__, a, lda, w_shape__, w,
     & work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssyev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssyev(jobz, uplo, n, a, lda, w, work, lwork, info)
        fw_iserr__ = 0
      end subroutine ssyev_c
      subroutine ssyevd_c(jobz, uplo, n, a_shape__, a, lda, w_shape__, w
     &, work_shape__, work, lwork, iwork_shape__, iwork, liwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssyevd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssyevd(jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork
     &, info)
        fw_iserr__ = 0
      end subroutine ssyevd_c
      subroutine ssyevr_c(jobz, range, uplo, n, a_shape__, a, lda, vl, v
     &u, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, isuppz_shap
     &e__, isuppz, work_shape__, work, lwork, iwork_shape__, iwork, liwo
     &rk, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssyevr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssyevr(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol
     &, m, w, z, ldz, isuppz, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine ssyevr_c
      subroutine ssyevx_c(jobz, range, uplo, n, a_shape__, a, lda, vl, v
     &u, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, work_shape_
     &_, work, lwork, iwork_shape__, iwork, ifail_shape__, ifail, info, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssyevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssyevx(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol
     &, m, w, z, ldz, work, lwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine ssyevx_c
      subroutine ssygs2_c(itype, uplo, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssygs2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssygs2(itype, uplo, n, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine ssygs2_c
      subroutine ssygst_c(itype, uplo, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssygst
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssygst(itype, uplo, n, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine ssygst_c
      subroutine ssygv_c(itype, jobz, uplo, n, a_shape__, a, lda, b_shap
     &e__, b, ldb, w_shape__, w, work_shape__, work, lwork, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssygv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssygv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork,
     & info)
        fw_iserr__ = 0
      end subroutine ssygv_c
      subroutine ssygvd_c(itype, jobz, uplo, n, a_shape__, a, lda, b_sha
     &pe__, b, ldb, w_shape__, w, work_shape__, work, lwork, iwork_shape
     &__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssygvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssygvd(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork
     &, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine ssygvd_c
      subroutine ssygvx_c(itype, jobz, range, uplo, n, a_shape__, a, lda
     &, b_shape__, b, ldb, vl, vu, il, iu, abstol, m, w_shape__, w, z_sh
     &ape__, z, ldz, work_shape__, work, lwork, iwork_shape__, iwork, if
     &ail_shape__, ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: vl
        real(kind=kind(0.0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssygvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssygvx(itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu,
     & il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine ssygvx_c
      subroutine ssyrfs_c(uplo, n, nrhs, a_shape__, a, lda, af_shape__, 
     &af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx
     &, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, iwor
     &k_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssyrfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssyrfs(uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ld
     &x, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine ssyrfs_c
      subroutine ssyrfsx_c(uplo, equed, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, ipiv_shape__, ipiv, s_shape__, s, b_shape__, b, 
     &ldb, x_shape__, x, ldx, rcond, berr_shape__, berr, n_err_bnds, err
     &_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bnds
     &_comp, nparams, params_shape__, params, work_shape__, work, iwork_
     &shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssyrfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssyrfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b,
     & ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_com
     &p, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine ssyrfsx_c
      subroutine ssysv_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__,
     & ipiv, b_shape__, b, ldb, work_shape__, work, lwork, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssysv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssysv(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine ssysv_c
      subroutine ssysvx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sha
     &pe__, af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, 
     &x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape_
     &_, work, lwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssysvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssysvx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     & x, ldx, rcond, ferr, berr, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine ssysvx_c
      subroutine ssysvxx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, ipiv_shape__, ipiv, equed, s_shape__, s, b_shape_
     &_, b, ldb, x_shape__, x, ldx, rcond, rpvgrw, berr_shape__, berr, n
     &_err_bnds, err_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_sha
     &pe__, err_bnds_comp, nparams, params_shape__, params, work_shape__
     &, work, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        real(kind=kind(0.0)), dimension(af_shape__(1), af_shape__(2)) ::
     & af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0)) :: rcond
        real(kind=kind(0.0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0)), dimension(err_bnds_norm_shape__(1), err_bn
     &ds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0)), dimension(err_bnds_comp_shape__(1), err_bn
     &ds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssysvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssysvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed,
     & s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm
     &, err_bnds_comp, nparams, params, work, iwork, info)
        fw_iserr__ = 0
      end subroutine ssysvxx_c
      subroutine ssyswapr_c(uplo, n, a_shape__, a, i1, i2, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: i1
        integer :: i2
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssyswapr
        fw_iserr__ = -1
        if ((n) .ne. (a_shape__(1)) .or. (n) .lt. 0 .or. (n) .gt. (a_sha
     &pe__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssyswapr(uplo, n, a, i1, i2)
        fw_iserr__ = 0
      end subroutine ssyswapr_c
      subroutine ssytd2_c(uplo, n, a_shape__, a, lda, d_shape__, d, e_sh
     &ape__, e, tau_shape__, tau, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssytd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssytd2(uplo, n, a, lda, d, e, tau, info)
        fw_iserr__ = 0
      end subroutine ssytd2_c
      subroutine ssytf2_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssytf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssytf2(uplo, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine ssytf2_c
      subroutine ssytrd_c(uplo, n, a_shape__, a, lda, d_shape__, d, e_sh
     &ape__, e, tau_shape__, tau, work_shape__, work, lwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssytrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssytrd(uplo, n, a, lda, d, e, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine ssytrd_c
      subroutine ssytrf_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssytrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssytrf(uplo, n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine ssytrf_c
      subroutine ssytri_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssytri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssytri(uplo, n, a, lda, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine ssytri_c
      subroutine ssytri2_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipi
     &v, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssytri2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssytri2(uplo, n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine ssytri2_c
      subroutine ssytri2x_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ip
     &iv, work_shape__, work, nb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1), work_shape__(2)
     &) :: work
        integer :: nb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssytri2x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n+nb+1) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssytri2x(uplo, n, a, lda, ipiv, work, nb, info)
        fw_iserr__ = 0
      end subroutine ssytri2x_c
      subroutine ssytrs_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__
     &, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssytrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssytrs(uplo, n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine ssytrs_c
      subroutine ssytrs2_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape_
     &_, ipiv, b_shape__, b, ldb, work_shape__, work, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ssytrs2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ssytrs2(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, info)
        fw_iserr__ = 0
      end subroutine ssytrs2_c
      subroutine stbcon_c(norm, uplo, diag, n, kd, ab_shape__, ab, ldab,
     & rcond, work_shape__, work, iwork_shape__, iwork, info, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stbcon(norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwor
     &k, info)
        fw_iserr__ = 0
      end subroutine stbcon_c
      subroutine stbrfs_c(uplo, trans, diag, n, kd, nrhs, ab_shape__, ab
     &, ldab, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, 
     &berr_shape__, berr, work_shape__, work, iwork_shape__, iwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stbrfs(uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x,
     & ldx, ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine stbrfs_c
      subroutine stbtrs_c(uplo, trans, diag, n, kd, nrhs, ab_shape__, ab
     &, ldab, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        real(kind=kind(0.0)), dimension(ab_shape__(1), ab_shape__(2)) ::
     & ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stbtrs(uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, in
     &fo)
        fw_iserr__ = 0
      end subroutine stbtrs_c
      subroutine stfsm_c(transr, side, uplo, trans, diag, m, n, alpha, a
     &_shape__, a, b_shape__, b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: m
        integer :: n
        real(kind=kind(0.0)) :: alpha
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1)) :: a
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stfsm
        fw_iserr__ = -1
        if (((ldb-1) - (0) + 1) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stfsm(transr, side, uplo, trans, diag, m, n, alpha, a, b, l
     &db)
        fw_iserr__ = 0
      end subroutine stfsm_c
      subroutine stftri_c(transr, uplo, diag, n, a_shape__, a, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stftri
        fw_iserr__ = -1
        call stftri(transr, uplo, diag, n, a, info)
        fw_iserr__ = 0
      end subroutine stftri_c
      subroutine stfttp_c(transr, uplo, n, arf_shape__, arf, ap_shape__,
     & ap, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: arf_shape__
        real(kind=kind(0.0)), dimension(arf_shape__(1)) :: arf
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stfttp
        fw_iserr__ = -1
        call stfttp(transr, uplo, n, arf, ap, info)
        fw_iserr__ = 0
      end subroutine stfttp_c
      subroutine stfttr_c(transr, uplo, n, arf_shape__, arf, a_shape__, 
     &a, lda, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: arf_shape__
        real(kind=kind(0.0)), dimension(arf_shape__(1)) :: arf
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stfttr
        fw_iserr__ = -1
        if (((lda-1) - (0) + 1) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stfttr(transr, uplo, n, arf, a, lda, info)
        fw_iserr__ = 0
      end subroutine stfttr_c
      subroutine stgevc_c(side, howmny, select_shape__, select, n, s_sha
     &pe__, s, lds, p_shape__, p, ldp, vl_shape__, vl, ldvl, vr_shape__,
     & vr, ldvr, mm, m, work_shape__, work, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1), s_shape__(2)) :: s
        integer :: lds
        integer, dimension(2) :: p_shape__
        real(kind=kind(0.0)), dimension(p_shape__(1), p_shape__(2)) :: p
        integer :: ldp
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1), vl_shape__(2)) ::
     & vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1), vr_shape__(2)) ::
     & vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stgevc
        fw_iserr__ = -1
        if ((lds) .ne. (s_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("s                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldp) .ne. (p_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("p                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stgevc(side, howmny, select, n, s, lds, p, ldp, vl, ldvl, v
     &r, ldvr, mm, m, work, info)
        fw_iserr__ = 0
      end subroutine stgevc_c
      subroutine stgex2_c(wantq, wantz, n, a_shape__, a, lda, b_shape__,
     & b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, j1, n1, n2, work_sh
     &ape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: j1
        integer :: n1
        integer :: n2
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stgex2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stgex2(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, j1,
     & n1, n2, work, lwork, info)
        fw_iserr__ = 0
      end subroutine stgex2_c
      subroutine stgexc_c(wantq, wantz, n, a_shape__, a, lda, b_shape__,
     & b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, ifst, ilst, work_sh
     &ape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: ifst
        integer :: ilst
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stgexc
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stgexc(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifs
     &t, ilst, work, lwork, info)
        fw_iserr__ = 0
      end subroutine stgexc_c
      subroutine stgsen_c(ijob, wantq, wantz, select_shape__, select, n,
     & a_shape__, a, lda, b_shape__, b, ldb, alphar_shape__, alphar, alp
     &hai_shape__, alphai, beta_shape__, beta, q_shape__, q, ldq, z_shap
     &e__, z, ldz, m, pl, pr, dif_shape__, dif, work_shape__, work, lwor
     &k, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: ijob
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alphar_shape__
        real(kind=kind(0.0)), dimension(alphar_shape__(1)) :: alphar
        integer, dimension(1) :: alphai_shape__
        real(kind=kind(0.0)), dimension(alphai_shape__(1)) :: alphai
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0)), dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: m
        real(kind=kind(0.0)) :: pl
        real(kind=kind(0.0)) :: pr
        integer, dimension(1) :: dif_shape__
        real(kind=kind(0.0)), dimension(dif_shape__(1)) :: dif
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stgsen
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stgsen(ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha
     &r, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwor
     &k, liwork, info)
        fw_iserr__ = 0
      end subroutine stgsen_c
      subroutine stgsja_c(jobu, jobv, jobq, m, p, n, k, l, a_shape__, a,
     & lda, b_shape__, b, ldb, tola, tolb, alpha_shape__, alpha, beta_sh
     &ape__, beta, u_shape__, u, ldu, v_shape__, v, ldv, q_shape__, q, l
     &dq, work_shape__, work, ncycle, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: p
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0)) :: tola
        real(kind=kind(0.0)) :: tolb
        integer, dimension(1) :: alpha_shape__
        real(kind=kind(0.0)), dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0)), dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        real(kind=kind(0.0)), dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: ncycle
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stgsja
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stgsja(jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tol
     &a, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle, info)
        fw_iserr__ = 0
      end subroutine stgsja_c
      subroutine stgsna_c(job, howmny, select_shape__, select, n, a_shap
     &e__, a, lda, b_shape__, b, ldb, vl_shape__, vl, ldvl, vr_shape__, 
     &vr, ldvr, s_shape__, s, dif_shape__, dif, mm, m, work_shape__, wor
     &k, lwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1), vl_shape__(2)) ::
     & vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1), vr_shape__(2)) ::
     & vr
        integer :: ldvr
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: dif_shape__
        real(kind=kind(0.0)), dimension(dif_shape__(1)) :: dif
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stgsna
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stgsna(job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr
     &, ldvr, s, dif, mm, m, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine stgsna_c
      subroutine stgsy2_c(trans, ijob, m, n, a_shape__, a, lda, b_shape_
     &_, b, ldb, c_shape__, c, ldc, d_shape__, d, ldd, e_shape__, e, lde
     &, f_shape__, f, ldf, scale, rdsum, rdscal, iwork_shape__, iwork, p
     &q, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: ijob
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(2) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1), d_shape__(2)) :: d
        integer :: ldd
        integer, dimension(2) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1), e_shape__(2)) :: e
        integer :: lde
        integer, dimension(2) :: f_shape__
        real(kind=kind(0.0)), dimension(f_shape__(1), f_shape__(2)) :: f
        integer :: ldf
        real(kind=kind(0.0)) :: scale
        real(kind=kind(0.0)) :: rdsum
        real(kind=kind(0.0)) :: rdscal
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: pq
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stgsy2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldd) .ne. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lde) .ne. (e_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("e                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stgsy2(trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e
     &, lde, f, ldf, scale, rdsum, rdscal, iwork, pq, info)
        fw_iserr__ = 0
      end subroutine stgsy2_c
      subroutine stgsyl_c(trans, ijob, m, n, a_shape__, a, lda, b_shape_
     &_, b, ldb, c_shape__, c, ldc, d_shape__, d, ldd, e_shape__, e, lde
     &, f_shape__, f, ldf, scale, dif, work_shape__, work, lwork, iwork_
     &shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: ijob
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(2) :: d_shape__
        real(kind=kind(0.0)), dimension(d_shape__(1), d_shape__(2)) :: d
        integer :: ldd
        integer, dimension(2) :: e_shape__
        real(kind=kind(0.0)), dimension(e_shape__(1), e_shape__(2)) :: e
        integer :: lde
        integer, dimension(2) :: f_shape__
        real(kind=kind(0.0)), dimension(f_shape__(1), f_shape__(2)) :: f
        integer :: ldf
        real(kind=kind(0.0)) :: scale
        real(kind=kind(0.0)) :: dif
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stgsyl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldd) .ne. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lde) .ne. (e_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("e                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stgsyl(trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e
     &, lde, f, ldf, scale, dif, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine stgsyl_c
      subroutine stpcon_c(norm, uplo, diag, n, ap_shape__, ap, rcond, wo
     &rk_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stpcon
        fw_iserr__ = -1
        call stpcon(norm, uplo, diag, n, ap, rcond, work, iwork, info)
        fw_iserr__ = 0
      end subroutine stpcon_c
      subroutine stprfs_c(uplo, trans, diag, n, nrhs, ap_shape__, ap, b_
     &shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_shape
     &__, berr, work_shape__, work, iwork_shape__, iwork, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stprfs(uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr
     &, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine stprfs_c
      subroutine stptri_c(uplo, diag, n, ap_shape__, ap, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stptri
        fw_iserr__ = -1
        call stptri(uplo, diag, n, ap, info)
        fw_iserr__ = 0
      end subroutine stptri_c
      subroutine stptrs_c(uplo, trans, diag, n, nrhs, ap_shape__, ap, b_
     &shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stptrs(uplo, trans, diag, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine stptrs_c
      subroutine stpttf_c(transr, uplo, n, ap_shape__, ap, arf_shape__, 
     &arf, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: arf_shape__
        real(kind=kind(0.0)), dimension(arf_shape__(1)) :: arf
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stpttf
        fw_iserr__ = -1
        call stpttf(transr, uplo, n, ap, arf, info)
        fw_iserr__ = 0
      end subroutine stpttf_c
      subroutine stpttr_c(uplo, n, ap_shape__, ap, a_shape__, a, lda, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stpttr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stpttr(uplo, n, ap, a, lda, info)
        fw_iserr__ = 0
      end subroutine stpttr_c
      subroutine strcon_c(norm, uplo, diag, n, a_shape__, a, lda, rcond,
     & work_shape__, work, iwork_shape__, iwork, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0)) :: rcond
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strcon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strcon(norm, uplo, diag, n, a, lda, rcond, work, iwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine strcon_c
      subroutine strevc_c(side, howmny, select_shape__, select, n, t_sha
     &pe__, t, ldt, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, mm, m, w
     &ork_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1), vl_shape__(2)) ::
     & vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1), vr_shape__(2)) ::
     & vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strevc
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strevc(side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr,
     & mm, m, work, info)
        fw_iserr__ = 0
      end subroutine strevc_c
      subroutine strexc_c(compq, n, t_shape__, t, ldt, q_shape__, q, ldq
     &, ifst, ilst, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compq
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer :: ifst
        integer :: ilst
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strexc
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strexc(compq, n, t, ldt, q, ldq, ifst, ilst, work, info)
        fw_iserr__ = 0
      end subroutine strexc_c
      subroutine strrfs_c(uplo, trans, diag, n, nrhs, a_shape__, a, lda,
     & b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_sh
     &ape__, berr, work_shape__, work, iwork_shape__, iwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        real(kind=kind(0.0)), dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strrfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strrfs(uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, 
     &ferr, berr, work, iwork, info)
        fw_iserr__ = 0
      end subroutine strrfs_c
      subroutine strsen_c(job, compq, select_shape__, select, n, t_shape
     &__, t, ldt, q_shape__, q, ldq, wr_shape__, wr, wi_shape__, wi, m, 
     &s, sep, work_shape__, work, lwork, iwork_shape__, iwork, liwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compq
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: q_shape__
        real(kind=kind(0.0)), dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: wr_shape__
        real(kind=kind(0.0)), dimension(wr_shape__(1)) :: wr
        integer, dimension(1) :: wi_shape__
        real(kind=kind(0.0)), dimension(wi_shape__(1)) :: wi
        integer :: m
        real(kind=kind(0.0)) :: s
        real(kind=kind(0.0)) :: sep
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strsen
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strsen(job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s,
     & sep, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine strsen_c
      subroutine strsna_c(job, howmny, select_shape__, select, n, t_shap
     &e__, t, ldt, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, s_shape__
     &, s, sep_shape__, sep, mm, m, work_shape__, work, ldwork, iwork_sh
     &ape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        real(kind=kind(0.0)), dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: vl_shape__
        real(kind=kind(0.0)), dimension(vl_shape__(1), vl_shape__(2)) ::
     & vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        real(kind=kind(0.0)), dimension(vr_shape__(1), vr_shape__(2)) ::
     & vr
        integer :: ldvr
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: sep_shape__
        real(kind=kind(0.0)), dimension(sep_shape__(1)) :: sep
        integer :: mm
        integer :: m
        integer, dimension(2) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1), work_shape__(2)
     &) :: work
        integer :: ldwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strsna
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strsna(job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, 
     &s, sep, mm, m, work, ldwork, iwork, info)
        fw_iserr__ = 0
      end subroutine strsna_c
      subroutine strsyl_c(trana, tranb, isgn, m, n, a_shape__, a, lda, b
     &_shape__, b, ldb, c_shape__, c, ldc, scale, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trana
        character(len=1, kind=kind('a')) :: tranb
        integer :: isgn
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        real(kind=kind(0.0)), dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        real(kind=kind(0.0)) :: scale
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strsyl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, sc
     &ale, info)
        fw_iserr__ = 0
      end subroutine strsyl_c
      subroutine strti2_c(uplo, diag, n, a_shape__, a, lda, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strti2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strti2(uplo, diag, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine strti2_c
      subroutine strtri_c(uplo, diag, n, a_shape__, a, lda, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strtri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strtri(uplo, diag, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine strtri_c
      subroutine strtrs_c(uplo, trans, diag, n, nrhs, a_shape__, a, lda,
     & b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0)), dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strtrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strtrs(uplo, trans, diag, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine strtrs_c
      subroutine strttf_c(transr, uplo, n, a_shape__, a, lda, arf_shape_
     &_, arf, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: arf_shape__
        real(kind=kind(0.0)), dimension(arf_shape__(1)) :: arf
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strttf
        fw_iserr__ = -1
        if (((lda-1) - (0) + 1) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strttf(transr, uplo, n, a, lda, arf, info)
        fw_iserr__ = 0
      end subroutine strttf_c
      subroutine strttp_c(uplo, n, a_shape__, a, lda, ap_shape__, ap, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ap_shape__
        real(kind=kind(0.0)), dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external strttp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call strttp(uplo, n, a, lda, ap, info)
        fw_iserr__ = 0
      end subroutine strttp_c
      subroutine stzrqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stzrqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stzrqf(m, n, a, lda, tau, info)
        fw_iserr__ = 0
      end subroutine stzrqf_c
      subroutine stzrzf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0)), dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        real(kind=kind(0.0)), dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external stzrzf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call stzrzf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine stzrzf_c
      subroutine zbbcsd_c(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, 
     &theta_shape__, theta, phi_shape__, phi, u1_shape__, u1, ldu1, u2_s
     &hape__, u2, ldu2, v1t_shape__, v1t, ldv1t, v2t_shape__, v2t, ldv2t
     &, b11d_shape__, b11d, b11e_shape__, b11e, b12d_shape__, b12d, b12e
     &_shape__, b12e, b21d_shape__, b21d, b21e_shape__, b21e, b22d_shape
     &__, b22d, b22e_shape__, b22e, rwork_shape__, rwork, lrwork, info, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu1
        character(len=1, kind=kind('a')) :: jobu2
        character(len=1, kind=kind('a')) :: jobv1t
        character(len=1, kind=kind('a')) :: jobv2t
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0D0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(1) :: phi_shape__
        real(kind=kind(0.0D0)), dimension(phi_shape__(1)) :: phi
        integer, dimension(2) :: u1_shape__
        complex*16, dimension(u1_shape__(1), u1_shape__(2)) :: u1
        integer :: ldu1
        integer, dimension(2) :: u2_shape__
        complex*16, dimension(u2_shape__(1), u2_shape__(2)) :: u2
        integer :: ldu2
        integer, dimension(2) :: v1t_shape__
        complex*16, dimension(v1t_shape__(1), v1t_shape__(2)) :: v1t
        integer :: ldv1t
        integer, dimension(2) :: v2t_shape__
        complex*16, dimension(v2t_shape__(1), v2t_shape__(2)) :: v2t
        integer :: ldv2t
        integer, dimension(1) :: b11d_shape__
        real(kind=kind(0.0D0)), dimension(b11d_shape__(1)) :: b11d
        integer, dimension(1) :: b11e_shape__
        real(kind=kind(0.0D0)), dimension(b11e_shape__(1)) :: b11e
        integer, dimension(1) :: b12d_shape__
        real(kind=kind(0.0D0)), dimension(b12d_shape__(1)) :: b12d
        integer, dimension(1) :: b12e_shape__
        real(kind=kind(0.0D0)), dimension(b12e_shape__(1)) :: b12e
        integer, dimension(1) :: b21d_shape__
        real(kind=kind(0.0D0)), dimension(b21d_shape__(1)) :: b21d
        integer, dimension(1) :: b21e_shape__
        real(kind=kind(0.0D0)), dimension(b21e_shape__(1)) :: b21e
        integer, dimension(1) :: b22d_shape__
        real(kind=kind(0.0D0)), dimension(b22d_shape__(1)) :: b22d
        integer, dimension(1) :: b22e_shape__
        real(kind=kind(0.0D0)), dimension(b22e_shape__(1)) :: b22e
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zbbcsd
        fw_iserr__ = -1
        if ((ldu1) .ne. (u1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv1t) .ne. (v1t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v1t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv2t) .ne. (v2t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v2t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zbbcsd(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta,
     & phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d
     &, b12e, b21d, b21e, b22d, b22e, rwork, lrwork, info)
        fw_iserr__ = 0
      end subroutine zbbcsd_c
      subroutine zbdsqr_c(uplo, n, ncvt, nru, ncc, d_shape__, d, e_shape
     &__, e, vt_shape__, vt, ldvt, u_shape__, u, ldu, c_shape__, c, ldc,
     & rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ncvt
        integer :: nru
        integer :: ncc
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: vt_shape__
        complex*16, dimension(vt_shape__(1), vt_shape__(2)) :: vt
        integer :: ldvt
        integer, dimension(2) :: u_shape__
        complex*16, dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zbdsqr
        fw_iserr__ = -1
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zbdsqr(uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, 
     &ldc, rwork, info)
        fw_iserr__ = 0
      end subroutine zbdsqr_c
      subroutine zcgesv_c(n, nrhs, a_shape__, a, lda, ipiv_shape__, ipiv
     &, b_shape__, b, ldb, x_shape__, x, ldx, work_shape__, work, swork_
     &shape__, swork, rwork_shape__, rwork, iter, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(2) :: work_shape__
        complex*16, dimension(work_shape__(1), work_shape__(2)) :: work
        integer, dimension(1) :: swork_shape__
        complex(kind=kind((0.0,0.0))), dimension(swork_shape__(1)) :: sw
     &ork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: iter
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zcgesv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zcgesv(n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, 
     &rwork, iter, info)
        fw_iserr__ = 0
      end subroutine zcgesv_c
      subroutine zcposv_c(uplo, n, nrhs, a_shape__, a, lda, b_shape__, b
     &, ldb, x_shape__, x, ldx, work_shape__, work, swork_shape__, swork
     &, rwork_shape__, rwork, iter, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(2) :: work_shape__
        complex*16, dimension(work_shape__(1), work_shape__(2)) :: work
        integer, dimension(1) :: swork_shape__
        complex(kind=kind((0.0,0.0))), dimension(swork_shape__(1)) :: sw
     &ork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: iter
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zcposv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zcposv(uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, 
     &rwork, iter, info)
        fw_iserr__ = 0
      end subroutine zcposv_c
      subroutine zdrscl_c(n, sa, sx_shape__, sx, incx, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0D0)) :: sa
        integer, dimension(1) :: sx_shape__
        complex*16, dimension(sx_shape__(1)) :: sx
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zdrscl
        fw_iserr__ = -1
        call zdrscl(n, sa, sx, incx)
        fw_iserr__ = 0
      end subroutine zdrscl_c
      subroutine zgbbrd_c(vect, m, n, ncc, kl, ku, ab_shape__, ab, ldab,
     & d_shape__, d, e_shape__, e, q_shape__, q, ldq, pt_shape__, pt, ld
     &pt, c_shape__, c, ldc, work_shape__, work, rwork_shape__, rwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        integer :: m
        integer :: n
        integer :: ncc
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: pt_shape__
        complex*16, dimension(pt_shape__(1), pt_shape__(2)) :: pt
        integer :: ldpt
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbbrd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldpt) .ne. (pt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("pt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbbrd(vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt,
     & ldpt, c, ldc, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgbbrd_c
      subroutine zgbcon_c(norm, n, kl, ku, ab_shape__, ab, ldab, ipiv_sh
     &ape__, ipiv, anorm, rcond, work_shape__, work, rwork_shape__, rwor
     &k, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbcon(norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work,
     & rwork, info)
        fw_iserr__ = 0
      end subroutine zgbcon_c
      subroutine zgbequ_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__,
     & r, c_shape__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbequ
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbequ(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, 
     &info)
        fw_iserr__ = 0
      end subroutine zgbequ_c
      subroutine zgbequb_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__
     &, r, c_shape__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbequb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbequb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax,
     & info)
        fw_iserr__ = 0
      end subroutine zgbequb_c
      subroutine zgbrfs_c(trans, n, kl, ku, nrhs, ab_shape__, ab, ldab, 
     &afb_shape__, afb, ldafb, ipiv_shape__, ipiv, b_shape__, b, ldb, x_
     &shape__, x, ldx, ferr_shape__, ferr, berr_shape__, berr, work_shap
     &e__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex*16, dimension(afb_shape__(1), afb_shape__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbrfs(trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, 
     &b, ldb, x, ldx, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgbrfs_c
      subroutine zgbrfsx_c(trans, equed, n, kl, ku, nrhs, ab_shape__, ab
     &, ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, r_shape__, r,
     & c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, berr_s
     &hape__, berr, n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, er
     &r_bnds_comp_shape__, err_bnds_comp, nparams, params_shape__, param
     &s, work_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex*16, dimension(afb_shape__(1), afb_shape__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbrfsx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbrfsx(trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb
     &, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_no
     &rm, err_bnds_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgbrfsx_c
      subroutine zgbsv_c(n, kl, ku, nrhs, ab_shape__, ab, ldab, ipiv_sha
     &pe__, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbsv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbsv(n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zgbsv_c
      subroutine zgbsvx_c(fact, trans, n, kl, ku, nrhs, ab_shape__, ab, 
     &ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, equed, r_shape_
     &_, r, c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, f
     &err_shape__, ferr, berr_shape__, berr, work_shape__, work, rwork_s
     &hape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex*16, dimension(afb_shape__(1), afb_shape__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbsvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbsvx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, 
     &ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork,
     & info)
        fw_iserr__ = 0
      end subroutine zgbsvx_c
      subroutine zgbsvxx_c(fact, trans, n, kl, ku, nrhs, ab_shape__, ab,
     & ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, equed, r_shape
     &__, r, c_shape__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, 
     &rpvgrw, berr_shape__, berr, n_err_bnds, err_bnds_norm_shape__, err
     &_bnds_norm, err_bnds_comp_shape__, err_bnds_comp, nparams, params_
     &shape__, params, work_shape__, work, rwork_shape__, rwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex*16, dimension(afb_shape__(1), afb_shape__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        real(kind=kind(0.0D0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbsvxx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbsvxx(fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb,
     & ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnd
     &s, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine zgbsvxx_c
      subroutine zgbtf2_c(m, n, kl, ku, ab_shape__, ab, ldab, ipiv_shape
     &__, ipiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbtf2
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbtf2(m, n, kl, ku, ab, ldab, ipiv, info)
        fw_iserr__ = 0
      end subroutine zgbtf2_c
      subroutine zgbtrf_c(m, n, kl, ku, ab_shape__, ab, ldab, ipiv_shape
     &__, ipiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbtrf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbtrf(m, n, kl, ku, ab, ldab, ipiv, info)
        fw_iserr__ = 0
      end subroutine zgbtrf_c
      subroutine zgbtrs_c(trans, n, kl, ku, nrhs, ab_shape__, ab, ldab, 
     &ipiv_shape__, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgbtrs(trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb, info
     &)
        fw_iserr__ = 0
      end subroutine zgbtrs_c
      subroutine zgebak_c(job, side, n, ilo, ihi, scale_shape__, scale, 
     &m, v_shape__, v, ldv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: side
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0D0)), dimension(scale_shape__(1)) :: scale
        integer :: m
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgebak
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgebak(job, side, n, ilo, ihi, scale, m, v, ldv, info)
        fw_iserr__ = 0
      end subroutine zgebak_c
      subroutine zgebal_c(job, n, a_shape__, a, lda, ilo, ihi, scale_sha
     &pe__, scale, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0D0)), dimension(scale_shape__(1)) :: scale
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgebal
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgebal(job, n, a, lda, ilo, ihi, scale, info)
        fw_iserr__ = 0
      end subroutine zgebal_c
      subroutine zgebd2_c(m, n, a_shape__, a, lda, d_shape__, d, e_shape
     &__, e, tauq_shape__, tauq, taup_shape__, taup, work_shape__, work,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        complex*16, dimension(tauq_shape__(1)) :: tauq
        integer, dimension(1) :: taup_shape__
        complex*16, dimension(taup_shape__(1)) :: taup
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgebd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgebd2(m, n, a, lda, d, e, tauq, taup, work, info)
        fw_iserr__ = 0
      end subroutine zgebd2_c
      subroutine zgebrd_c(m, n, a_shape__, a, lda, d_shape__, d, e_shape
     &__, e, tauq_shape__, tauq, taup_shape__, taup, work_shape__, work,
     & lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        complex*16, dimension(tauq_shape__(1)) :: tauq
        integer, dimension(1) :: taup_shape__
        complex*16, dimension(taup_shape__(1)) :: taup
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgebrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgebrd(m, n, a, lda, d, e, tauq, taup, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zgebrd_c
      subroutine zgecon_c(norm, n, a_shape__, a, lda, anorm, rcond, work
     &_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgecon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgecon(norm, n, a, lda, anorm, rcond, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgecon_c
      subroutine zgeequ_c(m, n, a_shape__, a, lda, r_shape__, r, c_shape
     &__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeequ
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeequ(m, n, a, lda, r, c, rowcnd, colcnd, amax, info)
        fw_iserr__ = 0
      end subroutine zgeequ_c
      subroutine zgeequb_c(m, n, a_shape__, a, lda, r_shape__, r, c_shap
     &e__, c, rowcnd, colcnd, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeequb(m, n, a, lda, r, c, rowcnd, colcnd, amax, info)
        fw_iserr__ = 0
      end subroutine zgeequb_c
      subroutine zgees_c(jobvs, sort, select, n, a_shape__, a, lda, sdim
     &, w_shape__, w, vs_shape__, vs, ldvs, work_shape__, work, lwork, r
     &work_shape__, rwork, bwork_shape__, bwork, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvs
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: sdim
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer, dimension(2) :: vs_shape__
        complex*16, dimension(vs_shape__(1), vs_shape__(2)) :: vs
        integer :: ldvs
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgees
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvs) .ne. (vs_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vs                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgees(jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, wo
     &rk, lwork, rwork, bwork, info)
        fw_iserr__ = 0
      end subroutine zgees_c
      subroutine zgeesx_c(jobvs, sort, select, sense, n, a_shape__, a, l
     &da, sdim, w_shape__, w, vs_shape__, vs, ldvs, rconde, rcondv, work
     &_shape__, work, lwork, rwork_shape__, rwork, bwork_shape__, bwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvs
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: select
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: sdim
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer, dimension(2) :: vs_shape__
        complex*16, dimension(vs_shape__(1), vs_shape__(2)) :: vs
        integer :: ldvs
        real(kind=kind(0.0D0)) :: rconde
        real(kind=kind(0.0D0)) :: rcondv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeesx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvs) .ne. (vs_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vs                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeesx(jobvs, sort, select, sense, n, a, lda, sdim, w, vs, 
     &ldvs, rconde, rcondv, work, lwork, rwork, bwork, info)
        fw_iserr__ = 0
      end subroutine zgeesx_c
      subroutine zgeev_c(jobvl, jobvr, n, a_shape__, a, lda, w_shape__, 
     &w, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, work_shape__, work,
     & lwork, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer, dimension(2) :: vl_shape__
        complex*16, dimension(vl_shape__(1), vl_shape__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex*16, dimension(vr_shape__(1), vr_shape__(2)) :: vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeev(jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work,
     & lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zgeev_c
      subroutine zgeevx_c(balanc, jobvl, jobvr, sense, n, a_shape__, a, 
     &lda, w_shape__, w, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, ilo
     &, ihi, scale_shape__, scale, abnrm, rconde_shape__, rconde, rcondv
     &_shape__, rcondv, work_shape__, work, lwork, rwork_shape__, rwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: balanc
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer, dimension(2) :: vl_shape__
        complex*16, dimension(vl_shape__(1), vl_shape__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex*16, dimension(vr_shape__(1), vr_shape__(2)) :: vr
        integer :: ldvr
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: scale_shape__
        real(kind=kind(0.0D0)), dimension(scale_shape__(1)) :: scale
        real(kind=kind(0.0D0)) :: abnrm
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0D0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0D0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeevx(balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl,
     & vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rw
     &ork, info)
        fw_iserr__ = 0
      end subroutine zgeevx_c
      subroutine zgegs_c(jobvsl, jobvsr, n, a_shape__, a, lda, b_shape__
     &, b, ldb, alpha_shape__, alpha, beta_shape__, beta, vsl_shape__, v
     &sl, ldvsl, vsr_shape__, vsr, ldvsr, work_shape__, work, lwork, rwo
     &rk_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        complex*16, dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        complex*16, dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vsl_shape__
        complex*16, dimension(vsl_shape__(1), vsl_shape__(2)) :: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        complex*16, dimension(vsr_shape__(1), vsr_shape__(2)) :: vsr
        integer :: ldvsr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgegs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgegs(jobvsl, jobvsr, n, a, lda, b, ldb, alpha, beta, vsl, 
     &ldvsl, vsr, ldvsr, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zgegs_c
      subroutine zgegv_c(jobvl, jobvr, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, alpha_shape__, alpha, beta_shape__, beta, vl_shape__, vl, 
     &ldvl, vr_shape__, vr, ldvr, work_shape__, work, lwork, rwork_shape
     &__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        complex*16, dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        complex*16, dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vl_shape__
        complex*16, dimension(vl_shape__(1), vl_shape__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex*16, dimension(vr_shape__(1), vr_shape__(2)) :: vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgegv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgegv(jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldv
     &l, vr, ldvr, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zgegv_c
      subroutine zgehd2_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgehd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgehd2(n, ilo, ihi, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine zgehd2_c
      subroutine zgehrd_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgehrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgehrd(n, ilo, ihi, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zgehrd_c
      subroutine zgelq2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgelq2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgelq2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine zgelq2_c
      subroutine zgelqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgelqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgelqf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zgelqf_c
      subroutine zgels_c(trans, m, n, nrhs, a_shape__, a, lda, b_shape__
     &, b, ldb, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgels
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgels(trans, m, n, nrhs, a, lda, b, ldb, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zgels_c
      subroutine zgelsd_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, s_shape__, s, rcond, rank, work_shape__, work, lwork, rwork_sh
     &ape__, rwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgelsd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgelsd(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lw
     &ork, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine zgelsd_c
      subroutine zgelss_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, s_shape__, s, rcond, rank, work_shape__, work, lwork, rwork_sh
     &ape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgelss
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgelss(m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lw
     &ork, rwork, info)
        fw_iserr__ = 0
      end subroutine zgelss_c
      subroutine zgelsx_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, jpvt_shape__, jpvt, rcond, rank, work_shape__, work, rwork_sha
     &pe__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        real(kind=kind(0.0D0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgelsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgelsx(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work,
     & rwork, info)
        fw_iserr__ = 0
      end subroutine zgelsx_c
      subroutine zgelsy_c(m, n, nrhs, a_shape__, a, lda, b_shape__, b, l
     &db, jpvt_shape__, jpvt, rcond, rank, work_shape__, work, lwork, rw
     &ork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        real(kind=kind(0.0D0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgelsy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgelsy(m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work,
     & lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zgelsy_c
      subroutine zgeql2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeql2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeql2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine zgeql2_c
      subroutine zgeqlf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeqlf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeqlf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zgeqlf_c
      subroutine zgeqp3_c(m, n, a_shape__, a, lda, jpvt_shape__, jpvt, t
     &au_shape__, tau, work_shape__, work, lwork, rwork_shape__, rwork, 
     &info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeqp3
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeqp3(m, n, a, lda, jpvt, tau, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zgeqp3_c
      subroutine zgeqpf_c(m, n, a_shape__, a, lda, jpvt_shape__, jpvt, t
     &au_shape__, tau, work_shape__, work, rwork_shape__, rwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeqpf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeqpf(m, n, a, lda, jpvt, tau, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgeqpf_c
      subroutine zgeqr2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeqr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeqr2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine zgeqr2_c
      subroutine zgeqr2p_c(m, n, a_shape__, a, lda, tau_shape__, tau, wo
     &rk_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeqr2p
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeqr2p(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine zgeqr2p_c
      subroutine zgeqrf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeqrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeqrf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zgeqrf_c
      subroutine zgeqrfp_c(m, n, a_shape__, a, lda, tau_shape__, tau, wo
     &rk_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgeqrfp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgeqrfp(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zgeqrfp_c
      subroutine zgerfs_c(trans, n, nrhs, a_shape__, a, lda, af_shape__,
     & af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ld
     &x, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, rwo
     &rk_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgerfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgerfs(trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, l
     &dx, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgerfs_c
      subroutine zgerfsx_c(trans, equed, n, nrhs, a_shape__, a, lda, af_
     &shape__, af, ldaf, ipiv_shape__, ipiv, r_shape__, r, c_shape__, c,
     & b_shape__, b, ldb, x_shape__, x, ldx, rcond, berr_shape__, berr, 
     &n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_sh
     &ape__, err_bnds_comp, nparams, params_shape__, params, work_shape_
     &_, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgerfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgerfsx(trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c
     &, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds
     &_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgerfsx_c
      subroutine zgerq2_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgerq2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgerq2(m, n, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine zgerq2_c
      subroutine zgerqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgerqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgerqf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zgerqf_c
      subroutine zgesc2_c(n, a_shape__, a, lda, rhs_shape__, rhs, ipiv_s
     &hape__, ipiv, jpiv_shape__, jpiv, scale, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: rhs_shape__
        complex*16, dimension(rhs_shape__(1)) :: rhs
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        real(kind=kind(0.0D0)) :: scale
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgesc2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgesc2(n, a, lda, rhs, ipiv, jpiv, scale)
        fw_iserr__ = 0
      end subroutine zgesc2_c
      subroutine zgesdd_c(jobz, m, n, a_shape__, a, lda, s_shape__, s, u
     &_shape__, u, ldu, vt_shape__, vt, ldvt, work_shape__, work, lwork,
     & rwork_shape__, rwork, iwork_shape__, iwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: u_shape__
        complex*16, dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        complex*16, dimension(vt_shape__(1), vt_shape__(2)) :: vt
        integer :: ldvt
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgesdd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgesdd(jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork
     &, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine zgesdd_c
      subroutine zgesv_c(n, nrhs, a_shape__, a, lda, ipiv_shape__, ipiv,
     & b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgesv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgesv(n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zgesv_c
      subroutine zgesvd_c(jobu, jobvt, m, n, a_shape__, a, lda, s_shape_
     &_, s, u_shape__, u, ldu, vt_shape__, vt, ldvt, work_shape__, work,
     & lwork, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobvt
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: u_shape__
        complex*16, dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        complex*16, dimension(vt_shape__(1), vt_shape__(2)) :: vt
        integer :: ldvt
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgesvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvt) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgesvd(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work
     &, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zgesvd_c
      subroutine zgesvx_c(fact, trans, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, ipiv_shape__, ipiv, equed, r_shape__, r, c_shape_
     &_, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, ferr_shape__, f
     &err, berr_shape__, berr, work_shape__, work, rwork_shape__, rwork,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgesvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgesvx(fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed,
     & r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgesvx_c
      subroutine zgesvxx_c(fact, trans, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, ipiv_shape__, ipiv, equed, r_shape__, r, c_shape
     &__, c, b_shape__, b, ldb, x_shape__, x, ldx, rcond, rpvgrw, berr_s
     &hape__, berr, n_err_bnds, err_bnds_norm_shape__, err_bnds_norm, er
     &r_bnds_comp_shape__, err_bnds_comp, nparams, params_shape__, param
     &s, work_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        real(kind=kind(0.0D0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgesvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgesvxx(fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed
     &, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_
     &norm, err_bnds_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgesvxx_c
      subroutine zgetc2_c(n, a_shape__, a, lda, ipiv_shape__, ipiv, jpiv
     &_shape__, jpiv, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgetc2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgetc2(n, a, lda, ipiv, jpiv, info)
        fw_iserr__ = 0
      end subroutine zgetc2_c
      subroutine zgetf2_c(m, n, a_shape__, a, lda, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgetf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgetf2(m, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine zgetf2_c
      subroutine zgetrf_c(m, n, a_shape__, a, lda, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgetrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgetrf(m, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine zgetrf_c
      subroutine zgetri_c(n, a_shape__, a, lda, ipiv_shape__, ipiv, work
     &_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgetri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgetri(n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zgetri_c
      subroutine zgetrs_c(trans, n, nrhs, a_shape__, a, lda, ipiv_shape_
     &_, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgetrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgetrs(trans, n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zgetrs_c
      subroutine zggbak_c(job, side, n, ilo, ihi, lscale_shape__, lscale
     &, rscale_shape__, rscale, m, v_shape__, v, ldv, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: side
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0D0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0D0)), dimension(rscale_shape__(1)) :: rscale
        integer :: m
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zggbak
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zggbak(job, side, n, ilo, ihi, lscale, rscale, m, v, ldv, i
     &nfo)
        fw_iserr__ = 0
      end subroutine zggbak_c
      subroutine zggbal_c(job, n, a_shape__, a, lda, b_shape__, b, ldb, 
     &ilo, ihi, lscale_shape__, lscale, rscale_shape__, rscale, work_sha
     &pe__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0D0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0D0)), dimension(rscale_shape__(1)) :: rscale
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zggbal
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zggbal(job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, wo
     &rk, info)
        fw_iserr__ = 0
      end subroutine zggbal_c
      subroutine zgges_c(jobvsl, jobvsr, sort, selctg, n, a_shape__, a, 
     &lda, b_shape__, b, ldb, sdim, alpha_shape__, alpha, beta_shape__, 
     &beta, vsl_shape__, vsl, ldvsl, vsr_shape__, vsr, ldvsr, work_shape
     &__, work, lwork, rwork_shape__, rwork, bwork_shape__, bwork, info,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: selctg
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: sdim
        integer, dimension(1) :: alpha_shape__
        complex*16, dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        complex*16, dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vsl_shape__
        complex*16, dimension(vsl_shape__(1), vsl_shape__(2)) :: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        complex*16, dimension(vsr_shape__(1), vsr_shape__(2)) :: vsr
        integer :: ldvsr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgges
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgges(jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim
     &, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork, 
     &info)
        fw_iserr__ = 0
      end subroutine zgges_c
      subroutine zggesx_c(jobvsl, jobvsr, sort, selctg, sense, n, a_shap
     &e__, a, lda, b_shape__, b, ldb, sdim, alpha_shape__, alpha, beta_s
     &hape__, beta, vsl_shape__, vsl, ldvsl, vsr_shape__, vsr, ldvsr, rc
     &onde_shape__, rconde, rcondv_shape__, rcondv, work_shape__, work, 
     &lwork, rwork_shape__, rwork, iwork_shape__, iwork, liwork, bwork_s
     &hape__, bwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvsl
        character(len=1, kind=kind('a')) :: jobvsr
        character(len=1, kind=kind('a')) :: sort
        integer(kind=kind(0)) :: selctg
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: sdim
        integer, dimension(1) :: alpha_shape__
        complex*16, dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        complex*16, dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vsl_shape__
        complex*16, dimension(vsl_shape__(1), vsl_shape__(2)) :: vsl
        integer :: ldvsl
        integer, dimension(2) :: vsr_shape__
        complex*16, dimension(vsr_shape__(1), vsr_shape__(2)) :: vsr
        integer :: ldvsr
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0D0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0D0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zggesx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsl) .ne. (vsl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsl                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvsr) .ne. (vsr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vsr                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (rconde_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("rconde                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .lt. 0 .or. (2) .gt. (rcondv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("rcondv                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zggesx(jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, l
     &db, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, wor
     &k, lwork, rwork, iwork, liwork, bwork, info)
        fw_iserr__ = 0
      end subroutine zggesx_c
      subroutine zggev_c(jobvl, jobvr, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, alpha_shape__, alpha, beta_shape__, beta, vl_shape__, vl, 
     &ldvl, vr_shape__, vr, ldvr, work_shape__, work, lwork, rwork_shape
     &__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        complex*16, dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        complex*16, dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vl_shape__
        complex*16, dimension(vl_shape__(1), vl_shape__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex*16, dimension(vr_shape__(1), vr_shape__(2)) :: vr
        integer :: ldvr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zggev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zggev(jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldv
     &l, vr, ldvr, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zggev_c
      subroutine zggevx_c(balanc, jobvl, jobvr, sense, n, a_shape__, a, 
     &lda, b_shape__, b, ldb, alpha_shape__, alpha, beta_shape__, beta, 
     &vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, ilo, ihi, lscale_shape
     &__, lscale, rscale_shape__, rscale, abnrm, bbnrm, rconde_shape__, 
     &rconde, rcondv_shape__, rcondv, work_shape__, work, lwork, rwork_s
     &hape__, rwork, iwork_shape__, iwork, bwork_shape__, bwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: balanc
        character(len=1, kind=kind('a')) :: jobvl
        character(len=1, kind=kind('a')) :: jobvr
        character(len=1, kind=kind('a')) :: sense
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        complex*16, dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        complex*16, dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: vl_shape__
        complex*16, dimension(vl_shape__(1), vl_shape__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex*16, dimension(vr_shape__(1), vr_shape__(2)) :: vr
        integer :: ldvr
        integer :: ilo
        integer :: ihi
        integer, dimension(1) :: lscale_shape__
        real(kind=kind(0.0D0)), dimension(lscale_shape__(1)) :: lscale
        integer, dimension(1) :: rscale_shape__
        real(kind=kind(0.0D0)), dimension(rscale_shape__(1)) :: rscale
        real(kind=kind(0.0D0)) :: abnrm
        real(kind=kind(0.0D0)) :: bbnrm
        integer, dimension(1) :: rconde_shape__
        real(kind=kind(0.0D0)), dimension(rconde_shape__(1)) :: rconde
        integer, dimension(1) :: rcondv_shape__
        real(kind=kind(0.0D0)), dimension(rcondv_shape__(1)) :: rcondv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: bwork_shape__
        integer(kind=kind(0)), dimension(bwork_shape__(1)) :: bwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zggevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zggevx(balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alph
     &a, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnr
     &m, rconde, rcondv, work, lwork, rwork, iwork, bwork, info)
        fw_iserr__ = 0
      end subroutine zggevx_c
      subroutine zggglm_c(n, m, p, a_shape__, a, lda, b_shape__, b, ldb,
     & d_shape__, d, x_shape__, x, y_shape__, y, work_shape__, work, lwo
     &rk, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: m
        integer :: p
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        complex*16, dimension(y_shape__(1)) :: y
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zggglm
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zggglm(n, m, p, a, lda, b, ldb, d, x, y, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zggglm_c
      subroutine zgghrd_c(compq, compz, n, ilo, ihi, a_shape__, a, lda, 
     &b_shape__, b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compq
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgghrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgghrd(compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z
     &, ldz, info)
        fw_iserr__ = 0
      end subroutine zgghrd_c
      subroutine zgglse_c(m, n, p, a_shape__, a, lda, b_shape__, b, ldb,
     & c_shape__, c, d_shape__, d, x_shape__, x, work_shape__, work, lwo
     &rk, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: p
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: c_shape__
        complex*16, dimension(c_shape__(1)) :: c
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgglse
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgglse(m, n, p, a, lda, b, ldb, c, d, x, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zgglse_c
      subroutine zggqrf_c(n, m, p, a_shape__, a, lda, taua_shape__, taua
     &, b_shape__, b, ldb, taub_shape__, taub, work_shape__, work, lwork
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: m
        integer :: p
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: taua_shape__
        complex*16, dimension(taua_shape__(1)) :: taua
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: taub_shape__
        complex*16, dimension(taub_shape__(1)) :: taub
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zggqrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zggqrf(n, m, p, a, lda, taua, b, ldb, taub, work, lwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine zggqrf_c
      subroutine zggrqf_c(m, p, n, a_shape__, a, lda, taua_shape__, taua
     &, b_shape__, b, ldb, taub_shape__, taub, work_shape__, work, lwork
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: p
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: taua_shape__
        complex*16, dimension(taua_shape__(1)) :: taua
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: taub_shape__
        complex*16, dimension(taub_shape__(1)) :: taub
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zggrqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zggrqf(m, p, n, a, lda, taua, b, ldb, taub, work, lwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine zggrqf_c
      subroutine zggsvd_c(jobu, jobv, jobq, m, n, p, k, l, a_shape__, a,
     & lda, b_shape__, b, ldb, alpha_shape__, alpha, beta_shape__, beta,
     & u_shape__, u, ldu, v_shape__, v, ldv, q_shape__, q, ldq, work_sha
     &pe__, work, rwork_shape__, rwork, iwork_shape__, iwork, info, fw_i
     &serr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: n
        integer :: p
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        real(kind=kind(0.0D0)), dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: u_shape__
        complex*16, dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zggsvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zggsvd(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alp
     &ha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine zggsvd_c
      subroutine zggsvp_c(jobu, jobv, jobq, m, p, n, a_shape__, a, lda, 
     &b_shape__, b, ldb, tola, tolb, k, l, u_shape__, u, ldu, v_shape__,
     & v, ldv, q_shape__, q, ldq, iwork_shape__, iwork, rwork_shape__, r
     &work, tau_shape__, tau, work_shape__, work, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: p
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0D0)) :: tola
        real(kind=kind(0.0D0)) :: tolb
        integer :: k
        integer :: l
        integer, dimension(2) :: u_shape__
        complex*16, dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zggsvp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zggsvp(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tol
     &b, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info)
        fw_iserr__ = 0
      end subroutine zggsvp_c
      subroutine zgtcon_c(norm, n, dl_shape__, dl, d_shape__, d, du_shap
     &e__, du, du2_shape__, du2, ipiv_shape__, ipiv, anorm, rcond, work_
     &shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: dl_shape__
        complex*16, dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex*16, dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        complex*16, dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgtcon
        fw_iserr__ = -1
        call zgtcon(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, i
     &nfo)
        fw_iserr__ = 0
      end subroutine zgtcon_c
      subroutine zgtrfs_c(trans, n, nrhs, dl_shape__, dl, d_shape__, d, 
     &du_shape__, du, dlf_shape__, dlf, df_shape__, df, duf_shape__, duf
     &, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape
     &__, x, ldx, ferr_shape__, ferr, berr_shape__, berr, work_shape__, 
     &work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        complex*16, dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex*16, dimension(du_shape__(1)) :: du
        integer, dimension(1) :: dlf_shape__
        complex*16, dimension(dlf_shape__(1)) :: dlf
        integer, dimension(1) :: df_shape__
        complex*16, dimension(df_shape__(1)) :: df
        integer, dimension(1) :: duf_shape__
        complex*16, dimension(duf_shape__(1)) :: duf
        integer, dimension(1) :: du2_shape__
        complex*16, dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgtrfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgtrfs(trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, 
     &b, ldb, x, ldx, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgtrfs_c
      subroutine zgtsv_c(n, nrhs, dl_shape__, dl, d_shape__, d, du_shape
     &__, du, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        complex*16, dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex*16, dimension(du_shape__(1)) :: du
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgtsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgtsv(n, nrhs, dl, d, du, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zgtsv_c
      subroutine zgtsvx_c(fact, trans, n, nrhs, dl_shape__, dl, d_shape_
     &_, d, du_shape__, du, dlf_shape__, dlf, df_shape__, df, duf_shape_
     &_, duf, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b, ldb, x
     &_shape__, x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, w
     &ork_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        complex*16, dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex*16, dimension(du_shape__(1)) :: du
        integer, dimension(1) :: dlf_shape__
        complex*16, dimension(dlf_shape__(1)) :: dlf
        integer, dimension(1) :: df_shape__
        complex*16, dimension(df_shape__(1)) :: df
        integer, dimension(1) :: duf_shape__
        complex*16, dimension(duf_shape__(1)) :: duf
        integer, dimension(1) :: du2_shape__
        complex*16, dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgtsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgtsvx(fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, 
     &ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zgtsvx_c
      subroutine zgttrf_c(n, dl_shape__, dl, d_shape__, d, du_shape__, d
     &u, du2_shape__, du2, ipiv_shape__, ipiv, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: dl_shape__
        complex*16, dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex*16, dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        complex*16, dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgttrf
        fw_iserr__ = -1
        call zgttrf(n, dl, d, du, du2, ipiv, info)
        fw_iserr__ = 0
      end subroutine zgttrf_c
      subroutine zgttrs_c(trans, n, nrhs, dl_shape__, dl, d_shape__, d, 
     &du_shape__, du, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, b
     &, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        complex*16, dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex*16, dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        complex*16, dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgttrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zgttrs_c
      subroutine zgtts2_c(itrans, n, nrhs, dl_shape__, dl, d_shape__, d,
     & du_shape__, du, du2_shape__, du2, ipiv_shape__, ipiv, b_shape__, 
     &b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itrans
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: dl_shape__
        complex*16, dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex*16, dimension(du_shape__(1)) :: du
        integer, dimension(1) :: du2_shape__
        complex*16, dimension(du2_shape__(1)) :: du2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zgtts2
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zgtts2(itrans, n, nrhs, dl, d, du, du2, ipiv, b, ldb)
        fw_iserr__ = 0
      end subroutine zgtts2_c
      subroutine zhbev_c(jobz, uplo, n, kd, ab_shape__, ab, ldab, w_shap
     &e__, w, z_shape__, z, ldz, work_shape__, work, rwork_shape__, rwor
     &k, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhbev
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhbev(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork, 
     &info)
        fw_iserr__ = 0
      end subroutine zhbev_c
      subroutine zhbevd_c(jobz, uplo, n, kd, ab_shape__, ab, ldab, w_sha
     &pe__, w, z_shape__, z, ldz, work_shape__, work, lwork, rwork_shape
     &__, rwork, lrwork, iwork_shape__, iwork, liwork, info, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhbevd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhbevd(jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork,
     & rwork, lrwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine zhbevd_c
      subroutine zhbevx_c(jobz, range, uplo, n, kd, ab_shape__, ab, ldab
     &, q_shape__, q, ldq, vl, vu, il, iu, abstol, m, w_shape__, w, z_sh
     &ape__, z, ldz, work_shape__, work, rwork_shape__, rwork, iwork_sha
     &pe__, iwork, ifail_shape__, ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhbevx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhbevx(jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, 
     &il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine zhbevx_c
      subroutine zhbgst_c(vect, uplo, n, ka, kb, ab_shape__, ab, ldab, b
     &b_shape__, bb, ldbb, x_shape__, x, ldx, work_shape__, work, rwork_
     &shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        complex*16, dimension(bb_shape__(1), bb_shape__(2)) :: bb
        integer :: ldbb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhbgst
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhbgst(vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, w
     &ork, rwork, info)
        fw_iserr__ = 0
      end subroutine zhbgst_c
      subroutine zhbgv_c(jobz, uplo, n, ka, kb, ab_shape__, ab, ldab, bb
     &_shape__, bb, ldbb, w_shape__, w, z_shape__, z, ldz, work_shape__,
     & work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        complex*16, dimension(bb_shape__(1), bb_shape__(2)) :: bb
        integer :: ldbb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhbgv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhbgv(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz,
     & work, rwork, info)
        fw_iserr__ = 0
      end subroutine zhbgv_c
      subroutine zhbgvd_c(jobz, uplo, n, ka, kb, ab_shape__, ab, ldab, b
     &b_shape__, bb, ldbb, w_shape__, w, z_shape__, z, ldz, work_shape__
     &, work, lwork, rwork_shape__, rwork, lrwork, iwork_shape__, iwork,
     & liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        complex*16, dimension(bb_shape__(1), bb_shape__(2)) :: bb
        integer :: ldbb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhbgvd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhbgvd(jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz
     &, work, lwork, rwork, lrwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine zhbgvd_c
      subroutine zhbgvx_c(jobz, range, uplo, n, ka, kb, ab_shape__, ab, 
     &ldab, bb_shape__, bb, ldbb, q_shape__, q, ldq, vl, vu, il, iu, abs
     &tol, m, w_shape__, w, z_shape__, z, ldz, work_shape__, work, rwork
     &_shape__, rwork, iwork_shape__, iwork, ifail_shape__, ifail, info,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: ka
        integer :: kb
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: bb_shape__
        complex*16, dimension(bb_shape__(1), bb_shape__(2)) :: bb
        integer :: ldbb
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhbgvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbb) .ne. (bb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bb                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhbgvx(jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q,
     & ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, if
     &ail, info)
        fw_iserr__ = 0
      end subroutine zhbgvx_c
      subroutine zhbtrd_c(vect, uplo, n, kd, ab_shape__, ab, ldab, d_sha
     &pe__, d, e_shape__, e, q_shape__, q, ldq, work_shape__, work, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhbtrd
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhbtrd(vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine zhbtrd_c
      subroutine zhecon_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, anorm, rcond, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhecon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhecon(uplo, n, a, lda, ipiv, anorm, rcond, work, info)
        fw_iserr__ = 0
      end subroutine zhecon_c
      subroutine zheequb_c(uplo, n, a_shape__, a, lda, s_shape__, s, sco
     &nd, amax, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zheequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zheequb(uplo, n, a, lda, s, scond, amax, work, info)
        fw_iserr__ = 0
      end subroutine zheequb_c
      subroutine zheev_c(jobz, uplo, n, a_shape__, a, lda, w_shape__, w,
     & work_shape__, work, lwork, rwork_shape__, rwork, info, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zheev
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zheev(jobz, uplo, n, a, lda, w, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zheev_c
      subroutine zheevd_c(jobz, uplo, n, a_shape__, a, lda, w_shape__, w
     &, work_shape__, work, lwork, rwork_shape__, rwork, lrwork, iwork_s
     &hape__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zheevd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zheevd(jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork
     &, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine zheevd_c
      subroutine zheevr_c(jobz, range, uplo, n, a_shape__, a, lda, vl, v
     &u, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, isuppz_shap
     &e__, isuppz, work_shape__, work, lwork, rwork_shape__, rwork, lrwo
     &rk, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zheevr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zheevr(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol
     &, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork,
     & info)
        fw_iserr__ = 0
      end subroutine zheevr_c
      subroutine zheevx_c(jobz, range, uplo, n, a_shape__, a, lda, vl, v
     &u, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, work_shape_
     &_, work, lwork, rwork_shape__, rwork, iwork_shape__, iwork, ifail_
     &shape__, ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zheevx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zheevx(jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol
     &, m, w, z, ldz, work, lwork, rwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine zheevx_c
      subroutine zhegs2_c(itype, uplo, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhegs2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhegs2(itype, uplo, n, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zhegs2_c
      subroutine zhegst_c(itype, uplo, n, a_shape__, a, lda, b_shape__, 
     &b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhegst
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhegst(itype, uplo, n, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zhegst_c
      subroutine zhegv_c(itype, jobz, uplo, n, a_shape__, a, lda, b_shap
     &e__, b, ldb, w_shape__, w, work_shape__, work, lwork, rwork_shape_
     &_, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhegv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhegv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork,
     & rwork, info)
        fw_iserr__ = 0
      end subroutine zhegv_c
      subroutine zhegvd_c(itype, jobz, uplo, n, a_shape__, a, lda, b_sha
     &pe__, b, ldb, w_shape__, w, work_shape__, work, lwork, rwork_shape
     &__, rwork, lrwork, iwork_shape__, iwork, liwork, info, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhegvd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhegvd(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork
     &, rwork, lrwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine zhegvd_c
      subroutine zhegvx_c(itype, jobz, range, uplo, n, a_shape__, a, lda
     &, b_shape__, b, ldb, vl, vu, il, iu, abstol, m, w_shape__, w, z_sh
     &ape__, z, ldz, work_shape__, work, lwork, rwork_shape__, rwork, iw
     &ork_shape__, iwork, ifail_shape__, ifail, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhegvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhegvx(itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu,
     & il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail, i
     &nfo)
        fw_iserr__ = 0
      end subroutine zhegvx_c
      subroutine zherfs_c(uplo, n, nrhs, a_shape__, a, lda, af_shape__, 
     &af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx
     &, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, rwor
     &k_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zherfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zherfs(uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ld
     &x, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zherfs_c
      subroutine zherfsx_c(uplo, equed, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, ipiv_shape__, ipiv, s_shape__, s, b_shape__, b, 
     &ldb, x_shape__, x, ldx, rcond, berr_shape__, berr, n_err_bnds, err
     &_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bnds
     &_comp, nparams, params_shape__, params, work_shape__, work, rwork_
     &shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zherfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zherfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b,
     & ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_com
     &p, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zherfsx_c
      subroutine zhesv_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__,
     & ipiv, b_shape__, b, ldb, work_shape__, work, lwork, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhesv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhesv(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine zhesv_c
      subroutine zhesvx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sha
     &pe__, af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, 
     &x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape_
     &_, work, lwork, rwork_shape__, rwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhesvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhesvx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     & x, ldx, rcond, ferr, berr, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zhesvx_c
      subroutine zhesvxx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, ipiv_shape__, ipiv, equed, s_shape__, s, b_shape_
     &_, b, ldb, x_shape__, x, ldx, rcond, rpvgrw, berr_shape__, berr, n
     &_err_bnds, err_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_sha
     &pe__, err_bnds_comp, nparams, params_shape__, params, work_shape__
     &, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        real(kind=kind(0.0D0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhesvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhesvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed,
     & s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm
     &, err_bnds_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zhesvxx_c
      subroutine zhetd2_c(uplo, n, a_shape__, a, lda, d_shape__, d, e_sh
     &ape__, e, tau_shape__, tau, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhetd2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhetd2(uplo, n, a, lda, d, e, tau, info)
        fw_iserr__ = 0
      end subroutine zhetd2_c
      subroutine zhetf2_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhetf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhetf2(uplo, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine zhetf2_c
      subroutine zhetrd_c(uplo, n, a_shape__, a, lda, d_shape__, d, e_sh
     &ape__, e, tau_shape__, tau, work_shape__, work, lwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhetrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhetrd(uplo, n, a, lda, d, e, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zhetrd_c
      subroutine zhetrf_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhetrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhetrf(uplo, n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zhetrf_c
      subroutine zhetri_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhetri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhetri(uplo, n, a, lda, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine zhetri_c
      subroutine zhetrs_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__
     &, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhetrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhetrs(uplo, n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zhetrs_c
      subroutine zhetrs2_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape_
     &_, ipiv, b_shape__, b, ldb, work_shape__, work, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(a_shape__(1), a_sha
     &pe__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(b_shape__(1), b_sha
     &pe__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(work_shape__(1)) ::
     & work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhetrs2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhetrs2(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, info)
        fw_iserr__ = 0
      end subroutine zhetrs2_c
      subroutine zhfrk_c(transr, uplo, trans, n, k, alpha, a_shape__, a,
     & lda, beta, c_shape__, c, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: k
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: c_shape__
        complex*16, dimension(c_shape__(1)) :: c
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhfrk
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhfrk(transr, uplo, trans, n, k, alpha, a, lda, beta, c)
        fw_iserr__ = 0
      end subroutine zhfrk_c
      subroutine zhgeqz_c(job, compq, compz, n, ilo, ihi, h_shape__, h, 
     &ldh, t_shape__, t, ldt, alpha_shape__, alpha, beta_shape__, beta, 
     &q_shape__, q, ldq, z_shape__, z, ldz, work_shape__, work, lwork, r
     &work_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compq
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(1) :: alpha_shape__
        complex*16, dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        complex*16, dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhgeqz
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhgeqz(job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alph
     &a, beta, q, ldq, z, ldz, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zhgeqz_c
      subroutine zhpcon_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, a
     &norm, rcond, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhpcon
        fw_iserr__ = -1
        call zhpcon(uplo, n, ap, ipiv, anorm, rcond, work, info)
        fw_iserr__ = 0
      end subroutine zhpcon_c
      subroutine zhpev_c(jobz, uplo, n, ap_shape__, ap, w_shape__, w, z_
     &shape__, z, ldz, work_shape__, work, rwork_shape__, rwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhpev
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhpev(jobz, uplo, n, ap, w, z, ldz, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zhpev_c
      subroutine zhpevd_c(jobz, uplo, n, ap_shape__, ap, w_shape__, w, z
     &_shape__, z, ldz, work_shape__, work, lwork, rwork_shape__, rwork,
     & lrwork, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhpevd
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhpevd(jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lr
     &work, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine zhpevd_c
      subroutine zhpevx_c(jobz, range, uplo, n, ap_shape__, ap, vl, vu, 
     &il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, work_shape__, 
     &work, rwork_shape__, rwork, iwork_shape__, iwork, ifail_shape__, i
     &fail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhpevx
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhpevx(jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m,
     & w, z, ldz, work, rwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine zhpevx_c
      subroutine zhpgst_c(itype, uplo, n, ap_shape__, ap, bp_shape__, bp
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        complex*16, dimension(bp_shape__(1)) :: bp
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhpgst
        fw_iserr__ = -1
        call zhpgst(itype, uplo, n, ap, bp, info)
        fw_iserr__ = 0
      end subroutine zhpgst_c
      subroutine zhpgv_c(itype, jobz, uplo, n, ap_shape__, ap, bp_shape_
     &_, bp, w_shape__, w, z_shape__, z, ldz, work_shape__, work, rwork_
     &shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        complex*16, dimension(bp_shape__(1)) :: bp
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhpgv
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhpgv(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork,
     & info)
        fw_iserr__ = 0
      end subroutine zhpgv_c
      subroutine zhpgvd_c(itype, jobz, uplo, n, ap_shape__, ap, bp_shape
     &__, bp, w_shape__, w, z_shape__, z, ldz, work_shape__, work, lwork
     &, rwork_shape__, rwork, lrwork, iwork_shape__, iwork, liwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        complex*16, dimension(bp_shape__(1)) :: bp
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhpgvd
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhpgvd(itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork
     &, rwork, lrwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine zhpgvd_c
      subroutine zhpgvx_c(itype, jobz, range, uplo, n, ap_shape__, ap, b
     &p_shape__, bp, vl, vu, il, iu, abstol, m, w_shape__, w, z_shape__,
     & z, ldz, work_shape__, work, rwork_shape__, rwork, iwork_shape__, 
     &iwork, ifail_shape__, ifail, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: itype
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: bp_shape__
        complex*16, dimension(bp_shape__(1)) :: bp
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhpgvx
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhpgvx(itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu,
     & abstol, m, w, z, ldz, work, rwork, iwork, ifail, info)
        fw_iserr__ = 0
      end subroutine zhpgvx_c
      subroutine zhprfs_c(uplo, n, nrhs, ap_shape__, ap, afp_shape__, af
     &p, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx, ferr_
     &shape__, ferr, berr_shape__, berr, work_shape__, work, rwork_shape
     &__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex*16, dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhprfs(uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, 
     &berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zhprfs_c
      subroutine zhpsv_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, ip
     &iv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhpsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhpsv(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zhpsv_c
      subroutine zhpsvx_c(fact, uplo, n, nrhs, ap_shape__, ap, afp_shape
     &__, afp, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx,
     & rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work
     &, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex*16, dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhpsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhpsvx(fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, 
     &rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zhpsvx_c
      subroutine zhptrd_c(uplo, n, ap_shape__, ap, d_shape__, d, e_shape
     &__, e, tau_shape__, tau, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhptrd
        fw_iserr__ = -1
        call zhptrd(uplo, n, ap, d, e, tau, info)
        fw_iserr__ = 0
      end subroutine zhptrd_c
      subroutine zhptrf_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhptrf
        fw_iserr__ = -1
        call zhptrf(uplo, n, ap, ipiv, info)
        fw_iserr__ = 0
      end subroutine zhptrf_c
      subroutine zhptri_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, w
     &ork_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhptri
        fw_iserr__ = -1
        call zhptri(uplo, n, ap, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine zhptri_c
      subroutine zhptrs_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, i
     &piv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhptrs(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zhptrs_c
      subroutine zhsein_c(side, eigsrc, initv, select_shape__, select, n
     &, h_shape__, h, ldh, w_shape__, w, vl_shape__, vl, ldvl, vr_shape_
     &_, vr, ldvr, mm, m, work_shape__, work, rwork_shape__, rwork, ifai
     &ll_shape__, ifaill, ifailr_shape__, ifailr, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: eigsrc
        character(len=1, kind=kind('a')) :: initv
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer, dimension(2) :: vl_shape__
        complex*16, dimension(vl_shape__(1), vl_shape__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex*16, dimension(vr_shape__(1), vr_shape__(2)) :: vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: ifaill_shape__
        integer, dimension(ifaill_shape__(1)) :: ifaill
        integer, dimension(1) :: ifailr_shape__
        integer, dimension(ifailr_shape__(1)) :: ifailr
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhsein
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhsein(side, eigsrc, initv, select, n, h, ldh, w, vl, ldvl,
     & vr, ldvr, mm, m, work, rwork, ifaill, ifailr, info)
        fw_iserr__ = 0
      end subroutine zhsein_c
      subroutine zhseqr_c(job, compz, n, ilo, ihi, h_shape__, h, ldh, w_
     &shape__, w, z_shape__, z, ldz, work_shape__, work, lwork, info, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zhseqr
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zhseqr(job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lw
     &ork, info)
        fw_iserr__ = 0
      end subroutine zhseqr_c
      subroutine zla_gbamv_c(trans, m, n, kl, ku, alpha, ab_shape__, ab,
     & ldab, x_shape__, x, incx, beta, y_shape__, y, incy, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: trans
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_gbamv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zla_gbamv(trans, m, n, kl, ku, alpha, ab, ldab, x, incx, be
     &ta, y, incy)
        fw_iserr__ = 0
      end subroutine zla_gbamv_c
      subroutine zla_gbrcond_c_c(fw_ret_arg, trans, n, kl, ku, ab_shape_
     &_, ab, ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, c_shape_
     &_, c, capply, info, work_shape__, work, rwork_shape__, rwork, fw_i
     &serr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex*16, dimension(afb_shape__(1), afb_shape__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer(kind=kind(0)) :: capply
        integer :: info
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_gbrcond_c
        external zla_gbrcond_c
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_gbrcond_c(trans, n, kl, ku, ab, ldab, afb, ldaf
     &b, ipiv, c, capply, info, work, rwork)
        fw_iserr__ = 0
      end subroutine zla_gbrcond_c_c
      subroutine zla_gbrcond_x_c(fw_ret_arg, trans, n, kl, ku, ab_shape_
     &_, ab, ldab, afb_shape__, afb, ldafb, ipiv_shape__, ipiv, x_shape_
     &_, x, info, work_shape__, work, rwork_shape__, rwork, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex*16, dimension(afb_shape__(1), afb_shape__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: info
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_gbrcond_x
        external zla_gbrcond_x
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_gbrcond_x(trans, n, kl, ku, ab, ldab, afb, ldaf
     &b, ipiv, x, info, work, rwork)
        fw_iserr__ = 0
      end subroutine zla_gbrcond_x_c
      subroutine zla_gbrfsx_extended_c(prec_type, trans_type, n, kl, ku,
     & nrhs, ab_shape__, ab, ldab, afb_shape__, afb, ldafb, ipiv_shape__
     &, ipiv, colequ, c_shape__, c, b_shape__, b, ldb, y_shape__, y, ldy
     &, berr_out_shape__, berr_out, n_norms, err_bnds_norm_shape__, err_
     &bnds_norm, err_bnds_comp_shape__, err_bnds_comp, res_shape__, res,
     & ayb_shape__, ayb, dy_shape__, dy, y_tail_shape__, y_tail, rcond, 
     &ithresh, rthresh, dz_ub, ignore_cwise, info, fw_iserr__, fw_errstr
     &__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        integer :: trans_type
        integer :: n
        integer :: kl
        integer :: ku
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex*16, dimension(afb_shape__(1), afb_shape__(2)) :: afb
        integer :: ldafb
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        complex*16, dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0D0)), dimension(berr_out_shape__(1)) :: berr_o
     &ut
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        complex*16, dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        complex*16, dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        complex*16, dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0D0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0D0)) :: rthresh
        real(kind=kind(0.0D0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_gbrfsx_extended
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zla_gbrfsx_extended(prec_type, trans_type, n, kl, ku, nrhs,
     & ab, ldab, afb, ldafb, ipiv, colequ, c, b, ldb, y, ldy, berr_out, 
     &n_norms, err_bnds_norm, err_bnds_comp, res, ayb, dy, y_tail, rcond
     &, ithresh, rthresh, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine zla_gbrfsx_extended_c
      subroutine zla_gbrpvgrw_c(fw_ret_arg, n, kl, ku, ncols, ab_shape__
     &, ab, ldab, afb_shape__, afb, ldafb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        integer :: n
        integer :: kl
        integer :: ku
        integer :: ncols
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex*16, dimension(afb_shape__(1), afb_shape__(2)) :: afb
        integer :: ldafb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_gbrpvgrw
        external zla_gbrpvgrw
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_gbrpvgrw(n, kl, ku, ncols, ab, ldab, afb, ldafb
     &)
        fw_iserr__ = 0
      end subroutine zla_gbrpvgrw_c
      subroutine zla_geamv_c(trans, m, n, alpha, a_shape__, a, lda, x_sh
     &ape__, x, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: trans
        integer :: m
        integer :: n
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_geamv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zla_geamv(trans, m, n, alpha, a, lda, x, incx, beta, y, inc
     &y)
        fw_iserr__ = 0
      end subroutine zla_geamv_c
      subroutine zla_gercond_c_c(fw_ret_arg, trans, n, a_shape__, a, lda
     &, af_shape__, af, ldaf, ipiv_shape__, ipiv, c_shape__, c, capply, 
     &info, work_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer(kind=kind(0)) :: capply
        integer :: info
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_gercond_c
        external zla_gercond_c
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_gercond_c(trans, n, a, lda, af, ldaf, ipiv, c, 
     &capply, info, work, rwork)
        fw_iserr__ = 0
      end subroutine zla_gercond_c_c
      subroutine zla_gercond_x_c(fw_ret_arg, trans, n, a_shape__, a, lda
     &, af_shape__, af, ldaf, ipiv_shape__, ipiv, x_shape__, x, info, wo
     &rk_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: info
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_gercond_x
        external zla_gercond_x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_gercond_x(trans, n, a, lda, af, ldaf, ipiv, x, 
     &info, work, rwork)
        fw_iserr__ = 0
      end subroutine zla_gercond_x_c
      subroutine zla_gerfsx_extended_c(prec_type, trans_type, n, nrhs, a
     &_shape__, a, lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, colequ
     &, c_shape__, c, b_shape__, b, ldb, y_shape__, y, ldy, berr_out_sha
     &pe__, berr_out, n_norms, errs_n_shape__, errs_n, errs_c_shape__, e
     &rrs_c, res_shape__, res, ayb_shape__, ayb, dy_shape__, dy, y_tail_
     &shape__, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        integer :: trans_type
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        complex*16, dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0D0)), dimension(berr_out_shape__(1)) :: berr_o
     &ut
        integer :: n_norms
        integer, dimension(2) :: errs_n_shape__
        real(kind=kind(0.0D0)), dimension(errs_n_shape__(1), errs_n_shap
     &e__(2)) :: errs_n
        integer, dimension(2) :: errs_c_shape__
        real(kind=kind(0.0D0)), dimension(errs_c_shape__(1), errs_c_shap
     &e__(2)) :: errs_c
        integer, dimension(1) :: res_shape__
        complex*16, dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        complex*16, dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        complex*16, dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0D0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0D0)) :: rthresh
        real(kind=kind(0.0D0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_gerfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (errs_n_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("errs_n                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (errs_c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("errs_c                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zla_gerfsx_extended(prec_type, trans_type, n, nrhs, a, lda,
     & af, ldaf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err
     &s_n, errs_c, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_ub,
     & ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine zla_gerfsx_extended_c
      subroutine zla_heamv_c(uplo, n, alpha, a_shape__, a, lda, x_shape_
     &_, x, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: uplo
        integer :: n
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_heamv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zla_heamv(uplo, n, alpha, a, lda, x, incx, beta, y, incy)
        fw_iserr__ = 0
      end subroutine zla_heamv_c
      subroutine zla_hercond_c_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, ipiv_shape__, ipiv, c_shape__, c, capply, i
     &nfo, work_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer(kind=kind(0)) :: capply
        integer :: info
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_hercond_c
        external zla_hercond_c
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_hercond_c(uplo, n, a, lda, af, ldaf, ipiv, c, c
     &apply, info, work, rwork)
        fw_iserr__ = 0
      end subroutine zla_hercond_c_c
      subroutine zla_hercond_x_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, ipiv_shape__, ipiv, x_shape__, x, info, wor
     &k_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: info
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_hercond_x
        external zla_hercond_x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_hercond_x(uplo, n, a, lda, af, ldaf, ipiv, x, i
     &nfo, work, rwork)
        fw_iserr__ = 0
      end subroutine zla_hercond_x_c
      subroutine zla_herfsx_extended_c(prec_type, uplo, n, nrhs, a_shape
     &__, a, lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, colequ, c_sh
     &ape__, c, b_shape__, b, ldb, y_shape__, y, ldy, berr_out_shape__, 
     &berr_out, n_norms, err_bnds_norm_shape__, err_bnds_norm, err_bnds_
     &comp_shape__, err_bnds_comp, res_shape__, res, ayb_shape__, ayb, d
     &y_shape__, dy, y_tail_shape__, y_tail, rcond, ithresh, rthresh, dz
     &_ub, ignore_cwise, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        complex*16, dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0D0)), dimension(berr_out_shape__(1)) :: berr_o
     &ut
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        complex*16, dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        complex*16, dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        complex*16, dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0D0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0D0)) :: rthresh
        real(kind=kind(0.0D0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_herfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zla_herfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, l
     &daf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_
     &norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh
     &, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine zla_herfsx_extended_c
      subroutine zla_herpvgrw_c(fw_ret_arg, uplo, n, info, a_shape__, a,
     & lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, work_shape__, work
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1) :: uplo
        integer :: n
        integer :: info
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_herpvgrw
        external zla_herpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_herpvgrw(uplo, n, info, a, lda, af, ldaf, ipiv,
     & work)
        fw_iserr__ = 0
      end subroutine zla_herpvgrw_c
      subroutine zla_lin_berr_c(n, nz, nrhs, res_shape__, res, ayb_shape
     &__, ayb, berr_shape__, berr, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nz
        integer :: nrhs
        integer, dimension(2) :: res_shape__
        complex*16, dimension(res_shape__(1), res_shape__(2)) :: res
        integer, dimension(2) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1), ayb_shape__(2)
     &) :: ayb
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_lin_berr
        fw_iserr__ = -1
        if ((n) .ne. (res_shape__(1)) .or. (nrhs) .lt. 0 .or. (nrhs) .gt
     &. (res_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("res                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .ne. (ayb_shape__(1)) .or. (nrhs) .lt. 0 .or. (nrhs) .gt
     &. (ayb_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ayb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .lt. 0 .or. (nrhs) .gt. (berr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("berr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zla_lin_berr(n, nz, nrhs, res, ayb, berr)
        fw_iserr__ = 0
      end subroutine zla_lin_berr_c
      subroutine zla_porcond_c_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, c_shape__, c, capply, info, work_shape__, w
     &ork, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer(kind=kind(0)) :: capply
        integer :: info
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_porcond_c
        external zla_porcond_c
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_porcond_c(uplo, n, a, lda, af, ldaf, c, capply,
     & info, work, rwork)
        fw_iserr__ = 0
      end subroutine zla_porcond_c_c
      subroutine zla_porcond_x_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, x_shape__, x, info, work_shape__, work, rwo
     &rk_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: info
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_porcond_x
        external zla_porcond_x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_porcond_x(uplo, n, a, lda, af, ldaf, x, info, w
     &ork, rwork)
        fw_iserr__ = 0
      end subroutine zla_porcond_x_c
      subroutine zla_porfsx_extended_c(prec_type, uplo, n, nrhs, a_shape
     &__, a, lda, af_shape__, af, ldaf, colequ, c_shape__, c, b_shape__,
     & b, ldb, y_shape__, y, ldy, berr_out_shape__, berr_out, n_norms, e
     &rr_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bn
     &ds_comp, res_shape__, res, ayb_shape__, ayb, dy_shape__, dy, y_tai
     &l_shape__, y_tail, rcond, ithresh, rthresh, dz_ub, ignore_cwise, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        complex*16, dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0D0)), dimension(berr_out_shape__(1)) :: berr_o
     &ut
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        complex*16, dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        complex*16, dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        complex*16, dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0D0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0D0)) :: rthresh
        real(kind=kind(0.0D0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_porfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zla_porfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, l
     &daf, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_norm, 
     &err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh, dz_u
     &b, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine zla_porfsx_extended_c
      subroutine zla_porpvgrw_c(fw_ret_arg, uplo, ncols, a_shape__, a, l
     &da, af_shape__, af, ldaf, work_shape__, work, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1) :: uplo
        integer :: ncols
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_porpvgrw
        external zla_porpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_porpvgrw(uplo, ncols, a, lda, af, ldaf, work)
        fw_iserr__ = 0
      end subroutine zla_porpvgrw_c
      subroutine zla_rpvgrw_c(fw_ret_arg, n, ncols, a_shape__, a, lda, a
     &f_shape__, af, ldaf, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        integer :: n
        integer :: ncols
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_rpvgrw
        external zla_rpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_rpvgrw(n, ncols, a, lda, af, ldaf)
        fw_iserr__ = 0
      end subroutine zla_rpvgrw_c
      subroutine zla_syamv_c(uplo, n, alpha, a_shape__, a, lda, x_shape_
     &_, x, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: uplo
        integer :: n
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(1) :: y_shape__
        real(kind=kind(0.0D0)), dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_syamv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zla_syamv(uplo, n, alpha, a, lda, x, incx, beta, y, incy)
        fw_iserr__ = 0
      end subroutine zla_syamv_c
      subroutine zla_syrcond_c_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, ipiv_shape__, ipiv, c_shape__, c, capply, i
     &nfo, work_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer(kind=kind(0)) :: capply
        integer :: info
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_syrcond_c
        external zla_syrcond_c
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_syrcond_c(uplo, n, a, lda, af, ldaf, ipiv, c, c
     &apply, info, work, rwork)
        fw_iserr__ = 0
      end subroutine zla_syrcond_c_c
      subroutine zla_syrcond_x_c(fw_ret_arg, uplo, n, a_shape__, a, lda,
     & af_shape__, af, ldaf, ipiv_shape__, ipiv, x_shape__, x, info, wor
     &k_shape__, work, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: info
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_syrcond_x
        external zla_syrcond_x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_syrcond_x(uplo, n, a, lda, af, ldaf, ipiv, x, i
     &nfo, work, rwork)
        fw_iserr__ = 0
      end subroutine zla_syrcond_x_c
      subroutine zla_syrfsx_extended_c(prec_type, uplo, n, nrhs, a_shape
     &__, a, lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, colequ, c_sh
     &ape__, c, b_shape__, b, ldb, y_shape__, y, ldy, berr_out_shape__, 
     &berr_out, n_norms, err_bnds_norm_shape__, err_bnds_norm, err_bnds_
     &comp_shape__, err_bnds_comp, res_shape__, res, ayb_shape__, ayb, d
     &y_shape__, dy, y_tail_shape__, y_tail, rcond, ithresh, rthresh, dz
     &_ub, ignore_cwise, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: prec_type
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer(kind=kind(0)) :: colequ
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: y_shape__
        complex*16, dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer, dimension(1) :: berr_out_shape__
        real(kind=kind(0.0D0)), dimension(berr_out_shape__(1)) :: berr_o
     &ut
        integer :: n_norms
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer, dimension(1) :: res_shape__
        complex*16, dimension(res_shape__(1)) :: res
        integer, dimension(1) :: ayb_shape__
        real(kind=kind(0.0D0)), dimension(ayb_shape__(1)) :: ayb
        integer, dimension(1) :: dy_shape__
        complex*16, dimension(dy_shape__(1)) :: dy
        integer, dimension(1) :: y_tail_shape__
        complex*16, dimension(y_tail_shape__(1)) :: y_tail
        real(kind=kind(0.0D0)) :: rcond
        integer :: ithresh
        real(kind=kind(0.0D0)) :: rthresh
        real(kind=kind(0.0D0)) :: dz_ub
        integer(kind=kind(0)) :: ignore_cwise
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_syrfsx_extended
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zla_syrfsx_extended(prec_type, uplo, n, nrhs, a, lda, af, l
     &daf, ipiv, colequ, c, b, ldb, y, ldy, berr_out, n_norms, err_bnds_
     &norm, err_bnds_comp, res, ayb, dy, y_tail, rcond, ithresh, rthresh
     &, dz_ub, ignore_cwise, info)
        fw_iserr__ = 0
      end subroutine zla_syrfsx_extended_c
      subroutine zla_syrpvgrw_c(fw_ret_arg, uplo, n, info, a_shape__, a,
     & lda, af_shape__, af, ldaf, ipiv_shape__, ipiv, work_shape__, work
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1) :: uplo
        integer :: n
        integer :: info
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zla_syrpvgrw
        external zla_syrpvgrw
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zla_syrpvgrw(uplo, n, info, a, lda, af, ldaf, ipiv,
     & work)
        fw_iserr__ = 0
      end subroutine zla_syrpvgrw_c
      subroutine zla_wwaddw_c(n, x_shape__, x, y_shape__, y, w_shape__, 
     &w, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        complex*16, dimension(y_shape__(1)) :: y
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zla_wwaddw
        fw_iserr__ = -1
        call zla_wwaddw(n, x, y, w)
        fw_iserr__ = 0
      end subroutine zla_wwaddw_c
      subroutine zlabrd_c(m, n, nb, a_shape__, a, lda, d_shape__, d, e_s
     &hape__, e, tauq_shape__, tauq, taup_shape__, taup, x_shape__, x, l
     &dx, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: nb
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tauq_shape__
        complex*16, dimension(tauq_shape__(1)) :: tauq
        integer, dimension(1) :: taup_shape__
        complex*16, dimension(taup_shape__(1)) :: taup
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(2) :: y_shape__
        complex*16, dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlabrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlabrd(m, n, nb, a, lda, d, e, tauq, taup, x, ldx, y, ldy)
        fw_iserr__ = 0
      end subroutine zlabrd_c
      subroutine zlacgv_c(n, x_shape__, x, incx, fw_iserr__, fw_errstr__
     &)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlacgv
        fw_iserr__ = -1
        call zlacgv(n, x, incx)
        fw_iserr__ = 0
      end subroutine zlacgv_c
      subroutine zlacn2_c(n, v_shape__, v, x_shape__, x, est, kase, isav
     &e_shape__, isave, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: v_shape__
        complex*16, dimension(v_shape__(1)) :: v
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        real(kind=kind(0.0D0)) :: est
        integer :: kase
        integer, dimension(1) :: isave_shape__
        integer, dimension(isave_shape__(1)) :: isave
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlacn2
        fw_iserr__ = -1
        if ((3) .lt. 0 .or. (3) .gt. (isave_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("isave                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlacn2(n, v, x, est, kase, isave)
        fw_iserr__ = 0
      end subroutine zlacn2_c
      subroutine zlacon_c(n, v_shape__, v, x_shape__, x, est, kase, fw_i
     &serr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: v_shape__
        complex*16, dimension(v_shape__(1)) :: v
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        real(kind=kind(0.0D0)) :: est
        integer :: kase
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlacon
        fw_iserr__ = -1
        if ((n) .lt. 0 .or. (n) .gt. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlacon(n, v, x, est, kase)
        fw_iserr__ = 0
      end subroutine zlacon_c
      subroutine zlacp2_c(uplo, m, n, a_shape__, a, lda, b_shape__, b, l
     &db, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlacp2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlacp2(uplo, m, n, a, lda, b, ldb)
        fw_iserr__ = 0
      end subroutine zlacp2_c
      subroutine zlacpy_c(uplo, m, n, a_shape__, a, lda, b_shape__, b, l
     &db, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlacpy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlacpy(uplo, m, n, a, lda, b, ldb)
        fw_iserr__ = 0
      end subroutine zlacpy_c
      subroutine zlacrm_c(m, n, a_shape__, a, lda, b_shape__, b, ldb, c_
     &shape__, c, ldc, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        real(kind=kind(0.0D0)), dimension(b_shape__(1), b_shape__(2)) ::
     & b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlacrm
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlacrm(m, n, a, lda, b, ldb, c, ldc, rwork)
        fw_iserr__ = 0
      end subroutine zlacrm_c
      subroutine zlacrt_c(n, cx_shape__, cx, incx, cy_shape__, cy, incy,
     & c, s, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: cx_shape__
        complex*16, dimension(cx_shape__(1)) :: cx
        integer :: incx
        integer, dimension(1) :: cy_shape__
        complex*16, dimension(cy_shape__(1)) :: cy
        integer :: incy
        complex*16 :: c
        complex*16 :: s
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlacrt
        fw_iserr__ = -1
        call zlacrt(n, cx, incx, cy, incy, c, s)
        fw_iserr__ = 0
      end subroutine zlacrt_c
      subroutine zladiv_c(fw_ret_arg, x, y, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        complex*16 :: fw_ret_arg
        complex*16 :: x
        complex*16 :: y
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        complex*16 :: zladiv
        external zladiv
        fw_iserr__ = -1
        fw_ret_arg = zladiv(x, y)
        fw_iserr__ = 0
      end subroutine zladiv_c
      subroutine zlaed0_c(qsiz, n, d_shape__, d, e_shape__, e, q_shape__
     &, q, ldq, qstore_shape__, qstore, ldqs, rwork_shape__, rwork, iwor
     &k_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: qsiz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: qstore_shape__
        complex*16, dimension(qstore_shape__(1), qstore_shape__(2)) :: q
     &store
        integer :: ldqs
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaed0
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldqs) .ne. (qstore_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("qstore                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaed0(qsiz, n, d, e, q, ldq, qstore, ldqs, rwork, iwork, i
     &nfo)
        fw_iserr__ = 0
      end subroutine zlaed0_c
      subroutine zlaed7_c(n, cutpnt, qsiz, tlvls, curlvl, curpbm, d_shap
     &e__, d, q_shape__, q, ldq, rho, indxq_shape__, indxq, qstore_shape
     &__, qstore, qptr_shape__, qptr, prmptr_shape__, prmptr, perm_shape
     &__, perm, givptr_shape__, givptr, givcol_shape__, givcol, givnum_s
     &hape__, givnum, work_shape__, work, rwork_shape__, rwork, iwork_sh
     &ape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: cutpnt
        integer :: qsiz
        integer :: tlvls
        integer :: curlvl
        integer :: curpbm
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        real(kind=kind(0.0D0)) :: rho
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        integer, dimension(1) :: qstore_shape__
        real(kind=kind(0.0D0)), dimension(qstore_shape__(1)) :: qstore
        integer, dimension(1) :: qptr_shape__
        integer, dimension(qptr_shape__(1)) :: qptr
        integer, dimension(1) :: prmptr_shape__
        integer, dimension(prmptr_shape__(1)) :: prmptr
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaed7
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaed7(n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q, ldq, r
     &ho, indxq, qstore, qptr, prmptr, perm, givptr, givcol, givnum, wor
     &k, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine zlaed7_c
      subroutine zlaed8_c(k, n, qsiz, q_shape__, q, ldq, d_shape__, d, r
     &ho, cutpnt, z_shape__, z, dlamda_shape__, dlamda, q2_shape__, q2, 
     &ldq2, w_shape__, w, indxp_shape__, indxp, indx_shape__, indx, indx
     &q_shape__, indxq, perm_shape__, perm, givptr, givcol_shape__, givc
     &ol, givnum_shape__, givnum, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: k
        integer :: n
        integer :: qsiz
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        real(kind=kind(0.0D0)) :: rho
        integer :: cutpnt
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer, dimension(1) :: dlamda_shape__
        real(kind=kind(0.0D0)), dimension(dlamda_shape__(1)) :: dlamda
        integer, dimension(2) :: q2_shape__
        complex*16, dimension(q2_shape__(1), q2_shape__(2)) :: q2
        integer :: ldq2
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: indxp_shape__
        integer, dimension(indxp_shape__(1)) :: indxp
        integer, dimension(1) :: indx_shape__
        integer, dimension(indx_shape__(1)) :: indx
        integer, dimension(1) :: indxq_shape__
        integer, dimension(indxq_shape__(1)) :: indxq
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaed8
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq2) .ne. (q2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaed8(k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda, q2, l
     &dq2, w, indxp, indx, indxq, perm, givptr, givcol, givnum, info)
        fw_iserr__ = 0
      end subroutine zlaed8_c
      subroutine zlaein_c(rightv, noinit, n, h_shape__, h, ldh, w, v_sha
     &pe__, v, b_shape__, b, ldb, rwork_shape__, rwork, eps3, smlnum, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: rightv
        integer(kind=kind(0)) :: noinit
        integer :: n
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        complex*16 :: w
        integer, dimension(1) :: v_shape__
        complex*16, dimension(v_shape__(1)) :: v
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        real(kind=kind(0.0D0)) :: eps3
        real(kind=kind(0.0D0)) :: smlnum
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaein
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaein(rightv, noinit, n, h, ldh, w, v, b, ldb, rwork, eps3
     &, smlnum, info)
        fw_iserr__ = 0
      end subroutine zlaein_c
      subroutine zlaesy_c(a, b, c, rt1, rt2, evscal, cs1, sn1, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        complex*16 :: a
        complex*16 :: b
        complex*16 :: c
        complex*16 :: rt1
        complex*16 :: rt2
        complex*16 :: evscal
        complex*16 :: cs1
        complex*16 :: sn1
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaesy
        fw_iserr__ = -1
        call zlaesy(a, b, c, rt1, rt2, evscal, cs1, sn1)
        fw_iserr__ = 0
      end subroutine zlaesy_c
      subroutine zlaev2_c(a, b, c, rt1, rt2, cs1, sn1, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        complex*16 :: a
        complex*16 :: b
        complex*16 :: c
        real(kind=kind(0.0D0)) :: rt1
        real(kind=kind(0.0D0)) :: rt2
        real(kind=kind(0.0D0)) :: cs1
        complex*16 :: sn1
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaev2
        fw_iserr__ = -1
        call zlaev2(a, b, c, rt1, rt2, cs1, sn1)
        fw_iserr__ = 0
      end subroutine zlaev2_c
      subroutine zlag2c_c(m, n, a_shape__, a, lda, sa_shape__, sa, ldsa,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: sa_shape__
        complex(kind=kind((0.0,0.0))), dimension(sa_shape__(1), sa_shape
     &__(2)) :: sa
        integer :: ldsa
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlag2c
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldsa) .ne. (sa_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sa                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlag2c(m, n, a, lda, sa, ldsa, info)
        fw_iserr__ = 0
      end subroutine zlag2c_c
      subroutine zlags2_c(upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, 
     &snv, csq, snq, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: upper
        real(kind=kind(0.0D0)) :: a1
        complex*16 :: a2
        real(kind=kind(0.0D0)) :: a3
        real(kind=kind(0.0D0)) :: b1
        complex*16 :: b2
        real(kind=kind(0.0D0)) :: b3
        real(kind=kind(0.0D0)) :: csu
        complex*16 :: snu
        real(kind=kind(0.0D0)) :: csv
        complex*16 :: snv
        real(kind=kind(0.0D0)) :: csq
        complex*16 :: snq
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlags2
        fw_iserr__ = -1
        call zlags2(upper, a1, a2, a3, b1, b2, b3, csu, snu, csv, snv, c
     &sq, snq)
        fw_iserr__ = 0
      end subroutine zlags2_c
      subroutine zlagtm_c(trans, n, nrhs, alpha, dl_shape__, dl, d_shape
     &__, d, du_shape__, du, x_shape__, x, ldx, beta, b_shape__, b, ldb,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: n
        integer :: nrhs
        real(kind=kind(0.0D0)) :: alpha
        integer, dimension(1) :: dl_shape__
        complex*16, dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex*16, dimension(du_shape__(1)) :: du
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: beta
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlagtm
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlagtm(trans, n, nrhs, alpha, dl, d, du, x, ldx, beta, b, l
     &db)
        fw_iserr__ = 0
      end subroutine zlagtm_c
      subroutine zlahef_c(uplo, n, nb, kb, a_shape__, a, lda, ipiv_shape
     &__, ipiv, w_shape__, w, ldw, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nb
        integer :: kb
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: w_shape__
        complex*16, dimension(w_shape__(1), w_shape__(2)) :: w
        integer :: ldw
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlahef
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldw) .ne. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlahef(uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)
        fw_iserr__ = 0
      end subroutine zlahef_c
      subroutine zlahqr_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &w_shape__, w, iloz, ihiz, z_shape__, z, ldz, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlahqr
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlahqr(wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z,
     & ldz, info)
        fw_iserr__ = 0
      end subroutine zlahqr_c
      subroutine zlahr2_c(n, k, nb, a_shape__, a, lda, tau_shape__, tau,
     & t_shape__, t, ldt, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: k
        integer :: nb
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: y_shape__
        complex*16, dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlahr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nb) .lt. 0 .or. (nb) .gt. (tau_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tau                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (t
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (y
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlahr2(n, k, nb, a, lda, tau, t, ldt, y, ldy)
        fw_iserr__ = 0
      end subroutine zlahr2_c
      subroutine zlahrd_c(n, k, nb, a_shape__, a, lda, tau_shape__, tau,
     & t_shape__, t, ldt, y_shape__, y, ldy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: k
        integer :: nb
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: y_shape__
        complex*16, dimension(y_shape__(1), y_shape__(2)) :: y
        integer :: ldy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlahrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nb) .lt. 0 .or. (nb) .gt. (tau_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("tau                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (t
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldy) .ne. (y_shape__(1)) .or. (nb) .lt. 0 .or. (nb) .gt. (y
     &_shape__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("y                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlahrd(n, k, nb, a, lda, tau, t, ldt, y, ldy)
        fw_iserr__ = 0
      end subroutine zlahrd_c
      subroutine zlaic1_c(job, j, x_shape__, x, sest, w_shape__, w, gamm
     &a, sestpr, s, c, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: job
        integer :: j
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        real(kind=kind(0.0D0)) :: sest
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        complex*16 :: gamma
        real(kind=kind(0.0D0)) :: sestpr
        complex*16 :: s
        complex*16 :: c
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaic1
        fw_iserr__ = -1
        if ((j) .lt. 0 .or. (j) .gt. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((j) .lt. 0 .or. (j) .gt. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaic1(job, j, x, sest, w, gamma, sestpr, s, c)
        fw_iserr__ = 0
      end subroutine zlaic1_c
      subroutine zlals0_c(icompq, nl, nr, sqre, nrhs, b_shape__, b, ldb,
     & bx_shape__, bx, ldbx, perm_shape__, perm, givptr, givcol_shape__,
     & givcol, ldgcol, givnum_shape__, givnum, ldgnum, poles_shape__, po
     &les, difl_shape__, difl, difr_shape__, difr, z_shape__, z, k, c, s
     &, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: nl
        integer :: nr
        integer :: sqre
        integer :: nrhs
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: bx_shape__
        complex*16, dimension(bx_shape__(1), bx_shape__(2)) :: bx
        integer :: ldbx
        integer, dimension(1) :: perm_shape__
        integer, dimension(perm_shape__(1)) :: perm
        integer :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer :: ldgnum
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0D0)), dimension(poles_shape__(1), poles_shape_
     &_(2)) :: poles
        integer, dimension(1) :: difl_shape__
        real(kind=kind(0.0D0)), dimension(difl_shape__(1)) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0D0)), dimension(difr_shape__(1), difr_shape__(
     &2)) :: difr
        integer, dimension(1) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1)) :: z
        integer :: k
        real(kind=kind(0.0D0)) :: c
        real(kind=kind(0.0D0)) :: s
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlals0
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbx) .ne. (bx_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bx                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgnum) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlals0(icompq, nl, nr, sqre, nrhs, b, ldb, bx, ldbx, perm, 
     &givptr, givcol, ldgcol, givnum, ldgnum, poles, difl, difr, z, k, c
     &, s, rwork, info)
        fw_iserr__ = 0
      end subroutine zlals0_c
      subroutine zlalsa_c(icompq, smlsiz, n, nrhs, b_shape__, b, ldb, bx
     &_shape__, bx, ldbx, u_shape__, u, ldu, vt_shape__, vt, k_shape__, 
     &k, difl_shape__, difl, difr_shape__, difr, z_shape__, z, poles_sha
     &pe__, poles, givptr_shape__, givptr, givcol_shape__, givcol, ldgco
     &l, perm_shape__, perm, givnum_shape__, givnum, c_shape__, c, s_sha
     &pe__, s, rwork_shape__, rwork, iwork_shape__, iwork, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: icompq
        integer :: smlsiz
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: bx_shape__
        complex*16, dimension(bx_shape__(1), bx_shape__(2)) :: bx
        integer :: ldbx
        integer, dimension(2) :: u_shape__
        real(kind=kind(0.0D0)), dimension(u_shape__(1), u_shape__(2)) ::
     & u
        integer :: ldu
        integer, dimension(2) :: vt_shape__
        real(kind=kind(0.0D0)), dimension(vt_shape__(1), vt_shape__(2)) 
     &:: vt
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer, dimension(2) :: difl_shape__
        real(kind=kind(0.0D0)), dimension(difl_shape__(1), difl_shape__(
     &2)) :: difl
        integer, dimension(2) :: difr_shape__
        real(kind=kind(0.0D0)), dimension(difr_shape__(1), difr_shape__(
     &2)) :: difr
        integer, dimension(2) :: z_shape__
        real(kind=kind(0.0D0)), dimension(z_shape__(1), z_shape__(2)) ::
     & z
        integer, dimension(2) :: poles_shape__
        real(kind=kind(0.0D0)), dimension(poles_shape__(1), poles_shape_
     &_(2)) :: poles
        integer, dimension(1) :: givptr_shape__
        integer, dimension(givptr_shape__(1)) :: givptr
        integer, dimension(2) :: givcol_shape__
        integer, dimension(givcol_shape__(1), givcol_shape__(2)) :: givc
     &ol
        integer :: ldgcol
        integer, dimension(2) :: perm_shape__
        integer, dimension(perm_shape__(1), perm_shape__(2)) :: perm
        integer, dimension(2) :: givnum_shape__
        real(kind=kind(0.0D0)), dimension(givnum_shape__(1), givnum_shap
     &e__(2)) :: givnum
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlalsa
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldbx) .ne. (bx_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("bx                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (vt_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vt                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difl                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (difr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("difr                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (poles_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("poles                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (givcol_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givcol                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldgcol) .ne. (perm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("perm                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (givnum_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("givnum                              
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlalsa(icompq, smlsiz, n, nrhs, b, ldb, bx, ldbx, u, ldu, v
     &t, k, difl, difr, z, poles, givptr, givcol, ldgcol, perm, givnum, 
     &c, s, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine zlalsa_c
      subroutine zlalsd_c(uplo, smlsiz, n, nrhs, d_shape__, d, e_shape__
     &, e, b_shape__, b, ldb, rcond, rank, work_shape__, work, rwork_sha
     &pe__, rwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: smlsiz
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0D0)) :: rcond
        integer :: rank
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlalsd
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlalsd(uplo, smlsiz, n, nrhs, d, e, b, ldb, rcond, rank, wo
     &rk, rwork, iwork, info)
        fw_iserr__ = 0
      end subroutine zlalsd_c
      subroutine zlangb_c(fw_ret_arg, norm, n, kl, ku, ab_shape__, ab, l
     &dab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlangb
        external zlangb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zlangb(norm, n, kl, ku, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine zlangb_c
      subroutine zlange_c(fw_ret_arg, norm, m, n, a_shape__, a, lda, wor
     &k_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlange
        external zlange
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zlange(norm, m, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine zlange_c
      subroutine zlangt_c(fw_ret_arg, norm, n, dl_shape__, dl, d_shape__
     &, d, du_shape__, du, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: dl_shape__
        complex*16, dimension(dl_shape__(1)) :: dl
        integer, dimension(1) :: d_shape__
        complex*16, dimension(d_shape__(1)) :: d
        integer, dimension(1) :: du_shape__
        complex*16, dimension(du_shape__(1)) :: du
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlangt
        external zlangt
        fw_iserr__ = -1
        fw_ret_arg = zlangt(norm, n, dl, d, du)
        fw_iserr__ = 0
      end subroutine zlangt_c
      subroutine zlanhb_c(fw_ret_arg, norm, uplo, n, k, ab_shape__, ab, 
     &ldab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: k
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlanhb
        external zlanhb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zlanhb(norm, uplo, n, k, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine zlanhb_c
      subroutine zlanhe_c(fw_ret_arg, norm, uplo, n, a_shape__, a, lda, 
     &work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlanhe
        external zlanhe
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zlanhe(norm, uplo, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine zlanhe_c
      subroutine zlanhf_c(fw_ret_arg, norm, transr, uplo, n, a_shape__, 
     &a, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        complex*16, dimension(a_shape__(1)) :: a
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlanhf
        external zlanhf
        fw_iserr__ = -1
        fw_ret_arg = zlanhf(norm, transr, uplo, n, a, work)
        fw_iserr__ = 0
      end subroutine zlanhf_c
      subroutine zlanhp_c(fw_ret_arg, norm, uplo, n, ap_shape__, ap, wor
     &k_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlanhp
        external zlanhp
        fw_iserr__ = -1
        fw_ret_arg = zlanhp(norm, uplo, n, ap, work)
        fw_iserr__ = 0
      end subroutine zlanhp_c
      subroutine zlanhs_c(fw_ret_arg, norm, n, a_shape__, a, lda, work_s
     &hape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlanhs
        external zlanhs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zlanhs(norm, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine zlanhs_c
      subroutine zlanht_c(fw_ret_arg, norm, n, d_shape__, d, e_shape__, 
     &e, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex*16, dimension(e_shape__(1)) :: e
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlanht
        external zlanht
        fw_iserr__ = -1
        fw_ret_arg = zlanht(norm, n, d, e)
        fw_iserr__ = 0
      end subroutine zlanht_c
      subroutine zlansb_c(fw_ret_arg, norm, uplo, n, k, ab_shape__, ab, 
     &ldab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: k
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlansb
        external zlansb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zlansb(norm, uplo, n, k, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine zlansb_c
      subroutine zlansp_c(fw_ret_arg, norm, uplo, n, ap_shape__, ap, wor
     &k_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlansp
        external zlansp
        fw_iserr__ = -1
        fw_ret_arg = zlansp(norm, uplo, n, ap, work)
        fw_iserr__ = 0
      end subroutine zlansp_c
      subroutine zlansy_c(fw_ret_arg, norm, uplo, n, a_shape__, a, lda, 
     &work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlansy
        external zlansy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zlansy(norm, uplo, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine zlansy_c
      subroutine zlantb_c(fw_ret_arg, norm, uplo, diag, n, k, ab_shape__
     &, ab, ldab, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: k
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlantb
        external zlantb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zlantb(norm, uplo, diag, n, k, ab, ldab, work)
        fw_iserr__ = 0
      end subroutine zlantb_c
      subroutine zlantp_c(fw_ret_arg, norm, uplo, diag, n, ap_shape__, a
     &p, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlantp
        external zlantp
        fw_iserr__ = -1
        fw_ret_arg = zlantp(norm, uplo, diag, n, ap, work)
        fw_iserr__ = 0
      end subroutine zlantp_c
      subroutine zlantr_c(fw_ret_arg, norm, uplo, diag, m, n, a_shape__,
     & a, lda, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        real(kind=kind(0.0D0)) :: fw_ret_arg
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        real(kind=kind(0.0D0)) :: zlantr
        external zlantr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        fw_ret_arg = zlantr(norm, uplo, diag, m, n, a, lda, work)
        fw_iserr__ = 0
      end subroutine zlantr_c
      subroutine zlapll_c(n, x_shape__, x, incx, y_shape__, y, incy, ssm
     &in, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        complex*16, dimension(y_shape__(1)) :: y
        integer :: incy
        real(kind=kind(0.0D0)) :: ssmin
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlapll
        fw_iserr__ = -1
        call zlapll(n, x, incx, y, incy, ssmin)
        fw_iserr__ = 0
      end subroutine zlapll_c
      subroutine zlapmr_c(forwrd, m, n, x_shape__, x, ldx, k_shape__, k,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: forwrd
        integer :: m
        integer :: n
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlapmr
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlapmr(forwrd, m, n, x, ldx, k)
        fw_iserr__ = 0
      end subroutine zlapmr_c
      subroutine zlapmt_c(forwrd, m, n, x_shape__, x, ldx, k_shape__, k,
     & fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: forwrd
        integer :: m
        integer :: n
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: k_shape__
        integer, dimension(k_shape__(1)) :: k
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlapmt
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlapmt(forwrd, m, n, x, ldx, k)
        fw_iserr__ = 0
      end subroutine zlapmt_c
      subroutine zlaqgb_c(m, n, kl, ku, ab_shape__, ab, ldab, r_shape__,
     & r, c_shape__, c, rowcnd, colcnd, amax, equed, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: kl
        integer :: ku
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqgb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqgb(m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax, 
     &equed)
        fw_iserr__ = 0
      end subroutine zlaqgb_c
      subroutine zlaqge_c(m, n, a_shape__, a, lda, r_shape__, r, c_shape
     &__, c, rowcnd, colcnd, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: r_shape__
        real(kind=kind(0.0D0)), dimension(r_shape__(1)) :: r
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        real(kind=kind(0.0D0)) :: rowcnd
        real(kind=kind(0.0D0)) :: colcnd
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqge
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqge(m, n, a, lda, r, c, rowcnd, colcnd, amax, equed)
        fw_iserr__ = 0
      end subroutine zlaqge_c
      subroutine zlaqhb_c(uplo, n, kd, ab_shape__, ab, ldab, s_shape__, 
     &s, scond, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqhb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqhb(uplo, n, kd, ab, ldab, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine zlaqhb_c
      subroutine zlaqhe_c(uplo, n, a_shape__, a, lda, s_shape__, s, scon
     &d, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqhe
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqhe(uplo, n, a, lda, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine zlaqhe_c
      subroutine zlaqhp_c(uplo, n, ap_shape__, ap, s_shape__, s, scond, 
     &amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqhp
        fw_iserr__ = -1
        call zlaqhp(uplo, n, ap, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine zlaqhp_c
      subroutine zlaqp2_c(m, n, offset, a_shape__, a, lda, jpvt_shape__,
     & jpvt, tau_shape__, tau, vn1_shape__, vn1, vn2_shape__, vn2, work_
     &shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: offset
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: vn1_shape__
        real(kind=kind(0.0D0)), dimension(vn1_shape__(1)) :: vn1
        integer, dimension(1) :: vn2_shape__
        real(kind=kind(0.0D0)), dimension(vn2_shape__(1)) :: vn2
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqp2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqp2(m, n, offset, a, lda, jpvt, tau, vn1, vn2, work)
        fw_iserr__ = 0
      end subroutine zlaqp2_c
      subroutine zlaqps_c(m, n, offset, nb, kb, a_shape__, a, lda, jpvt_
     &shape__, jpvt, tau_shape__, tau, vn1_shape__, vn1, vn2_shape__, vn
     &2, auxv_shape__, auxv, f_shape__, f, ldf, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: offset
        integer :: nb
        integer :: kb
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: jpvt_shape__
        integer, dimension(jpvt_shape__(1)) :: jpvt
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: vn1_shape__
        real(kind=kind(0.0D0)), dimension(vn1_shape__(1)) :: vn1
        integer, dimension(1) :: vn2_shape__
        real(kind=kind(0.0D0)), dimension(vn2_shape__(1)) :: vn2
        integer, dimension(1) :: auxv_shape__
        complex*16, dimension(auxv_shape__(1)) :: auxv
        integer, dimension(2) :: f_shape__
        complex*16, dimension(f_shape__(1), f_shape__(2)) :: f
        integer :: ldf
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqps
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqps(m, n, offset, nb, kb, a, lda, jpvt, tau, vn1, vn2, a
     &uxv, f, ldf)
        fw_iserr__ = 0
      end subroutine zlaqps_c
      subroutine zlaqr0_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &w_shape__, w, iloz, ihiz, z_shape__, z, ldz, work_shape__, work, l
     &work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqr0
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqr0(wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z,
     & ldz, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zlaqr0_c
      subroutine zlaqr1_c(n, h_shape__, h, ldh, s1, s2, v_shape__, v, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        complex*16 :: s1
        complex*16 :: s2
        integer, dimension(1) :: v_shape__
        complex*16, dimension(v_shape__(1)) :: v
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqr1
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqr1(n, h, ldh, s1, s2, v)
        fw_iserr__ = 0
      end subroutine zlaqr1_c
      subroutine zlaqr2_c(wantt, wantz, n, ktop, kbot, nw, h_shape__, h,
     & ldh, iloz, ihiz, z_shape__, z, ldz, ns, nd, sh_shape__, sh, v_sha
     &pe__, v, ldv, nh, t_shape__, t, ldt, nv, wv_shape__, wv, ldwv, wor
     &k_shape__, work, lwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nw
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: ns
        integer :: nd
        integer, dimension(1) :: sh_shape__
        complex*16, dimension(sh_shape__(1)) :: sh
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer :: nh
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer :: nv
        integer, dimension(2) :: wv_shape__
        complex*16, dimension(wv_shape__(1), wv_shape__(2)) :: wv
        integer :: ldwv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqr2
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqr2(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz,
     & z, ldz, ns, nd, sh, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork
     &)
        fw_iserr__ = 0
      end subroutine zlaqr2_c
      subroutine zlaqr3_c(wantt, wantz, n, ktop, kbot, nw, h_shape__, h,
     & ldh, iloz, ihiz, z_shape__, z, ldz, ns, nd, sh_shape__, sh, v_sha
     &pe__, v, ldv, nh, t_shape__, t, ldt, nv, wv_shape__, wv, ldwv, wor
     &k_shape__, work, lwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nw
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: ns
        integer :: nd
        integer, dimension(1) :: sh_shape__
        complex*16, dimension(sh_shape__(1)) :: sh
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer :: nh
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer :: nv
        integer, dimension(2) :: wv_shape__
        complex*16, dimension(wv_shape__(1), wv_shape__(2)) :: wv
        integer :: ldwv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqr3
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqr3(wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz, ihiz,
     & z, ldz, ns, nd, sh, v, ldv, nh, t, ldt, nv, wv, ldwv, work, lwork
     &)
        fw_iserr__ = 0
      end subroutine zlaqr3_c
      subroutine zlaqr4_c(wantt, wantz, n, ilo, ihi, h_shape__, h, ldh, 
     &w_shape__, w, iloz, ihiz, z_shape__, z, ldz, work_shape__, work, l
     &work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqr4
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqr4(wantt, wantz, n, ilo, ihi, h, ldh, w, iloz, ihiz, z,
     & ldz, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zlaqr4_c
      subroutine zlaqr5_c(wantt, wantz, kacc22, n, ktop, kbot, nshfts, s
     &_shape__, s, h_shape__, h, ldh, iloz, ihiz, z_shape__, z, ldz, v_s
     &hape__, v, ldv, u_shape__, u, ldu, nv, wv_shape__, wv, ldwv, nh, w
     &h_shape__, wh, ldwh, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantt
        integer(kind=kind(0)) :: wantz
        integer :: kacc22
        integer :: n
        integer :: ktop
        integer :: kbot
        integer :: nshfts
        integer, dimension(1) :: s_shape__
        complex*16, dimension(s_shape__(1)) :: s
        integer, dimension(2) :: h_shape__
        complex*16, dimension(h_shape__(1), h_shape__(2)) :: h
        integer :: ldh
        integer :: iloz
        integer :: ihiz
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: u_shape__
        complex*16, dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer :: nv
        integer, dimension(2) :: wv_shape__
        complex*16, dimension(wv_shape__(1), wv_shape__(2)) :: wv
        integer :: ldwv
        integer :: nh
        integer, dimension(2) :: wh_shape__
        complex*16, dimension(wh_shape__(1), wh_shape__(2)) :: wh
        integer :: ldwh
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqr5
        fw_iserr__ = -1
        if ((ldh) .ne. (h_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("h                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwv) .ne. (wv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wv                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwh) .ne. (wh_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("wh                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqr5(wantt, wantz, kacc22, n, ktop, kbot, nshfts, s, h, l
     &dh, iloz, ihiz, z, ldz, v, ldv, u, ldu, nv, wv, ldwv, nh, wh, ldwh
     &)
        fw_iserr__ = 0
      end subroutine zlaqr5_c
      subroutine zlaqsb_c(uplo, n, kd, ab_shape__, ab, ldab, s_shape__, 
     &s, scond, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqsb
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqsb(uplo, n, kd, ab, ldab, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine zlaqsb_c
      subroutine zlaqsp_c(uplo, n, ap_shape__, ap, s_shape__, s, scond, 
     &amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqsp
        fw_iserr__ = -1
        call zlaqsp(uplo, n, ap, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine zlaqsp_c
      subroutine zlaqsy_c(uplo, n, a_shape__, a, lda, s_shape__, s, scon
     &d, amax, equed, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        character(len=1, kind=kind('a')) :: equed
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaqsy
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaqsy(uplo, n, a, lda, s, scond, amax, equed)
        fw_iserr__ = 0
      end subroutine zlaqsy_c
      subroutine zlar1v_c(n, b1, bn, lambda, d_shape__, d, l_shape__, l,
     & ld_shape__, ld, lld_shape__, lld, pivmin, gaptol, z_shape__, z, w
     &antnc, negcnt, ztz, mingma, r, isuppz_shape__, isuppz, nrminv, res
     &id, rqcorr, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: b1
        integer :: bn
        real(kind=kind(0.0D0)) :: lambda
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: l_shape__
        real(kind=kind(0.0D0)), dimension(l_shape__(1)) :: l
        integer, dimension(1) :: ld_shape__
        real(kind=kind(0.0D0)), dimension(ld_shape__(1)) :: ld
        integer, dimension(1) :: lld_shape__
        real(kind=kind(0.0D0)), dimension(lld_shape__(1)) :: lld
        real(kind=kind(0.0D0)) :: pivmin
        real(kind=kind(0.0D0)) :: gaptol
        integer, dimension(1) :: z_shape__
        complex*16, dimension(z_shape__(1)) :: z
        integer(kind=kind(0)) :: wantnc
        integer :: negcnt
        real(kind=kind(0.0D0)) :: ztz
        real(kind=kind(0.0D0)) :: mingma
        integer :: r
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        real(kind=kind(0.0D0)) :: nrminv
        real(kind=kind(0.0D0)) :: resid
        real(kind=kind(0.0D0)) :: rqcorr
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlar1v
        fw_iserr__ = -1
        call zlar1v(n, b1, bn, lambda, d, l, ld, lld, pivmin, gaptol, z,
     & wantnc, negcnt, ztz, mingma, r, isuppz, nrminv, resid, rqcorr, wo
     &rk)
        fw_iserr__ = 0
      end subroutine zlar1v_c
      subroutine zlar2v_c(n, x_shape__, x, y_shape__, y, z_shape__, z, i
     &ncx, c_shape__, c, s_shape__, s, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer, dimension(1) :: y_shape__
        complex*16, dimension(y_shape__(1)) :: y
        integer, dimension(1) :: z_shape__
        complex*16, dimension(z_shape__(1)) :: z
        integer :: incx
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        complex*16, dimension(s_shape__(1)) :: s
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlar2v
        fw_iserr__ = -1
        call zlar2v(n, x, y, z, incx, c, s, incc)
        fw_iserr__ = 0
      end subroutine zlar2v_c
      subroutine zlarcm_c(m, n, a_shape__, a, lda, b_shape__, b, ldb, c_
     &shape__, c, ldc, rwork_shape__, rwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        real(kind=kind(0.0D0)), dimension(a_shape__(1), a_shape__(2)) ::
     & a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarcm
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarcm(m, n, a, lda, b, ldb, c, ldc, rwork)
        fw_iserr__ = 0
      end subroutine zlarcm_c
      subroutine zlarf_c(side, m, n, v_shape__, v, incv, tau, c_shape__,
     & c, ldc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        complex*16, dimension(v_shape__(1)) :: v
        integer :: incv
        complex*16 :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarf
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarf(side, m, n, v, incv, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine zlarf_c
      subroutine zlarfb_c(side, trans, direct, storev, m, n, k, v_shape_
     &_, v, ldv, t_shape__, t, ldt, c_shape__, c, ldc, work_shape__, wor
     &k, ldwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(2) :: work_shape__
        complex*16, dimension(work_shape__(1), work_shape__(2)) :: work
        integer :: ldwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarfb
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarfb(side, trans, direct, storev, m, n, k, v, ldv, t, ldt
     &, c, ldc, work, ldwork)
        fw_iserr__ = 0
      end subroutine zlarfb_c
      subroutine zlarfg_c(n, alpha, x_shape__, x, incx, tau, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        complex*16 :: alpha
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        complex*16 :: tau
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarfg
        fw_iserr__ = -1
        call zlarfg(n, alpha, x, incx, tau)
        fw_iserr__ = 0
      end subroutine zlarfg_c
      subroutine zlarfgp_c(n, alpha, x_shape__, x, incx, tau, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        complex*16 :: alpha
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        complex*16 :: tau
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarfgp
        fw_iserr__ = -1
        call zlarfgp(n, alpha, x, incx, tau)
        fw_iserr__ = 0
      end subroutine zlarfgp_c
      subroutine zlarft_c(direct, storev, n, k, v_shape__, v, ldv, tau_s
     &hape__, tau, t_shape__, t, ldt, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarft
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarft(direct, storev, n, k, v, ldv, tau, t, ldt)
        fw_iserr__ = 0
      end subroutine zlarft_c
      subroutine zlarfx_c(side, m, n, v_shape__, v, tau, c_shape__, c, l
     &dc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        complex*16, dimension(v_shape__(1)) :: v
        complex*16 :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarfx
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarfx(side, m, n, v, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine zlarfx_c
      subroutine zlargv_c(n, x_shape__, x, incx, y_shape__, y, incy, c_s
     &hape__, c, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        complex*16, dimension(y_shape__(1)) :: y
        integer :: incy
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlargv
        fw_iserr__ = -1
        call zlargv(n, x, incx, y, incy, c, incc)
        fw_iserr__ = 0
      end subroutine zlargv_c
      subroutine zlarnv_c(idist, iseed_shape__, iseed, n, x_shape__, x, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: idist
        integer, dimension(1) :: iseed_shape__
        integer, dimension(iseed_shape__(1)) :: iseed
        integer :: n
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarnv
        fw_iserr__ = -1
        if ((4) .lt. 0 .or. (4) .gt. (iseed_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("iseed                               
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarnv(idist, iseed, n, x)
        fw_iserr__ = 0
      end subroutine zlarnv_c
      subroutine zlarrv_c(n, vl, vu, d_shape__, d, l_shape__, l, pivmin,
     & isplit_shape__, isplit, m, dol, dou, minrgp, rtol1, rtol2, w_shap
     &e__, w, werr_shape__, werr, wgap_shape__, wgap, iblock_shape__, ib
     &lock, indexw_shape__, indexw, gers_shape__, gers, z_shape__, z, ld
     &z, isuppz_shape__, isuppz, work_shape__, work, iwork_shape__, iwor
     &k, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: l_shape__
        real(kind=kind(0.0D0)), dimension(l_shape__(1)) :: l
        real(kind=kind(0.0D0)) :: pivmin
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer :: m
        integer :: dol
        integer :: dou
        real(kind=kind(0.0D0)) :: minrgp
        real(kind=kind(0.0D0)) :: rtol1
        real(kind=kind(0.0D0)) :: rtol2
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: werr_shape__
        real(kind=kind(0.0D0)), dimension(werr_shape__(1)) :: werr
        integer, dimension(1) :: wgap_shape__
        real(kind=kind(0.0D0)), dimension(wgap_shape__(1)) :: wgap
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: indexw_shape__
        integer, dimension(indexw_shape__(1)) :: indexw
        integer, dimension(1) :: gers_shape__
        real(kind=kind(0.0D0)), dimension(gers_shape__(1)) :: gers
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarrv
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarrv(n, vl, vu, d, l, pivmin, isplit, m, dol, dou, minrgp
     &, rtol1, rtol2, w, werr, wgap, iblock, indexw, gers, z, ldz, isupp
     &z, work, iwork, info)
        fw_iserr__ = 0
      end subroutine zlarrv_c
      subroutine zlarscl2_c(m, n, d_shape__, d, x_shape__, x, ldx, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarscl2
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarscl2(m, n, d, x, ldx)
        fw_iserr__ = 0
      end subroutine zlarscl2_c
      subroutine zlartg_c(f, g, cs, sn, r, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        complex*16 :: f
        complex*16 :: g
        real(kind=kind(0.0D0)) :: cs
        complex*16 :: sn
        complex*16 :: r
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlartg
        fw_iserr__ = -1
        call zlartg(f, g, cs, sn, r)
        fw_iserr__ = 0
      end subroutine zlartg_c
      subroutine zlartv_c(n, x_shape__, x, incx, y_shape__, y, incy, c_s
     &hape__, c, s_shape__, s, incc, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: y_shape__
        complex*16, dimension(y_shape__(1)) :: y
        integer :: incy
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        complex*16, dimension(s_shape__(1)) :: s
        integer :: incc
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlartv
        fw_iserr__ = -1
        call zlartv(n, x, incx, y, incy, c, s, incc)
        fw_iserr__ = 0
      end subroutine zlartv_c
      subroutine zlarz_c(side, m, n, l, v_shape__, v, incv, tau, c_shape
     &__, c, ldc, work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer :: l
        integer, dimension(1) :: v_shape__
        complex*16, dimension(v_shape__(1)) :: v
        integer :: incv
        complex*16 :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarz
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarz(side, m, n, l, v, incv, tau, c, ldc, work)
        fw_iserr__ = 0
      end subroutine zlarz_c
      subroutine zlarzb_c(side, trans, direct, storev, m, n, k, l, v_sha
     &pe__, v, ldv, t_shape__, t, ldt, c_shape__, c, ldc, work_shape__, 
     &work, ldwork, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(2) :: work_shape__
        complex*16, dimension(work_shape__(1), work_shape__(2)) :: work
        integer :: ldwork
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarzb
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarzb(side, trans, direct, storev, m, n, k, l, v, ldv, t, 
     &ldt, c, ldc, work, ldwork)
        fw_iserr__ = 0
      end subroutine zlarzb_c
      subroutine zlarzt_c(direct, storev, n, k, v_shape__, v, ldv, tau_s
     &hape__, tau, t_shape__, t, ldt, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: direct
        character(len=1, kind=kind('a')) :: storev
        integer :: n
        integer :: k
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlarzt
        fw_iserr__ = -1
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlarzt(direct, storev, n, k, v, ldv, tau, t, ldt)
        fw_iserr__ = 0
      end subroutine zlarzt_c
      subroutine zlascl_c(type, kl, ku, cfrom, cto, m, n, a_shape__, a, 
     &lda, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: type
        integer :: kl
        integer :: ku
        real(kind=kind(0.0D0)) :: cfrom
        real(kind=kind(0.0D0)) :: cto
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlascl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlascl(type, kl, ku, cfrom, cto, m, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine zlascl_c
      subroutine zlascl2_c(m, n, d_shape__, d, x_shape__, x, ldx, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlascl2
        fw_iserr__ = -1
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlascl2(m, n, d, x, ldx)
        fw_iserr__ = 0
      end subroutine zlascl2_c
      subroutine zlaset_c(uplo, m, n, alpha, beta, a_shape__, a, lda, fw
     &_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: m
        integer :: n
        complex*16 :: alpha
        complex*16 :: beta
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaset
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaset(uplo, m, n, alpha, beta, a, lda)
        fw_iserr__ = 0
      end subroutine zlaset_c
      subroutine zlasr_c(side, pivot, direct, m, n, c_shape__, c, s_shap
     &e__, s, a_shape__, a, lda, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: pivot
        character(len=1, kind=kind('a')) :: direct
        integer :: m
        integer :: n
        integer, dimension(1) :: c_shape__
        real(kind=kind(0.0D0)), dimension(c_shape__(1)) :: c
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlasr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlasr(side, pivot, direct, m, n, c, s, a, lda)
        fw_iserr__ = 0
      end subroutine zlasr_c
      subroutine zlassq_c(n, x_shape__, x, incx, scale, sumsq, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        real(kind=kind(0.0D0)) :: scale
        real(kind=kind(0.0D0)) :: sumsq
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlassq
        fw_iserr__ = -1
        call zlassq(n, x, incx, scale, sumsq)
        fw_iserr__ = 0
      end subroutine zlassq_c
      subroutine zlaswp_c(n, a_shape__, a, lda, k1, k2, ipiv_shape__, ip
     &iv, incx, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: k1
        integer :: k2
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: incx
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlaswp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlaswp(n, a, lda, k1, k2, ipiv, incx)
        fw_iserr__ = 0
      end subroutine zlaswp_c
      subroutine zlasyf_c(uplo, n, nb, kb, a_shape__, a, lda, ipiv_shape
     &__, ipiv, w_shape__, w, ldw, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nb
        integer :: kb
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: w_shape__
        complex*16, dimension(w_shape__(1), w_shape__(2)) :: w
        integer :: ldw
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlasyf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldw) .ne. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlasyf(uplo, n, nb, kb, a, lda, ipiv, w, ldw, info)
        fw_iserr__ = 0
      end subroutine zlasyf_c
      subroutine zlat2c_c(uplo, n, a_shape__, a, lda, sa_shape__, sa, ld
     &sa, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: sa_shape__
        complex(kind=kind((0.0,0.0))), dimension(sa_shape__(1), sa_shape
     &__(2)) :: sa
        integer :: ldsa
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlat2c
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldsa) .ne. (sa_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("sa                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlat2c(uplo, n, a, lda, sa, ldsa, info)
        fw_iserr__ = 0
      end subroutine zlat2c_c
      subroutine zlatbs_c(uplo, trans, diag, normin, n, kd, ab_shape__, 
     &ab, ldab, x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        real(kind=kind(0.0D0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0D0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlatbs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlatbs(uplo, trans, diag, normin, n, kd, ab, ldab, x, scale
     &, cnorm, info)
        fw_iserr__ = 0
      end subroutine zlatbs_c
      subroutine zlatdf_c(ijob, n, z_shape__, z, ldz, rhs_shape__, rhs, 
     &rdsum, rdscal, ipiv_shape__, ipiv, jpiv_shape__, jpiv, fw_iserr__,
     & fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: ijob
        integer :: n
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: rhs_shape__
        complex*16, dimension(rhs_shape__(1)) :: rhs
        real(kind=kind(0.0D0)) :: rdsum
        real(kind=kind(0.0D0)) :: rdscal
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: jpiv_shape__
        integer, dimension(jpiv_shape__(1)) :: jpiv
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlatdf
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlatdf(ijob, n, z, ldz, rhs, rdsum, rdscal, ipiv, jpiv)
        fw_iserr__ = 0
      end subroutine zlatdf_c
      subroutine zlatps_c(uplo, trans, diag, normin, n, ap_shape__, ap, 
     &x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        real(kind=kind(0.0D0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0D0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlatps
        fw_iserr__ = -1
        call zlatps(uplo, trans, diag, normin, n, ap, x, scale, cnorm, i
     &nfo)
        fw_iserr__ = 0
      end subroutine zlatps_c
      subroutine zlatrd_c(uplo, n, nb, a_shape__, a, lda, e_shape__, e, 
     &tau_shape__, tau, w_shape__, w, ldw, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nb
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: w_shape__
        complex*16, dimension(w_shape__(1), w_shape__(2)) :: w
        integer :: ldw
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlatrd
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldw) .ne. (w_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("w                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlatrd(uplo, n, nb, a, lda, e, tau, w, ldw)
        fw_iserr__ = 0
      end subroutine zlatrd_c
      subroutine zlatrs_c(uplo, trans, diag, normin, n, a_shape__, a, ld
     &a, x_shape__, x, scale, cnorm_shape__, cnorm, info, fw_iserr__, fw
     &_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        character(len=1, kind=kind('a')) :: normin
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        real(kind=kind(0.0D0)) :: scale
        integer, dimension(1) :: cnorm_shape__
        real(kind=kind(0.0D0)), dimension(cnorm_shape__(1)) :: cnorm
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlatrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlatrs(uplo, trans, diag, normin, n, a, lda, x, scale, cnor
     &m, info)
        fw_iserr__ = 0
      end subroutine zlatrs_c
      subroutine zlatrz_c(m, n, l, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: l
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlatrz
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlatrz(m, n, l, a, lda, tau, work)
        fw_iserr__ = 0
      end subroutine zlatrz_c
      subroutine zlatzm_c(side, m, n, v_shape__, v, incv, tau, c1_shape_
     &_, c1, c2_shape__, c2, ldc, work_shape__, work, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        integer :: m
        integer :: n
        integer, dimension(1) :: v_shape__
        complex*16, dimension(v_shape__(1)) :: v
        integer :: incv
        complex*16 :: tau
        integer, dimension(2) :: c1_shape__
        complex*16, dimension(c1_shape__(1), c1_shape__(2)) :: c1
        integer, dimension(2) :: c2_shape__
        complex*16, dimension(c2_shape__(1), c2_shape__(2)) :: c2
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlatzm
        fw_iserr__ = -1
        if ((ldc) .ne. (c1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlatzm(side, m, n, v, incv, tau, c1, c2, ldc, work)
        fw_iserr__ = 0
      end subroutine zlatzm_c
      subroutine zlauu2_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlauu2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlauu2(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine zlauu2_c
      subroutine zlauum_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zlauum
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zlauum(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine zlauum_c
      subroutine zpbcon_c(uplo, n, kd, ab_shape__, ab, ldab, anorm, rcon
     &d, work_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpbcon(uplo, n, kd, ab, ldab, anorm, rcond, work, rwork, in
     &fo)
        fw_iserr__ = 0
      end subroutine zpbcon_c
      subroutine zpbequ_c(uplo, n, kd, ab_shape__, ab, ldab, s_shape__, 
     &s, scond, amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpbequ
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpbequ(uplo, n, kd, ab, ldab, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine zpbequ_c
      subroutine zpbrfs_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, afb_s
     &hape__, afb, ldafb, b_shape__, b, ldb, x_shape__, x, ldx, ferr_sha
     &pe__, ferr, berr_shape__, berr, work_shape__, work, rwork_shape__,
     & rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex*16, dimension(afb_shape__(1), afb_shape__(2)) :: afb
        integer :: ldafb
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpbrfs(uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, 
     &ldx, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zpbrfs_c
      subroutine zpbstf_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpbstf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpbstf(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine zpbstf_c
      subroutine zpbsv_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, b_shap
     &e__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpbsv
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpbsv(uplo, n, kd, nrhs, ab, ldab, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zpbsv_c
      subroutine zpbsvx_c(fact, uplo, n, kd, nrhs, ab_shape__, ab, ldab,
     & afb_shape__, afb, ldafb, equed, s_shape__, s, b_shape__, b, ldb, 
     &x_shape__, x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, 
     &work_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_err
     &str__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: afb_shape__
        complex*16, dimension(afb_shape__(1), afb_shape__(2)) :: afb
        integer :: ldafb
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpbsvx
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldafb) .ne. (afb_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("afb                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpbsvx(fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed
     &, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zpbsvx_c
      subroutine zpbtf2_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpbtf2
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpbtf2(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine zpbtf2_c
      subroutine zpbtrf_c(uplo, n, kd, ab_shape__, ab, ldab, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpbtrf
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpbtrf(uplo, n, kd, ab, ldab, info)
        fw_iserr__ = 0
      end subroutine zpbtrf_c
      subroutine zpbtrs_c(uplo, n, kd, nrhs, ab_shape__, ab, ldab, b_sha
     &pe__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpbtrs(uplo, n, kd, nrhs, ab, ldab, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zpbtrs_c
      subroutine zpftrf_c(transr, uplo, n, a_shape__, a, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        complex*16, dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpftrf
        fw_iserr__ = -1
        call zpftrf(transr, uplo, n, a, info)
        fw_iserr__ = 0
      end subroutine zpftrf_c
      subroutine zpftri_c(transr, uplo, n, a_shape__, a, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: a_shape__
        complex*16, dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpftri
        fw_iserr__ = -1
        call zpftri(transr, uplo, n, a, info)
        fw_iserr__ = 0
      end subroutine zpftri_c
      subroutine zpftrs_c(transr, uplo, n, nrhs, a_shape__, a, b_shape__
     &, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: a_shape__
        complex*16, dimension(a_shape__(1)) :: a
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpftrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpftrs(transr, uplo, n, nrhs, a, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zpftrs_c
      subroutine zpocon_c(uplo, n, a_shape__, a, lda, anorm, rcond, work
     &_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpocon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpocon(uplo, n, a, lda, anorm, rcond, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zpocon_c
      subroutine zpoequ_c(n, a_shape__, a, lda, s_shape__, s, scond, ama
     &x, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpoequ
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpoequ(n, a, lda, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine zpoequ_c
      subroutine zpoequb_c(n, a_shape__, a, lda, s_shape__, s, scond, am
     &ax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpoequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpoequb(n, a, lda, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine zpoequb_c
      subroutine zporfs_c(uplo, n, nrhs, a_shape__, a, lda, af_shape__, 
     &af, ldaf, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr
     &, berr_shape__, berr, work_shape__, work, rwork_shape__, rwork, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zporfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zporfs(uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, fer
     &r, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zporfs_c
      subroutine zporfsx_c(uplo, equed, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, s_shape__, s, b_shape__, b, ldb, x_shape__, x, l
     &dx, rcond, berr_shape__, berr, n_err_bnds, err_bnds_norm_shape__, 
     &err_bnds_norm, err_bnds_comp_shape__, err_bnds_comp, nparams, para
     &ms_shape__, params, work_shape__, work, rwork_shape__, rwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zporfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zporfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, 
     &x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, npa
     &rams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zporfsx_c
      subroutine zposv_c(uplo, n, nrhs, a_shape__, a, lda, b_shape__, b,
     & ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zposv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zposv(uplo, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zposv_c
      subroutine zposvx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sha
     &pe__, af, ldaf, equed, s_shape__, s, b_shape__, b, ldb, x_shape__,
     & x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape
     &__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zposvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zposvx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, 
     &ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zposvx_c
      subroutine zposvxx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, equed, s_shape__, s, b_shape__, b, ldb, x_shape__
     &, x, ldx, rcond, rpvgrw, berr_shape__, berr, n_err_bnds, err_bnds_
     &norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bnds_comp,
     & nparams, params_shape__, params, work_shape__, work, rwork_shape_
     &_, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        real(kind=kind(0.0D0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zposvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zposvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b,
     & ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_
     &bnds_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zposvxx_c
      subroutine zpotf2_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpotf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpotf2(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine zpotf2_c
      subroutine zpotrf_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpotrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpotrf(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine zpotrf_c
      subroutine zpotri_c(uplo, n, a_shape__, a, lda, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpotri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpotri(uplo, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine zpotri_c
      subroutine zpotrs_c(uplo, n, nrhs, a_shape__, a, lda, b_shape__, b
     &, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpotrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpotrs(uplo, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zpotrs_c
      subroutine zppcon_c(uplo, n, ap_shape__, ap, anorm, rcond, work_sh
     &ape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zppcon
        fw_iserr__ = -1
        call zppcon(uplo, n, ap, anorm, rcond, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zppcon_c
      subroutine zppequ_c(uplo, n, ap_shape__, ap, s_shape__, s, scond, 
     &amax, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zppequ
        fw_iserr__ = -1
        call zppequ(uplo, n, ap, s, scond, amax, info)
        fw_iserr__ = 0
      end subroutine zppequ_c
      subroutine zpprfs_c(uplo, n, nrhs, ap_shape__, ap, afp_shape__, af
     &p, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_
     &shape__, berr, work_shape__, work, rwork_shape__, rwork, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex*16, dimension(afp_shape__(1)) :: afp
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpprfs(uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, 
     &work, rwork, info)
        fw_iserr__ = 0
      end subroutine zpprfs_c
      subroutine zppsv_c(uplo, n, nrhs, ap_shape__, ap, b_shape__, b, ld
     &b, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zppsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zppsv(uplo, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zppsv_c
      subroutine zppsvx_c(fact, uplo, n, nrhs, ap_shape__, ap, afp_shape
     &__, afp, equed, s_shape__, s, b_shape__, b, ldb, x_shape__, x, ldx
     &, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, wor
     &k, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex*16, dimension(afp_shape__(1)) :: afp
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zppsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zppsvx(fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, l
     &dx, rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zppsvx_c
      subroutine zpptrf_c(uplo, n, ap_shape__, ap, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpptrf
        fw_iserr__ = -1
        call zpptrf(uplo, n, ap, info)
        fw_iserr__ = 0
      end subroutine zpptrf_c
      subroutine zpptri_c(uplo, n, ap_shape__, ap, info, fw_iserr__, fw_
     &errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpptri
        fw_iserr__ = -1
        call zpptri(uplo, n, ap, info)
        fw_iserr__ = 0
      end subroutine zpptri_c
      subroutine zpptrs_c(uplo, n, nrhs, ap_shape__, ap, b_shape__, b, l
     &db, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpptrs(uplo, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zpptrs_c
      subroutine zpstf2_c(uplo, n, a_shape__, a, lda, piv_shape__, piv, 
     &rank, tol, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: piv_shape__
        integer, dimension(piv_shape__(1)) :: piv
        integer :: rank
        real(kind=kind(0.0D0)) :: tol
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpstf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (piv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("piv                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2*n) .lt. 0 .or. (2*n) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpstf2(uplo, n, a, lda, piv, rank, tol, work, info)
        fw_iserr__ = 0
      end subroutine zpstf2_c
      subroutine zpstrf_c(uplo, n, a_shape__, a, lda, piv_shape__, piv, 
     &rank, tol, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: piv_shape__
        integer, dimension(piv_shape__(1)) :: piv
        integer :: rank
        real(kind=kind(0.0D0)) :: tol
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpstrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n) .lt. 0 .or. (n) .gt. (piv_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("piv                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((2*n) .lt. 0 .or. (2*n) .gt. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpstrf(uplo, n, a, lda, piv, rank, tol, work, info)
        fw_iserr__ = 0
      end subroutine zpstrf_c
      subroutine zptcon_c(n, d_shape__, d, e_shape__, e, anorm, rcond, r
     &work_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex*16, dimension(e_shape__(1)) :: e
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zptcon
        fw_iserr__ = -1
        call zptcon(n, d, e, anorm, rcond, rwork, info)
        fw_iserr__ = 0
      end subroutine zptcon_c
      subroutine zpteqr_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpteqr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpteqr(compz, n, d, e, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine zpteqr_c
      subroutine zptrfs_c(uplo, n, nrhs, d_shape__, d, e_shape__, e, df_
     &shape__, df, ef_shape__, ef, b_shape__, b, ldb, x_shape__, x, ldx,
     & ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, rwork
     &_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex*16, dimension(e_shape__(1)) :: e
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0D0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: ef_shape__
        complex*16, dimension(ef_shape__(1)) :: ef
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zptrfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zptrfs(uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, b
     &err, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zptrfs_c
      subroutine zptsv_c(n, nrhs, d_shape__, d, e_shape__, e, b_shape__,
     & b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex*16, dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zptsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zptsv(n, nrhs, d, e, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zptsv_c
      subroutine zptsvx_c(fact, n, nrhs, d_shape__, d, e_shape__, e, df_
     &shape__, df, ef_shape__, ef, b_shape__, b, ldb, x_shape__, x, ldx,
     & rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work
     &, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex*16, dimension(e_shape__(1)) :: e
        integer, dimension(1) :: df_shape__
        real(kind=kind(0.0D0)), dimension(df_shape__(1)) :: df
        integer, dimension(1) :: ef_shape__
        complex*16, dimension(ef_shape__(1)) :: ef
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zptsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, 
     &ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zptsvx_c
      subroutine zpttrf_c(n, d_shape__, d, e_shape__, e, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex*16, dimension(e_shape__(1)) :: e
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpttrf
        fw_iserr__ = -1
        call zpttrf(n, d, e, info)
        fw_iserr__ = 0
      end subroutine zpttrf_c
      subroutine zpttrs_c(uplo, n, nrhs, d_shape__, d, e_shape__, e, b_s
     &hape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex*16, dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zpttrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zpttrs(uplo, n, nrhs, d, e, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zpttrs_c
      subroutine zptts2_c(iuplo, n, nrhs, d_shape__, d, e_shape__, e, b_
     &shape__, b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: iuplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        complex*16, dimension(e_shape__(1)) :: e
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zptts2
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zptts2(iuplo, n, nrhs, d, e, b, ldb)
        fw_iserr__ = 0
      end subroutine zptts2_c
      subroutine zrot_c(n, cx_shape__, cx, incx, cy_shape__, cy, incy, c
     &, s, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: cx_shape__
        complex*16, dimension(cx_shape__(1)) :: cx
        integer :: incx
        integer, dimension(1) :: cy_shape__
        complex*16, dimension(cy_shape__(1)) :: cy
        integer :: incy
        real(kind=kind(0.0D0)) :: c
        complex*16 :: s
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zrot
        fw_iserr__ = -1
        call zrot(n, cx, incx, cy, incy, c, s)
        fw_iserr__ = 0
      end subroutine zrot_c
      subroutine zspcon_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, a
     &norm, rcond, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zspcon
        fw_iserr__ = -1
        call zspcon(uplo, n, ap, ipiv, anorm, rcond, work, info)
        fw_iserr__ = 0
      end subroutine zspcon_c
      subroutine zspmv_c(uplo, n, alpha, ap_shape__, ap, x_shape__, x, i
     &ncx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        complex*16 :: alpha
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        complex*16 :: beta
        integer, dimension(1) :: y_shape__
        complex*16, dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zspmv
        fw_iserr__ = -1
        call zspmv(uplo, n, alpha, ap, x, incx, beta, y, incy)
        fw_iserr__ = 0
      end subroutine zspmv_c
      subroutine zspr_c(uplo, n, alpha, x_shape__, x, incx, ap_shape__, 
     &ap, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        complex*16 :: alpha
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zspr
        fw_iserr__ = -1
        call zspr(uplo, n, alpha, x, incx, ap)
        fw_iserr__ = 0
      end subroutine zspr_c
      subroutine zsprfs_c(uplo, n, nrhs, ap_shape__, ap, afp_shape__, af
     &p, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx, ferr_
     &shape__, ferr, berr_shape__, berr, work_shape__, work, rwork_shape
     &__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex*16, dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsprfs(uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, 
     &berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zsprfs_c
      subroutine zspsv_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, ip
     &iv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zspsv
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zspsv(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zspsv_c
      subroutine zspsvx_c(fact, uplo, n, nrhs, ap_shape__, ap, afp_shape
     &__, afp, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx,
     & rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work
     &, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: afp_shape__
        complex*16, dimension(afp_shape__(1)) :: afp
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zspsvx
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zspsvx(fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, 
     &rcond, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zspsvx_c
      subroutine zsptrf_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsptrf
        fw_iserr__ = -1
        call zsptrf(uplo, n, ap, ipiv, info)
        fw_iserr__ = 0
      end subroutine zsptrf_c
      subroutine zsptri_c(uplo, n, ap_shape__, ap, ipiv_shape__, ipiv, w
     &ork_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsptri
        fw_iserr__ = -1
        call zsptri(uplo, n, ap, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine zsptri_c
      subroutine zsptrs_c(uplo, n, nrhs, ap_shape__, ap, ipiv_shape__, i
     &piv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsptrs(uplo, n, nrhs, ap, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zsptrs_c
      subroutine zstedc_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, lwork, rwork_shape__, rwork, lrwork
     &, iwork_shape__, iwork, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zstedc
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zstedc(compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, 
     &iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine zstedc_c
      subroutine zstegr_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, abstol, m, w_shape__, w, z_shape__, z, ldz, isuppz_s
     &hape__, isuppz, work_shape__, work, lwork, iwork_shape__, iwork, l
     &iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        real(kind=kind(0.0D0)) :: abstol
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zstegr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zstegr(jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, 
     &z, ldz, isuppz, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine zstegr_c
      subroutine zstein_c(n, d_shape__, d, e_shape__, e, m, w_shape__, w
     &, iblock_shape__, iblock, isplit_shape__, isplit, z_shape__, z, ld
     &z, work_shape__, work, iwork_shape__, iwork, ifail_shape__, ifail,
     & info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(1) :: iblock_shape__
        integer, dimension(iblock_shape__(1)) :: iblock
        integer, dimension(1) :: isplit_shape__
        integer, dimension(isplit_shape__(1)) :: isplit
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer, dimension(1) :: ifail_shape__
        integer, dimension(ifail_shape__(1)) :: ifail
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zstein
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zstein(n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, 
     &ifail, info)
        fw_iserr__ = 0
      end subroutine zstein_c
      subroutine zstemr_c(jobz, range, n, d_shape__, d, e_shape__, e, vl
     &, vu, il, iu, m, w_shape__, w, z_shape__, z, ldz, nzc, isuppz_shap
     &e__, isuppz, tryrac, work_shape__, work, lwork, iwork_shape__, iwo
     &rk, liwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobz
        character(len=1, kind=kind('a')) :: range
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        real(kind=kind(0.0D0)) :: vl
        real(kind=kind(0.0D0)) :: vu
        integer :: il
        integer :: iu
        integer :: m
        integer, dimension(1) :: w_shape__
        real(kind=kind(0.0D0)), dimension(w_shape__(1)) :: w
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: nzc
        integer, dimension(1) :: isuppz_shape__
        integer, dimension(isuppz_shape__(1)) :: isuppz
        integer(kind=kind(0)) :: tryrac
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zstemr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zstemr(jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, 
     &nzc, isuppz, tryrac, work, lwork, iwork, liwork, info)
        fw_iserr__ = 0
      end subroutine zstemr_c
      subroutine zsteqr_c(compz, n, d_shape__, d, e_shape__, e, z_shape_
     &_, z, ldz, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compz
        integer :: n
        integer, dimension(1) :: d_shape__
        real(kind=kind(0.0D0)), dimension(d_shape__(1)) :: d
        integer, dimension(1) :: e_shape__
        real(kind=kind(0.0D0)), dimension(e_shape__(1)) :: e
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer, dimension(1) :: work_shape__
        real(kind=kind(0.0D0)), dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsteqr
        fw_iserr__ = -1
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsteqr(compz, n, d, e, z, ldz, work, info)
        fw_iserr__ = 0
      end subroutine zsteqr_c
      subroutine zsycon_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, anorm, rcond, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        real(kind=kind(0.0D0)) :: anorm
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsycon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsycon(uplo, n, a, lda, ipiv, anorm, rcond, work, info)
        fw_iserr__ = 0
      end subroutine zsycon_c
      subroutine zsyconv_c(uplo, way, n, a_shape__, a, lda, ipiv_shape__
     &, ipiv, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: way
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(a_shape__(1), a_sha
     &pe__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(work_shape__(1)) ::
     & work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsyconv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsyconv(uplo, way, n, a, lda, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine zsyconv_c
      subroutine zsyequb_c(uplo, n, a_shape__, a, lda, s_shape__, s, sco
     &nd, amax, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        real(kind=kind(0.0D0)) :: scond
        real(kind=kind(0.0D0)) :: amax
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsyequb
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsyequb(uplo, n, a, lda, s, scond, amax, work, info)
        fw_iserr__ = 0
      end subroutine zsyequb_c
      subroutine zsymv_c(uplo, n, alpha, a_shape__, a, lda, x_shape__, x
     &, incx, beta, y_shape__, y, incy, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        complex*16 :: alpha
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        complex*16 :: beta
        integer, dimension(1) :: y_shape__
        complex*16, dimension(y_shape__(1)) :: y
        integer :: incy
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsymv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsymv(uplo, n, alpha, a, lda, x, incx, beta, y, incy)
        fw_iserr__ = 0
      end subroutine zsymv_c
      subroutine zsyr_c(uplo, n, alpha, x_shape__, x, incx, a_shape__, a
     &, lda, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        complex*16 :: alpha
        integer, dimension(1) :: x_shape__
        complex*16, dimension(x_shape__(1)) :: x
        integer :: incx
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsyr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsyr(uplo, n, alpha, x, incx, a, lda)
        fw_iserr__ = 0
      end subroutine zsyr_c
      subroutine zsyrfs_c(uplo, n, nrhs, a_shape__, a, lda, af_shape__, 
     &af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, x, ldx
     &, ferr_shape__, ferr, berr_shape__, berr, work_shape__, work, rwor
     &k_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsyrfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsyrfs(uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ld
     &x, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zsyrfs_c
      subroutine zsyrfsx_c(uplo, equed, n, nrhs, a_shape__, a, lda, af_s
     &hape__, af, ldaf, ipiv_shape__, ipiv, s_shape__, s, b_shape__, b, 
     &ldb, x_shape__, x, ldx, rcond, berr_shape__, berr, n_err_bnds, err
     &_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_shape__, err_bnds
     &_comp, nparams, params_shape__, params, work_shape__, work, rwork_
     &shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: equed
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsyrfsx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsyrfsx(uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b,
     & ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_com
     &p, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zsyrfsx_c
      subroutine zsysv_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__,
     & ipiv, b_shape__, b, ldb, work_shape__, work, lwork, info, fw_iser
     &r__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsysv
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsysv(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine zsysv_c
      subroutine zsysvx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sha
     &pe__, af, ldaf, ipiv_shape__, ipiv, b_shape__, b, ldb, x_shape__, 
     &x, ldx, rcond, ferr_shape__, ferr, berr_shape__, berr, work_shape_
     &_, work, lwork, rwork_shape__, rwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsysvx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsysvx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,
     & x, ldx, rcond, ferr, berr, work, lwork, rwork, info)
        fw_iserr__ = 0
      end subroutine zsysvx_c
      subroutine zsysvxx_c(fact, uplo, n, nrhs, a_shape__, a, lda, af_sh
     &ape__, af, ldaf, ipiv_shape__, ipiv, equed, s_shape__, s, b_shape_
     &_, b, ldb, x_shape__, x, ldx, rcond, rpvgrw, berr_shape__, berr, n
     &_err_bnds, err_bnds_norm_shape__, err_bnds_norm, err_bnds_comp_sha
     &pe__, err_bnds_comp, nparams, params_shape__, params, work_shape__
     &, work, rwork_shape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: fact
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: af_shape__
        complex*16, dimension(af_shape__(1), af_shape__(2)) :: af
        integer :: ldaf
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        character(len=1, kind=kind('a')) :: equed
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        real(kind=kind(0.0D0)) :: rcond
        real(kind=kind(0.0D0)) :: rpvgrw
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer :: n_err_bnds
        integer, dimension(2) :: err_bnds_norm_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_norm_shape__(1), err_
     &bnds_norm_shape__(2)) :: err_bnds_norm
        integer, dimension(2) :: err_bnds_comp_shape__
        real(kind=kind(0.0D0)), dimension(err_bnds_comp_shape__(1), err_
     &bnds_comp_shape__(2)) :: err_bnds_comp
        integer :: nparams
        integer, dimension(1) :: params_shape__
        real(kind=kind(0.0D0)), dimension(params_shape__(1)) :: params
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsysvxx
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldaf) .ne. (af_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("af                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_norm_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_norm                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((nrhs) .ne. (err_bnds_comp_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("err_bnds_comp                       
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsysvxx(fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed,
     & s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm
     &, err_bnds_comp, nparams, params, work, rwork, info)
        fw_iserr__ = 0
      end subroutine zsysvxx_c
      subroutine zsyswapr_c(uplo, n, a_shape__, a, i1, i2, fw_iserr__, f
     &w_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(a_shape__(1), a_sha
     &pe__(2)) :: a
        integer :: i1
        integer :: i2
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsyswapr
        fw_iserr__ = -1
        if ((n) .ne. (a_shape__(1)) .or. (n) .lt. 0 .or. (n) .gt. (a_sha
     &pe__(2))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsyswapr(uplo, n, a, i1, i2)
        fw_iserr__ = 0
      end subroutine zsyswapr_c
      subroutine zsytf2_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsytf2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsytf2(uplo, n, a, lda, ipiv, info)
        fw_iserr__ = 0
      end subroutine zsytf2_c
      subroutine zsytrf_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsytrf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsytrf(uplo, n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zsytrf_c
      subroutine zsytri_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipiv
     &, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsytri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsytri(uplo, n, a, lda, ipiv, work, info)
        fw_iserr__ = 0
      end subroutine zsytri_c
      subroutine zsytri2_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ipi
     &v, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(a_shape__(1), a_sha
     &pe__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(work_shape__(1)) ::
     & work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsytri2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsytri2(uplo, n, a, lda, ipiv, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zsytri2_c
      subroutine zsytri2x_c(uplo, n, a_shape__, a, lda, ipiv_shape__, ip
     &iv, work_shape__, work, nb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(a_shape__(1), a_sha
     &pe__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: work_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(work_shape__(1), wo
     &rk_shape__(2)) :: work
        integer :: nb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsytri2x
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((n+nb+1) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsytri2x(uplo, n, a, lda, ipiv, work, nb, info)
        fw_iserr__ = 0
      end subroutine zsytri2x_c
      subroutine zsytrs_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape__
     &, ipiv, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsytrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsytrs(uplo, n, nrhs, a, lda, ipiv, b, ldb, info)
        fw_iserr__ = 0
      end subroutine zsytrs_c
      subroutine zsytrs2_c(uplo, n, nrhs, a_shape__, a, lda, ipiv_shape_
     &_, ipiv, b_shape__, b, ldb, work_shape__, work, info, fw_iserr__, 
     &fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(a_shape__(1), a_sha
     &pe__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ipiv_shape__
        integer, dimension(ipiv_shape__(1)) :: ipiv
        integer, dimension(2) :: b_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(b_shape__(1), b_sha
     &pe__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: work_shape__
        complex(kind=kind((0.0D0,0.0D0))), dimension(work_shape__(1)) ::
     & work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zsytrs2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zsytrs2(uplo, n, nrhs, a, lda, ipiv, b, ldb, work, info)
        fw_iserr__ = 0
      end subroutine zsytrs2_c
      subroutine ztbcon_c(norm, uplo, diag, n, kd, ab_shape__, ab, ldab,
     & rcond, work_shape__, work, rwork_shape__, rwork, info, fw_iserr__
     &, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztbcon
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztbcon(norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwor
     &k, info)
        fw_iserr__ = 0
      end subroutine ztbcon_c
      subroutine ztbrfs_c(uplo, trans, diag, n, kd, nrhs, ab_shape__, ab
     &, ldab, b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, 
     &berr_shape__, berr, work_shape__, work, rwork_shape__, rwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztbrfs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztbrfs(uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x,
     & ldx, ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ztbrfs_c
      subroutine ztbtrs_c(uplo, trans, diag, n, kd, nrhs, ab_shape__, ab
     &, ldab, b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: kd
        integer :: nrhs
        integer, dimension(2) :: ab_shape__
        complex*16, dimension(ab_shape__(1), ab_shape__(2)) :: ab
        integer :: ldab
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztbtrs
        fw_iserr__ = -1
        if ((ldab) .ne. (ab_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("ab                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztbtrs(uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, in
     &fo)
        fw_iserr__ = 0
      end subroutine ztbtrs_c
      subroutine ztfsm_c(transr, side, uplo, trans, diag, m, n, alpha, a
     &_shape__, a, b_shape__, b, ldb, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: m
        integer :: n
        complex*16 :: alpha
        integer, dimension(1) :: a_shape__
        complex*16, dimension(a_shape__(1)) :: a
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztfsm
        fw_iserr__ = -1
        if (((ldb-1) - (0) + 1) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztfsm(transr, side, uplo, trans, diag, m, n, alpha, a, b, l
     &db)
        fw_iserr__ = 0
      end subroutine ztfsm_c
      subroutine ztftri_c(transr, uplo, diag, n, a_shape__, a, info, fw_
     &iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: a_shape__
        complex*16, dimension(a_shape__(1)) :: a
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztftri
        fw_iserr__ = -1
        call ztftri(transr, uplo, diag, n, a, info)
        fw_iserr__ = 0
      end subroutine ztftri_c
      subroutine ztfttp_c(transr, uplo, n, arf_shape__, arf, ap_shape__,
     & ap, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: arf_shape__
        complex*16, dimension(arf_shape__(1)) :: arf
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztfttp
        fw_iserr__ = -1
        call ztfttp(transr, uplo, n, arf, ap, info)
        fw_iserr__ = 0
      end subroutine ztfttp_c
      subroutine ztfttr_c(transr, uplo, n, arf_shape__, arf, a_shape__, 
     &a, lda, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: arf_shape__
        complex*16, dimension(arf_shape__(1)) :: arf
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztfttr
        fw_iserr__ = -1
        if (((lda-1) - (0) + 1) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztfttr(transr, uplo, n, arf, a, lda, info)
        fw_iserr__ = 0
      end subroutine ztfttr_c
      subroutine ztgevc_c(side, howmny, select_shape__, select, n, s_sha
     &pe__, s, lds, p_shape__, p, ldp, vl_shape__, vl, ldvl, vr_shape__,
     & vr, ldvr, mm, m, work_shape__, work, rwork_shape__, rwork, info, 
     &fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: s_shape__
        complex*16, dimension(s_shape__(1), s_shape__(2)) :: s
        integer :: lds
        integer, dimension(2) :: p_shape__
        complex*16, dimension(p_shape__(1), p_shape__(2)) :: p
        integer :: ldp
        integer, dimension(2) :: vl_shape__
        complex*16, dimension(vl_shape__(1), vl_shape__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex*16, dimension(vr_shape__(1), vr_shape__(2)) :: vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztgevc
        fw_iserr__ = -1
        if ((lds) .ne. (s_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("s                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldp) .ne. (p_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("p                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztgevc(side, howmny, select, n, s, lds, p, ldp, vl, ldvl, v
     &r, ldvr, mm, m, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ztgevc_c
      subroutine ztgex2_c(wantq, wantz, n, a_shape__, a, lda, b_shape__,
     & b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, j1, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: j1
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztgex2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztgex2(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, j1,
     & info)
        fw_iserr__ = 0
      end subroutine ztgex2_c
      subroutine ztgexc_c(wantq, wantz, n, a_shape__, a, lda, b_shape__,
     & b, ldb, q_shape__, q, ldq, z_shape__, z, ldz, ifst, ilst, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: ifst
        integer :: ilst
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztgexc
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztgexc(wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifs
     &t, ilst, info)
        fw_iserr__ = 0
      end subroutine ztgexc_c
      subroutine ztgsen_c(ijob, wantq, wantz, select_shape__, select, n,
     & a_shape__, a, lda, b_shape__, b, ldb, alpha_shape__, alpha, beta_
     &shape__, beta, q_shape__, q, ldq, z_shape__, z, ldz, m, pl, pr, di
     &f_shape__, dif, work_shape__, work, lwork, iwork_shape__, iwork, l
     &iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: ijob
        integer(kind=kind(0)) :: wantq
        integer(kind=kind(0)) :: wantz
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(1) :: alpha_shape__
        complex*16, dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        complex*16, dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(2) :: z_shape__
        complex*16, dimension(z_shape__(1), z_shape__(2)) :: z
        integer :: ldz
        integer :: m
        real(kind=kind(0.0D0)) :: pl
        real(kind=kind(0.0D0)) :: pr
        integer, dimension(1) :: dif_shape__
        real(kind=kind(0.0D0)), dimension(dif_shape__(1)) :: dif
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: liwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztgsen
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldz) .ne. (z_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("z                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztgsen(ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha
     &, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork
     &, info)
        fw_iserr__ = 0
      end subroutine ztgsen_c
      subroutine ztgsja_c(jobu, jobv, jobq, m, p, n, k, l, a_shape__, a,
     & lda, b_shape__, b, ldb, tola, tolb, alpha_shape__, alpha, beta_sh
     &ape__, beta, u_shape__, u, ldu, v_shape__, v, ldv, q_shape__, q, l
     &dq, work_shape__, work, ncycle, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu
        character(len=1, kind=kind('a')) :: jobv
        character(len=1, kind=kind('a')) :: jobq
        integer :: m
        integer :: p
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        real(kind=kind(0.0D0)) :: tola
        real(kind=kind(0.0D0)) :: tolb
        integer, dimension(1) :: alpha_shape__
        real(kind=kind(0.0D0)), dimension(alpha_shape__(1)) :: alpha
        integer, dimension(1) :: beta_shape__
        real(kind=kind(0.0D0)), dimension(beta_shape__(1)) :: beta
        integer, dimension(2) :: u_shape__
        complex*16, dimension(u_shape__(1), u_shape__(2)) :: u
        integer :: ldu
        integer, dimension(2) :: v_shape__
        complex*16, dimension(v_shape__(1), v_shape__(2)) :: v
        integer :: ldv
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: ncycle
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztgsja
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu) .ne. (u_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv) .ne. (v_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztgsja(jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tol
     &a, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle, info)
        fw_iserr__ = 0
      end subroutine ztgsja_c
      subroutine ztgsna_c(job, howmny, select_shape__, select, n, a_shap
     &e__, a, lda, b_shape__, b, ldb, vl_shape__, vl, ldvl, vr_shape__, 
     &vr, ldvr, s_shape__, s, dif_shape__, dif, mm, m, work_shape__, wor
     &k, lwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: vl_shape__
        complex*16, dimension(vl_shape__(1), vl_shape__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex*16, dimension(vr_shape__(1), vr_shape__(2)) :: vr
        integer :: ldvr
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: dif_shape__
        real(kind=kind(0.0D0)), dimension(dif_shape__(1)) :: dif
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztgsna
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztgsna(job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr
     &, ldvr, s, dif, mm, m, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine ztgsna_c
      subroutine ztgsy2_c(trans, ijob, m, n, a_shape__, a, lda, b_shape_
     &_, b, ldb, c_shape__, c, ldc, d_shape__, d, ldd, e_shape__, e, lde
     &, f_shape__, f, ldf, scale, rdsum, rdscal, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: ijob
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(2) :: d_shape__
        complex*16, dimension(d_shape__(1), d_shape__(2)) :: d
        integer :: ldd
        integer, dimension(2) :: e_shape__
        complex*16, dimension(e_shape__(1), e_shape__(2)) :: e
        integer :: lde
        integer, dimension(2) :: f_shape__
        complex*16, dimension(f_shape__(1), f_shape__(2)) :: f
        integer :: ldf
        real(kind=kind(0.0D0)) :: scale
        real(kind=kind(0.0D0)) :: rdsum
        real(kind=kind(0.0D0)) :: rdscal
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztgsy2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldd) .ne. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lde) .ne. (e_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("e                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztgsy2(trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e
     &, lde, f, ldf, scale, rdsum, rdscal, info)
        fw_iserr__ = 0
      end subroutine ztgsy2_c
      subroutine ztgsyl_c(trans, ijob, m, n, a_shape__, a, lda, b_shape_
     &_, b, ldb, c_shape__, c, ldc, d_shape__, d, ldd, e_shape__, e, lde
     &, f_shape__, f, ldf, scale, dif, work_shape__, work, lwork, iwork_
     &shape__, iwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        integer :: ijob
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(2) :: d_shape__
        complex*16, dimension(d_shape__(1), d_shape__(2)) :: d
        integer :: ldd
        integer, dimension(2) :: e_shape__
        complex*16, dimension(e_shape__(1), e_shape__(2)) :: e
        integer :: lde
        integer, dimension(2) :: f_shape__
        complex*16, dimension(f_shape__(1), f_shape__(2)) :: f
        integer :: ldf
        real(kind=kind(0.0D0)) :: scale
        real(kind=kind(0.0D0)) :: dif
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztgsyl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldd) .ne. (d_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("d                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((lde) .ne. (e_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("e                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldf) .ne. (f_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("f                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztgsyl(trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e
     &, lde, f, ldf, scale, dif, work, lwork, iwork, info)
        fw_iserr__ = 0
      end subroutine ztgsyl_c
      subroutine ztpcon_c(norm, uplo, diag, n, ap_shape__, ap, rcond, wo
     &rk_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errst
     &r__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztpcon
        fw_iserr__ = -1
        call ztpcon(norm, uplo, diag, n, ap, rcond, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ztpcon_c
      subroutine ztprfs_c(uplo, trans, diag, n, nrhs, ap_shape__, ap, b_
     &shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_shape
     &__, berr, work_shape__, work, rwork_shape__, rwork, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztprfs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztprfs(uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr
     &, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ztprfs_c
      subroutine ztptri_c(uplo, diag, n, ap_shape__, ap, info, fw_iserr_
     &_, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztptri
        fw_iserr__ = -1
        call ztptri(uplo, diag, n, ap, info)
        fw_iserr__ = 0
      end subroutine ztptri_c
      subroutine ztptrs_c(uplo, trans, diag, n, nrhs, ap_shape__, ap, b_
     &shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztptrs
        fw_iserr__ = -1
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztptrs(uplo, trans, diag, n, nrhs, ap, b, ldb, info)
        fw_iserr__ = 0
      end subroutine ztptrs_c
      subroutine ztpttf_c(transr, uplo, n, ap_shape__, ap, arf_shape__, 
     &arf, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: arf_shape__
        complex*16, dimension(arf_shape__(1)) :: arf
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztpttf
        fw_iserr__ = -1
        call ztpttf(transr, uplo, n, ap, arf, info)
        fw_iserr__ = 0
      end subroutine ztpttf_c
      subroutine ztpttr_c(uplo, n, ap_shape__, ap, a_shape__, a, lda, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztpttr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztpttr(uplo, n, ap, a, lda, info)
        fw_iserr__ = 0
      end subroutine ztpttr_c
      subroutine ztrcon_c(norm, uplo, diag, n, a_shape__, a, lda, rcond,
     & work_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_er
     &rstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: norm
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        real(kind=kind(0.0D0)) :: rcond
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrcon
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrcon(norm, uplo, diag, n, a, lda, rcond, work, rwork, inf
     &o)
        fw_iserr__ = 0
      end subroutine ztrcon_c
      subroutine ztrevc_c(side, howmny, select_shape__, select, n, t_sha
     &pe__, t, ldt, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, mm, m, w
     &ork_shape__, work, rwork_shape__, rwork, info, fw_iserr__, fw_errs
     &tr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: vl_shape__
        complex*16, dimension(vl_shape__(1), vl_shape__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex*16, dimension(vr_shape__(1), vr_shape__(2)) :: vr
        integer :: ldvr
        integer :: mm
        integer :: m
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrevc
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrevc(side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr,
     & mm, m, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ztrevc_c
      subroutine ztrexc_c(compq, n, t_shape__, t, ldt, q_shape__, q, ldq
     &, ifst, ilst, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: compq
        integer :: n
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer :: ifst
        integer :: ilst
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrexc
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrexc(compq, n, t, ldt, q, ldq, ifst, ilst, info)
        fw_iserr__ = 0
      end subroutine ztrexc_c
      subroutine ztrrfs_c(uplo, trans, diag, n, nrhs, a_shape__, a, lda,
     & b_shape__, b, ldb, x_shape__, x, ldx, ferr_shape__, ferr, berr_sh
     &ape__, berr, work_shape__, work, rwork_shape__, rwork, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: x_shape__
        complex*16, dimension(x_shape__(1), x_shape__(2)) :: x
        integer :: ldx
        integer, dimension(1) :: ferr_shape__
        real(kind=kind(0.0D0)), dimension(ferr_shape__(1)) :: ferr
        integer, dimension(1) :: berr_shape__
        real(kind=kind(0.0D0)), dimension(berr_shape__(1)) :: berr
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrrfs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx) .ne. (x_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrrfs(uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, 
     &ferr, berr, work, rwork, info)
        fw_iserr__ = 0
      end subroutine ztrrfs_c
      subroutine ztrsen_c(job, compq, select_shape__, select, n, t_shape
     &__, t, ldt, q_shape__, q, ldq, w_shape__, w, m, s, sep, work_shape
     &__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: compq
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: w_shape__
        complex*16, dimension(w_shape__(1)) :: w
        integer :: m
        real(kind=kind(0.0D0)) :: s
        real(kind=kind(0.0D0)) :: sep
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrsen
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrsen(job, compq, select, n, t, ldt, q, ldq, w, m, s, sep,
     & work, lwork, info)
        fw_iserr__ = 0
      end subroutine ztrsen_c
      subroutine ztrsna_c(job, howmny, select_shape__, select, n, t_shap
     &e__, t, ldt, vl_shape__, vl, ldvl, vr_shape__, vr, ldvr, s_shape__
     &, s, sep_shape__, sep, mm, m, work_shape__, work, ldwork, rwork_sh
     &ape__, rwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: job
        character(len=1, kind=kind('a')) :: howmny
        integer, dimension(1) :: select_shape__
        integer(kind=kind(0)), dimension(select_shape__(1)) :: select
        integer :: n
        integer, dimension(2) :: t_shape__
        complex*16, dimension(t_shape__(1), t_shape__(2)) :: t
        integer :: ldt
        integer, dimension(2) :: vl_shape__
        complex*16, dimension(vl_shape__(1), vl_shape__(2)) :: vl
        integer :: ldvl
        integer, dimension(2) :: vr_shape__
        complex*16, dimension(vr_shape__(1), vr_shape__(2)) :: vr
        integer :: ldvr
        integer, dimension(1) :: s_shape__
        real(kind=kind(0.0D0)), dimension(s_shape__(1)) :: s
        integer, dimension(1) :: sep_shape__
        real(kind=kind(0.0D0)), dimension(sep_shape__(1)) :: sep
        integer :: mm
        integer :: m
        integer, dimension(2) :: work_shape__
        complex*16, dimension(work_shape__(1), work_shape__(2)) :: work
        integer :: ldwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrsna
        fw_iserr__ = -1
        if ((ldt) .ne. (t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("t                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvl) .ne. (vl_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vl                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldvr) .ne. (vr_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("vr                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldwork) .ne. (work_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("work                                
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrsna(job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, 
     &s, sep, mm, m, work, ldwork, rwork, info)
        fw_iserr__ = 0
      end subroutine ztrsna_c
      subroutine ztrsyl_c(trana, tranb, isgn, m, n, a_shape__, a, lda, b
     &_shape__, b, ldb, c_shape__, c, ldc, scale, info, fw_iserr__, fw_e
     &rrstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trana
        character(len=1, kind=kind('a')) :: tranb
        integer :: isgn
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        real(kind=kind(0.0D0)) :: scale
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrsyl
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, sc
     &ale, info)
        fw_iserr__ = 0
      end subroutine ztrsyl_c
      subroutine ztrti2_c(uplo, diag, n, a_shape__, a, lda, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrti2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrti2(uplo, diag, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine ztrti2_c
      subroutine ztrtri_c(uplo, diag, n, a_shape__, a, lda, info, fw_ise
     &rr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrtri
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrtri(uplo, diag, n, a, lda, info)
        fw_iserr__ = 0
      end subroutine ztrtri_c
      subroutine ztrtrs_c(uplo, trans, diag, n, nrhs, a_shape__, a, lda,
     & b_shape__, b, ldb, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: diag
        integer :: n
        integer :: nrhs
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(2) :: b_shape__
        complex*16, dimension(b_shape__(1), b_shape__(2)) :: b
        integer :: ldb
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrtrs
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldb) .ne. (b_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("b                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrtrs(uplo, trans, diag, n, nrhs, a, lda, b, ldb, info)
        fw_iserr__ = 0
      end subroutine ztrtrs_c
      subroutine ztrttf_c(transr, uplo, n, a_shape__, a, lda, arf_shape_
     &_, arf, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: transr
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: arf_shape__
        complex*16, dimension(arf_shape__(1)) :: arf
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrttf
        fw_iserr__ = -1
        if (((lda-1) - (0) + 1) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrttf(transr, uplo, n, a, lda, arf, info)
        fw_iserr__ = 0
      end subroutine ztrttf_c
      subroutine ztrttp_c(uplo, n, a_shape__, a, lda, ap_shape__, ap, in
     &fo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztrttp
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztrttp(uplo, n, a, lda, ap, info)
        fw_iserr__ = 0
      end subroutine ztrttp_c
      subroutine ztzrqf_c(m, n, a_shape__, a, lda, tau_shape__, tau, inf
     &o, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztzrqf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztzrqf(m, n, a, lda, tau, info)
        fw_iserr__ = 0
      end subroutine ztzrqf_c
      subroutine ztzrzf_c(m, n, a_shape__, a, lda, tau_shape__, tau, wor
     &k_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external ztzrzf
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call ztzrzf(m, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine ztzrzf_c
      subroutine zunbdb_c(trans, signs, m, p, q, x11_shape__, x11, ldx11
     &, x12_shape__, x12, ldx12, x21_shape__, x21, ldx21, x22_shape__, x
     &22, ldx22, theta_shape__, theta, phi_shape__, phi, taup1_shape__, 
     &taup1, taup2_shape__, taup2, tauq1_shape__, tauq1, tauq2_shape__, 
     &tauq2, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: signs
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(2) :: x11_shape__
        complex*16, dimension(x11_shape__(1), x11_shape__(2)) :: x11
        integer :: ldx11
        integer, dimension(2) :: x12_shape__
        complex*16, dimension(x12_shape__(1), x12_shape__(2)) :: x12
        integer :: ldx12
        integer, dimension(2) :: x21_shape__
        complex*16, dimension(x21_shape__(1), x21_shape__(2)) :: x21
        integer :: ldx21
        integer, dimension(2) :: x22_shape__
        complex*16, dimension(x22_shape__(1), x22_shape__(2)) :: x22
        integer :: ldx22
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0D0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(1) :: phi_shape__
        real(kind=kind(0.0D0)), dimension(phi_shape__(1)) :: phi
        integer, dimension(1) :: taup1_shape__
        complex*16, dimension(taup1_shape__(1)) :: taup1
        integer, dimension(1) :: taup2_shape__
        complex*16, dimension(taup2_shape__(1)) :: taup2
        integer, dimension(1) :: tauq1_shape__
        complex*16, dimension(tauq1_shape__(1)) :: tauq1
        integer, dimension(1) :: tauq2_shape__
        complex*16, dimension(tauq2_shape__(1)) :: tauq2
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunbdb
        fw_iserr__ = -1
        if ((ldx11) .ne. (x11_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x11                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx12) .ne. (x12_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x12                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx21) .ne. (x21_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x21                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx22) .ne. (x22_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x22                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunbdb(trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, 
     &ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, l
     &work, info)
        fw_iserr__ = 0
      end subroutine zunbdb_c
      subroutine zuncsd_c(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m,
     & p, q, x11_shape__, x11, ldx11, x12_shape__, x12, ldx12, x21_shape
     &__, x21, ldx21, x22_shape__, x22, ldx22, theta_shape__, theta, u1_
     &shape__, u1, ldu1, u2_shape__, u2, ldu2, v1t_shape__, v1t, ldv1t, 
     &v2t_shape__, v2t, ldv2t, work_shape__, work, lwork, rwork_shape__,
     & rwork, lrwork, iwork_shape__, iwork, info, fw_iserr__, fw_errstr_
     &_)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: jobu1
        character(len=1, kind=kind('a')) :: jobu2
        character(len=1, kind=kind('a')) :: jobv1t
        character(len=1, kind=kind('a')) :: jobv2t
        character(len=1, kind=kind('a')) :: trans
        character(len=1, kind=kind('a')) :: signs
        integer :: m
        integer :: p
        integer :: q
        integer, dimension(2) :: x11_shape__
        complex*16, dimension(x11_shape__(1), x11_shape__(2)) :: x11
        integer :: ldx11
        integer, dimension(2) :: x12_shape__
        complex*16, dimension(x12_shape__(1), x12_shape__(2)) :: x12
        integer :: ldx12
        integer, dimension(2) :: x21_shape__
        complex*16, dimension(x21_shape__(1), x21_shape__(2)) :: x21
        integer :: ldx21
        integer, dimension(2) :: x22_shape__
        complex*16, dimension(x22_shape__(1), x22_shape__(2)) :: x22
        integer :: ldx22
        integer, dimension(1) :: theta_shape__
        real(kind=kind(0.0D0)), dimension(theta_shape__(1)) :: theta
        integer, dimension(2) :: u1_shape__
        complex*16, dimension(u1_shape__(1), u1_shape__(2)) :: u1
        integer :: ldu1
        integer, dimension(2) :: u2_shape__
        complex*16, dimension(u2_shape__(1), u2_shape__(2)) :: u2
        integer :: ldu2
        integer, dimension(2) :: v1t_shape__
        complex*16, dimension(v1t_shape__(1), v1t_shape__(2)) :: v1t
        integer :: ldv1t
        integer, dimension(2) :: v2t_shape__
        complex*16, dimension(v2t_shape__(1), v2t_shape__(2)) :: v2t
        integer :: ldv2t
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer, dimension(1) :: rwork_shape__
        real(kind=kind(0.0D0)), dimension(rwork_shape__(1)) :: rwork
        integer :: lrwork
        integer, dimension(1) :: iwork_shape__
        integer, dimension(iwork_shape__(1)) :: iwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zuncsd
        fw_iserr__ = -1
        if ((ldx11) .ne. (x11_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x11                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx12) .ne. (x12_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x12                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx21) .ne. (x21_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x21                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldx22) .ne. (x22_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("x22                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu1) .ne. (u1_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u1                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldu2) .ne. (u2_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("u2                                  
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv1t) .ne. (v1t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v1t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldv2t) .ne. (v2t_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("v2t                                 
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zuncsd(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q,
     & x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, 
     &u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwor
     &k, info)
        fw_iserr__ = 0
      end subroutine zuncsd_c
      subroutine zung2l_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zung2l
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zung2l(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine zung2l_c
      subroutine zung2r_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zung2r
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zung2r(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine zung2r_c
      subroutine zungbr_c(vect, m, n, k, a_shape__, a, lda, tau_shape__,
     & tau, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zungbr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zungbr(vect, m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zungbr_c
      subroutine zunghr_c(n, ilo, ihi, a_shape__, a, lda, tau_shape__, t
     &au, work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunghr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunghr(n, ilo, ihi, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zunghr_c
      subroutine zungl2_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zungl2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zungl2(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine zungl2_c
      subroutine zunglq_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunglq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunglq(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zunglq_c
      subroutine zungql_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zungql
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zungql(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zungql_c
      subroutine zungqr_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zungqr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zungqr(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zungqr_c
      subroutine zungr2_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zungr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zungr2(m, n, k, a, lda, tau, work, info)
        fw_iserr__ = 0
      end subroutine zungr2_c
      subroutine zungrq_c(m, n, k, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zungrq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zungrq(m, n, k, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zungrq_c
      subroutine zungtr_c(uplo, n, a_shape__, a, lda, tau_shape__, tau, 
     &work_shape__, work, lwork, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zungtr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zungtr(uplo, n, a, lda, tau, work, lwork, info)
        fw_iserr__ = 0
      end subroutine zungtr_c
      subroutine zunm2l_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunm2l
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunm2l(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine zunm2l_c
      subroutine zunm2r_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunm2r
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunm2r(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine zunm2r_c
      subroutine zunmbr_c(vect, side, trans, m, n, k, a_shape__, a, lda,
     & tau_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, i
     &nfo, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: vect
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunmbr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunmbr(vect, side, trans, m, n, k, a, lda, tau, c, ldc, wor
     &k, lwork, info)
        fw_iserr__ = 0
      end subroutine zunmbr_c
      subroutine zunmhr_c(side, trans, m, n, ilo, ihi, a_shape__, a, lda
     &, tau_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, 
     &info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: ilo
        integer :: ihi
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunmhr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunmhr(side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, wo
     &rk, lwork, info)
        fw_iserr__ = 0
      end subroutine zunmhr_c
      subroutine zunml2_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunml2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunml2(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine zunml2_c
      subroutine zunmlq_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunmlq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunmlq(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine zunmlq_c
      subroutine zunmql_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunmql
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunmql(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine zunmql_c
      subroutine zunmqr_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunmqr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunmqr(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine zunmqr_c
      subroutine zunmr2_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunmr2
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunmr2(side, trans, m, n, k, a, lda, tau, c, ldc, work, inf
     &o)
        fw_iserr__ = 0
      end subroutine zunmr2_c
      subroutine zunmr3_c(side, trans, m, n, k, l, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_is
     &err__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunmr3
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunmr3(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, 
     &info)
        fw_iserr__ = 0
      end subroutine zunmr3_c
      subroutine zunmrq_c(side, trans, m, n, k, a_shape__, a, lda, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info, f
     &w_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunmrq
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunmrq(side, trans, m, n, k, a, lda, tau, c, ldc, work, lwo
     &rk, info)
        fw_iserr__ = 0
      end subroutine zunmrq_c
      subroutine zunmrz_c(side, trans, m, n, k, l, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer :: k
        integer :: l
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunmrz
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunmrz(side, trans, m, n, k, l, a, lda, tau, c, ldc, work, 
     &lwork, info)
        fw_iserr__ = 0
      end subroutine zunmrz_c
      subroutine zunmtr_c(side, uplo, trans, m, n, a_shape__, a, lda, ta
     &u_shape__, tau, c_shape__, c, ldc, work_shape__, work, lwork, info
     &, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer, dimension(2) :: a_shape__
        complex*16, dimension(a_shape__(1), a_shape__(2)) :: a
        integer :: lda
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: lwork
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zunmtr
        fw_iserr__ = -1
        if ((lda) .ne. (a_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("a                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zunmtr(side, uplo, trans, m, n, a, lda, tau, c, ldc, work, 
     &lwork, info)
        fw_iserr__ = 0
      end subroutine zunmtr_c
      subroutine zupgtr_c(uplo, n, ap_shape__, ap, tau_shape__, tau, q_s
     &hape__, q, ldq, work_shape__, work, info, fw_iserr__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: uplo
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: q_shape__
        complex*16, dimension(q_shape__(1), q_shape__(2)) :: q
        integer :: ldq
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zupgtr
        fw_iserr__ = -1
        if ((ldq) .ne. (q_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("q                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zupgtr(uplo, n, ap, tau, q, ldq, work, info)
        fw_iserr__ = 0
      end subroutine zupgtr_c
      subroutine zupmtr_c(side, uplo, trans, m, n, ap_shape__, ap, tau_s
     &hape__, tau, c_shape__, c, ldc, work_shape__, work, info, fw_iserr
     &__, fw_errstr__)
        implicit none
        integer FW_ARR_DIM__
        parameter (FW_ARR_DIM__ = 2)
        integer FW_CHAR_SIZE__
        parameter (FW_CHAR_SIZE__ = 1)
        integer FW_INIT_ERR__
        parameter (FW_INIT_ERR__ = -1)
        integer FW_NO_ERR__
        parameter (FW_NO_ERR__ = 0)
        integer fw_errstr_len
        parameter (fw_errstr_len = 63)
        character C_NULL_CHAR
        parameter (C_NULL_CHAR = '\0')
        character(len=1, kind=kind('a')) :: side
        character(len=1, kind=kind('a')) :: uplo
        character(len=1, kind=kind('a')) :: trans
        integer :: m
        integer :: n
        integer, dimension(1) :: ap_shape__
        complex*16, dimension(ap_shape__(1)) :: ap
        integer, dimension(1) :: tau_shape__
        complex*16, dimension(tau_shape__(1)) :: tau
        integer, dimension(2) :: c_shape__
        complex*16, dimension(c_shape__(1), c_shape__(2)) :: c
        integer :: ldc
        integer, dimension(1) :: work_shape__
        complex*16, dimension(work_shape__(1)) :: work
        integer :: info
        integer :: fw_iserr__
        character(len=1, kind=kind('a')), dimension(63) :: fw_errstr__
        external zupmtr
        fw_iserr__ = -1
        if ((ldc) .ne. (c_shape__(1))) then
            fw_iserr__ = FW_ARR_DIM__
            fw_errstr__ = transfer("c                                   
     &                           ", fw_errstr__)
            fw_errstr__(fw_errstr_len) = C_NULL_CHAR
            return
        endif
        call zupmtr(side, uplo, trans, m, n, ap, tau, c, ldc, work, info
     &)
        fw_iserr__ = 0
      end subroutine zupmtr_c
